// Copyright (C) 2005-2008 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "SCL_BaseTypes.h"

namespace IEC61850
{
  namespace SCL
  {
    // tBaseElement
    // 

    const tBaseElement::Text_optional& tBaseElement::
    Text () const
    {
      return this->Text_;
    }

    tBaseElement::Text_optional& tBaseElement::
    Text ()
    {
      return this->Text_;
    }

    void tBaseElement::
    Text (const Text_type& x)
    {
      this->Text_.set (x);
    }

    void tBaseElement::
    Text (const Text_optional& x)
    {
      this->Text_ = x;
    }

    void tBaseElement::
    Text (::std::auto_ptr< Text_type > x)
    {
      this->Text_.set (x);
    }

    const tBaseElement::Private_sequence& tBaseElement::
    Private () const
    {
      return this->Private_;
    }

    tBaseElement::Private_sequence& tBaseElement::
    Private ()
    {
      return this->Private_;
    }

    void tBaseElement::
    Private (const Private_sequence& s)
    {
      this->Private_ = s;
    }


    // tUnNaming
    // 

    const tUnNaming::desc_optional& tUnNaming::
    desc () const
    {
      return this->desc_;
    }

    tUnNaming::desc_optional& tUnNaming::
    desc ()
    {
      return this->desc_;
    }

    void tUnNaming::
    desc (const desc_type& x)
    {
      this->desc_.set (x);
    }

    void tUnNaming::
    desc (const desc_optional& x)
    {
      this->desc_ = x;
    }

    void tUnNaming::
    desc (::std::auto_ptr< desc_type > x)
    {
      this->desc_.set (x);
    }


    // tNaming
    // 

    const tNaming::name_type& tNaming::
    name () const
    {
      return this->name_.get ();
    }

    tNaming::name_type& tNaming::
    name ()
    {
      return this->name_.get ();
    }

    void tNaming::
    name (const name_type& x)
    {
      this->name_.set (x);
    }

    void tNaming::
    name (::std::auto_ptr< name_type > x)
    {
      this->name_.set (x);
    }

    const tNaming::desc_optional& tNaming::
    desc () const
    {
      return this->desc_;
    }

    tNaming::desc_optional& tNaming::
    desc ()
    {
      return this->desc_;
    }

    void tNaming::
    desc (const desc_type& x)
    {
      this->desc_.set (x);
    }

    void tNaming::
    desc (const desc_optional& x)
    {
      this->desc_ = x;
    }

    void tNaming::
    desc (::std::auto_ptr< desc_type > x)
    {
      this->desc_.set (x);
    }


    // tIDNaming
    // 

    const tIDNaming::id_type& tIDNaming::
    id () const
    {
      return this->id_.get ();
    }

    tIDNaming::id_type& tIDNaming::
    id ()
    {
      return this->id_.get ();
    }

    void tIDNaming::
    id (const id_type& x)
    {
      this->id_.set (x);
    }

    void tIDNaming::
    id (::std::auto_ptr< id_type > x)
    {
      this->id_.set (x);
    }

    const tIDNaming::desc_optional& tIDNaming::
    desc () const
    {
      return this->desc_;
    }

    tIDNaming::desc_optional& tIDNaming::
    desc ()
    {
      return this->desc_;
    }

    void tIDNaming::
    desc (const desc_type& x)
    {
      this->desc_.set (x);
    }

    void tIDNaming::
    desc (const desc_optional& x)
    {
      this->desc_ = x;
    }

    void tIDNaming::
    desc (::std::auto_ptr< desc_type > x)
    {
      this->desc_.set (x);
    }


    // tAnyContentFromOtherNamespace
    // 


    // tText
    // 

    const tText::source_optional& tText::
    source () const
    {
      return this->source_;
    }

    tText::source_optional& tText::
    source ()
    {
      return this->source_;
    }

    void tText::
    source (const source_type& x)
    {
      this->source_.set (x);
    }

    void tText::
    source (const source_optional& x)
    {
      this->source_ = x;
    }

    void tText::
    source (::std::auto_ptr< source_type > x)
    {
      this->source_.set (x);
    }


    // tPrivate
    // 

    const tPrivate::type_optional& tPrivate::
    type () const
    {
      return this->type_;
    }

    tPrivate::type_optional& tPrivate::
    type ()
    {
      return this->type_;
    }

    void tPrivate::
    type (const type_type& x)
    {
      this->type_.set (x);
    }

    void tPrivate::
    type (const type_optional& x)
    {
      this->type_ = x;
    }

    void tPrivate::
    type (::std::auto_ptr< type_type > x)
    {
      this->type_.set (x);
    }

    const tPrivate::source_optional& tPrivate::
    source () const
    {
      return this->source_;
    }

    tPrivate::source_optional& tPrivate::
    source ()
    {
      return this->source_;
    }

    void tPrivate::
    source (const source_type& x)
    {
      this->source_.set (x);
    }

    void tPrivate::
    source (const source_optional& x)
    {
      this->source_ = x;
    }

    void tPrivate::
    source (::std::auto_ptr< source_type > x)
    {
      this->source_.set (x);
    }


    // tHeader
    // 

    const tHeader::Text_optional& tHeader::
    Text () const
    {
      return this->Text_;
    }

    tHeader::Text_optional& tHeader::
    Text ()
    {
      return this->Text_;
    }

    void tHeader::
    Text (const Text_type& x)
    {
      this->Text_.set (x);
    }

    void tHeader::
    Text (const Text_optional& x)
    {
      this->Text_ = x;
    }

    void tHeader::
    Text (::std::auto_ptr< Text_type > x)
    {
      this->Text_.set (x);
    }

    const tHeader::History_optional& tHeader::
    History () const
    {
      return this->History_;
    }

    tHeader::History_optional& tHeader::
    History ()
    {
      return this->History_;
    }

    void tHeader::
    History (const History_type& x)
    {
      this->History_.set (x);
    }

    void tHeader::
    History (const History_optional& x)
    {
      this->History_ = x;
    }

    void tHeader::
    History (::std::auto_ptr< History_type > x)
    {
      this->History_.set (x);
    }

    const tHeader::id_type& tHeader::
    id () const
    {
      return this->id_.get ();
    }

    tHeader::id_type& tHeader::
    id ()
    {
      return this->id_.get ();
    }

    void tHeader::
    id (const id_type& x)
    {
      this->id_.set (x);
    }

    void tHeader::
    id (::std::auto_ptr< id_type > x)
    {
      this->id_.set (x);
    }

    const tHeader::version_optional& tHeader::
    version () const
    {
      return this->version_;
    }

    tHeader::version_optional& tHeader::
    version ()
    {
      return this->version_;
    }

    void tHeader::
    version (const version_type& x)
    {
      this->version_.set (x);
    }

    void tHeader::
    version (const version_optional& x)
    {
      this->version_ = x;
    }

    void tHeader::
    version (::std::auto_ptr< version_type > x)
    {
      this->version_.set (x);
    }

    const tHeader::revision_optional& tHeader::
    revision () const
    {
      return this->revision_;
    }

    tHeader::revision_optional& tHeader::
    revision ()
    {
      return this->revision_;
    }

    void tHeader::
    revision (const revision_type& x)
    {
      this->revision_.set (x);
    }

    void tHeader::
    revision (const revision_optional& x)
    {
      this->revision_ = x;
    }

    void tHeader::
    revision (::std::auto_ptr< revision_type > x)
    {
      this->revision_.set (x);
    }

    const tHeader::toolID_optional& tHeader::
    toolID () const
    {
      return this->toolID_;
    }

    tHeader::toolID_optional& tHeader::
    toolID ()
    {
      return this->toolID_;
    }

    void tHeader::
    toolID (const toolID_type& x)
    {
      this->toolID_.set (x);
    }

    void tHeader::
    toolID (const toolID_optional& x)
    {
      this->toolID_ = x;
    }

    void tHeader::
    toolID (::std::auto_ptr< toolID_type > x)
    {
      this->toolID_.set (x);
    }

    const tHeader::nameStructure_type& tHeader::
    nameStructure () const
    {
      return this->nameStructure_.get ();
    }

    tHeader::nameStructure_type& tHeader::
    nameStructure ()
    {
      return this->nameStructure_.get ();
    }

    void tHeader::
    nameStructure (const nameStructure_type& x)
    {
      this->nameStructure_.set (x);
    }

    void tHeader::
    nameStructure (::std::auto_ptr< nameStructure_type > x)
    {
      this->nameStructure_.set (x);
    }

    const tHeader::nameStructure_type& tHeader::
    nameStructure_default_value ()
    {
      return nameStructure_default_value_;
    }


    // tHitem
    // 

    const tHitem::version_type& tHitem::
    version () const
    {
      return this->version_.get ();
    }

    tHitem::version_type& tHitem::
    version ()
    {
      return this->version_.get ();
    }

    void tHitem::
    version (const version_type& x)
    {
      this->version_.set (x);
    }

    void tHitem::
    version (::std::auto_ptr< version_type > x)
    {
      this->version_.set (x);
    }

    const tHitem::revision_type& tHitem::
    revision () const
    {
      return this->revision_.get ();
    }

    tHitem::revision_type& tHitem::
    revision ()
    {
      return this->revision_.get ();
    }

    void tHitem::
    revision (const revision_type& x)
    {
      this->revision_.set (x);
    }

    void tHitem::
    revision (::std::auto_ptr< revision_type > x)
    {
      this->revision_.set (x);
    }

    const tHitem::when_type& tHitem::
    when () const
    {
      return this->when_.get ();
    }

    tHitem::when_type& tHitem::
    when ()
    {
      return this->when_.get ();
    }

    void tHitem::
    when (const when_type& x)
    {
      this->when_.set (x);
    }

    void tHitem::
    when (::std::auto_ptr< when_type > x)
    {
      this->when_.set (x);
    }

    const tHitem::who_optional& tHitem::
    who () const
    {
      return this->who_;
    }

    tHitem::who_optional& tHitem::
    who ()
    {
      return this->who_;
    }

    void tHitem::
    who (const who_type& x)
    {
      this->who_.set (x);
    }

    void tHitem::
    who (const who_optional& x)
    {
      this->who_ = x;
    }

    void tHitem::
    who (::std::auto_ptr< who_type > x)
    {
      this->who_.set (x);
    }

    const tHitem::what_optional& tHitem::
    what () const
    {
      return this->what_;
    }

    tHitem::what_optional& tHitem::
    what ()
    {
      return this->what_;
    }

    void tHitem::
    what (const what_type& x)
    {
      this->what_.set (x);
    }

    void tHitem::
    what (const what_optional& x)
    {
      this->what_ = x;
    }

    void tHitem::
    what (::std::auto_ptr< what_type > x)
    {
      this->what_.set (x);
    }

    const tHitem::why_optional& tHitem::
    why () const
    {
      return this->why_;
    }

    tHitem::why_optional& tHitem::
    why ()
    {
      return this->why_;
    }

    void tHitem::
    why (const why_type& x)
    {
      this->why_.set (x);
    }

    void tHitem::
    why (const why_optional& x)
    {
      this->why_ = x;
    }

    void tHitem::
    why (::std::auto_ptr< why_type > x)
    {
      this->why_.set (x);
    }


    // tVal
    // 

    const tVal::sGroup_optional& tVal::
    sGroup () const
    {
      return this->sGroup_;
    }

    tVal::sGroup_optional& tVal::
    sGroup ()
    {
      return this->sGroup_;
    }

    void tVal::
    sGroup (const sGroup_type& x)
    {
      this->sGroup_.set (x);
    }

    void tVal::
    sGroup (const sGroup_optional& x)
    {
      this->sGroup_ = x;
    }


    // tValueWithUnit
    // 

    const tValueWithUnit::unit_type& tValueWithUnit::
    unit () const
    {
      return this->unit_.get ();
    }

    tValueWithUnit::unit_type& tValueWithUnit::
    unit ()
    {
      return this->unit_.get ();
    }

    void tValueWithUnit::
    unit (const unit_type& x)
    {
      this->unit_.set (x);
    }

    void tValueWithUnit::
    unit (::std::auto_ptr< unit_type > x)
    {
      this->unit_.set (x);
    }

    const tValueWithUnit::multiplier_optional& tValueWithUnit::
    multiplier () const
    {
      return this->multiplier_;
    }

    tValueWithUnit::multiplier_optional& tValueWithUnit::
    multiplier ()
    {
      return this->multiplier_;
    }

    void tValueWithUnit::
    multiplier (const multiplier_type& x)
    {
      this->multiplier_.set (x);
    }

    void tValueWithUnit::
    multiplier (const multiplier_optional& x)
    {
      this->multiplier_ = x;
    }

    void tValueWithUnit::
    multiplier (::std::auto_ptr< multiplier_type > x)
    {
      this->multiplier_.set (x);
    }


    // tVoltage
    // 


    // tBitRateInMbPerSec
    // 


    // tDurationInSec
    // 


    // tDurationInMilliSec
    // 


    // History
    // 

    const History::Hitem_sequence& History::
    Hitem () const
    {
      return this->Hitem_;
    }

    History::Hitem_sequence& History::
    Hitem ()
    {
      return this->Hitem_;
    }

    void History::
    Hitem (const Hitem_sequence& s)
    {
      this->Hitem_ = s;
    }


    // nameStructure
    // 

    nameStructure::
    nameStructure (value v)
    : ::xml_schema::name (_xsd_nameStructure_literals_[v])
    {
    }

    nameStructure::
    nameStructure (const char* v)
    : ::xml_schema::name (v)
    {
    }

    nameStructure::
    nameStructure (const ::std::string& v)
    : ::xml_schema::name (v)
    {
    }

    nameStructure::
    nameStructure (const ::xml_schema::name& v)
    : ::xml_schema::name (v)
    {
    }

    nameStructure::
    nameStructure (const nameStructure& v,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xml_schema::name (v, f, c)
    {
    }

    nameStructure& nameStructure::
    operator= (value v)
    {
      static_cast< ::xml_schema::name& > (*this) = 
      ::xml_schema::name (_xsd_nameStructure_literals_[v]);

      return *this;
    }
  }
}

#include <xsd/cxx/xml/dom/parsing-source.hxx>

namespace IEC61850
{
  namespace SCL
  {
    // tBaseElement
    //

    tBaseElement::
    tBaseElement ()
    : ::xml_schema::type (),
      Text_ (::xml_schema::flags (), this),
      Private_ (::xml_schema::flags (), this)
    {
    }

    tBaseElement::
    tBaseElement (const tBaseElement& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Text_ (x.Text_, f, this),
      Private_ (x.Private_, f, this)
    {
    }

    tBaseElement::
    tBaseElement (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Text_ (f, this),
      Private_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void tBaseElement::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Text
        //
        if (n.name () == "Text" && n.namespace_ () == "http://www.iec.ch/61850/2003/SCL")
        {
          ::std::auto_ptr< Text_type > r (
            Text_traits::create (i, f, this));

          if (!this->Text_)
          {
            this->Text_.set (r);
            continue;
          }
        }

        // Private
        //
        if (n.name () == "Private" && n.namespace_ () == "http://www.iec.ch/61850/2003/SCL")
        {
          ::std::auto_ptr< Private_type > r (
            Private_traits::create (i, f, this));

          this->Private_.push_back (r);
          continue;
        }

        break;
      }
    }

    tBaseElement* tBaseElement::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class tBaseElement (*this, f, c);
    }

    tBaseElement::
    ~tBaseElement ()
    {
    }

    // tUnNaming
    //

    tUnNaming::
    tUnNaming ()
    : ::IEC61850::SCL::tBaseElement (),
      desc_ (::xml_schema::flags (), this)
    {
    }

    tUnNaming::
    tUnNaming (const tUnNaming& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
    : ::IEC61850::SCL::tBaseElement (x, f, c),
      desc_ (x.desc_, f, this)
    {
    }

    tUnNaming::
    tUnNaming (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
    : ::IEC61850::SCL::tBaseElement (e, f | ::xml_schema::flags::base, c),
      desc_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void tUnNaming::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::IEC61850::SCL::tBaseElement::parse (p, f);

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "desc" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< desc_type > r (
            desc_traits::create (i, f, this));

          this->desc_.set (r);
          continue;
        }
      }
    }

    tUnNaming* tUnNaming::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class tUnNaming (*this, f, c);
    }

    tUnNaming::
    ~tUnNaming ()
    {
    }

    // tNaming
    //

    tNaming::
    tNaming (const name_type& name)
    : ::IEC61850::SCL::tBaseElement (),
      name_ (name, ::xml_schema::flags (), this),
      desc_ (::xml_schema::flags (), this)
    {
    }

    tNaming::
    tNaming (const tNaming& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
    : ::IEC61850::SCL::tBaseElement (x, f, c),
      name_ (x.name_, f, this),
      desc_ (x.desc_, f, this)
    {
    }

    tNaming::
    tNaming (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
    : ::IEC61850::SCL::tBaseElement (e, f | ::xml_schema::flags::base, c),
      name_ (f, this),
      desc_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void tNaming::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::IEC61850::SCL::tBaseElement::parse (p, f);

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "name" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< name_type > r (
            name_traits::create (i, f, this));

          this->name_.set (r);
          continue;
        }

        if (n.name () == "desc" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< desc_type > r (
            desc_traits::create (i, f, this));

          this->desc_.set (r);
          continue;
        }
      }

      if (!name_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "name",
          "");
      }
    }

    tNaming* tNaming::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class tNaming (*this, f, c);
    }

    tNaming::
    ~tNaming ()
    {
    }

    // tIDNaming
    //

    tIDNaming::
    tIDNaming (const id_type& id)
    : ::IEC61850::SCL::tBaseElement (),
      id_ (id, ::xml_schema::flags (), this),
      desc_ (::xml_schema::flags (), this)
    {
    }

    tIDNaming::
    tIDNaming (const tIDNaming& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
    : ::IEC61850::SCL::tBaseElement (x, f, c),
      id_ (x.id_, f, this),
      desc_ (x.desc_, f, this)
    {
    }

    tIDNaming::
    tIDNaming (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
    : ::IEC61850::SCL::tBaseElement (e, f | ::xml_schema::flags::base, c),
      id_ (f, this),
      desc_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void tIDNaming::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::IEC61850::SCL::tBaseElement::parse (p, f);

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "id" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< id_type > r (
            id_traits::create (i, f, this));

          this->id_.set (r);
          continue;
        }

        if (n.name () == "desc" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< desc_type > r (
            desc_traits::create (i, f, this));

          this->desc_.set (r);
          continue;
        }
      }

      if (!id_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "id",
          "");
      }
    }

    tIDNaming* tIDNaming::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class tIDNaming (*this, f, c);
    }

    tIDNaming::
    ~tIDNaming ()
    {
    }

    // tAnyContentFromOtherNamespace
    //

    tAnyContentFromOtherNamespace::
    tAnyContentFromOtherNamespace ()
    : ::xml_schema::type ()
    {
    }

    tAnyContentFromOtherNamespace::
    tAnyContentFromOtherNamespace (const tAnyContentFromOtherNamespace& x,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c)
    {
    }

    tAnyContentFromOtherNamespace::
    tAnyContentFromOtherNamespace (const ::xercesc::DOMElement& e,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void tAnyContentFromOtherNamespace::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        break;
      }
    }

    tAnyContentFromOtherNamespace* tAnyContentFromOtherNamespace::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class tAnyContentFromOtherNamespace (*this, f, c);
    }

    tAnyContentFromOtherNamespace::
    ~tAnyContentFromOtherNamespace ()
    {
    }

    // tText
    //

    tText::
    tText ()
    : ::IEC61850::SCL::tAnyContentFromOtherNamespace (),
      source_ (::xml_schema::flags (), this)
    {
    }

    tText::
    tText (const tText& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
    : ::IEC61850::SCL::tAnyContentFromOtherNamespace (x, f, c),
      source_ (x.source_, f, this)
    {
    }

    tText::
    tText (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
    : ::IEC61850::SCL::tAnyContentFromOtherNamespace (e, f | ::xml_schema::flags::base, c),
      source_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void tText::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::IEC61850::SCL::tAnyContentFromOtherNamespace::parse (p, f);

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "source" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< source_type > r (
            source_traits::create (i, f, this));

          this->source_.set (r);
          continue;
        }
      }
    }

    tText* tText::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class tText (*this, f, c);
    }

    tText::
    ~tText ()
    {
    }

    // tPrivate
    //

    tPrivate::
    tPrivate ()
    : ::IEC61850::SCL::tAnyContentFromOtherNamespace (),
      type_ (::xml_schema::flags (), this),
      source_ (::xml_schema::flags (), this)
    {
    }

    tPrivate::
    tPrivate (const tPrivate& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
    : ::IEC61850::SCL::tAnyContentFromOtherNamespace (x, f, c),
      type_ (x.type_, f, this),
      source_ (x.source_, f, this)
    {
    }

    tPrivate::
    tPrivate (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
    : ::IEC61850::SCL::tAnyContentFromOtherNamespace (e, f | ::xml_schema::flags::base, c),
      type_ (f, this),
      source_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void tPrivate::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::IEC61850::SCL::tAnyContentFromOtherNamespace::parse (p, f);

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "type" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< type_type > r (
            type_traits::create (i, f, this));

          this->type_.set (r);
          continue;
        }

        if (n.name () == "source" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< source_type > r (
            source_traits::create (i, f, this));

          this->source_.set (r);
          continue;
        }
      }
    }

    tPrivate* tPrivate::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class tPrivate (*this, f, c);
    }

    tPrivate::
    ~tPrivate ()
    {
    }

    // tHeader
    //

    const tHeader::nameStructure_type tHeader::nameStructure_default_value_ (
      ::std::string ("IEDName"), 0, 0, 0);

    tHeader::
    tHeader (const id_type& id)
    : ::xml_schema::type (),
      Text_ (::xml_schema::flags (), this),
      History_ (::xml_schema::flags (), this),
      id_ (id, ::xml_schema::flags (), this),
      version_ (::xml_schema::flags (), this),
      revision_ (::xml_schema::flags (), this),
      toolID_ (::xml_schema::flags (), this),
      nameStructure_ (nameStructure_default_value (), ::xml_schema::flags (), this)
    {
    }

    tHeader::
    tHeader (const tHeader& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Text_ (x.Text_, f, this),
      History_ (x.History_, f, this),
      id_ (x.id_, f, this),
      version_ (x.version_, f, this),
      revision_ (x.revision_, f, this),
      toolID_ (x.toolID_, f, this),
      nameStructure_ (x.nameStructure_, f, this)
    {
    }

    tHeader::
    tHeader (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Text_ (f, this),
      History_ (f, this),
      id_ (f, this),
      version_ (f, this),
      revision_ (f, this),
      toolID_ (f, this),
      nameStructure_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void tHeader::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Text
        //
        if (n.name () == "Text" && n.namespace_ () == "http://www.iec.ch/61850/2003/SCL")
        {
          ::std::auto_ptr< Text_type > r (
            Text_traits::create (i, f, this));

          if (!this->Text_)
          {
            this->Text_.set (r);
            continue;
          }
        }

        // History
        //
        if (n.name () == "History" && n.namespace_ () == "http://www.iec.ch/61850/2003/SCL")
        {
          ::std::auto_ptr< History_type > r (
            History_traits::create (i, f, this));

          if (!this->History_)
          {
            this->History_.set (r);
            continue;
          }
        }

        break;
      }

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "id" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< id_type > r (
            id_traits::create (i, f, this));

          this->id_.set (r);
          continue;
        }

        if (n.name () == "version" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< version_type > r (
            version_traits::create (i, f, this));

          this->version_.set (r);
          continue;
        }

        if (n.name () == "revision" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< revision_type > r (
            revision_traits::create (i, f, this));

          this->revision_.set (r);
          continue;
        }

        if (n.name () == "toolID" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< toolID_type > r (
            toolID_traits::create (i, f, this));

          this->toolID_.set (r);
          continue;
        }

        if (n.name () == "nameStructure" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< nameStructure_type > r (
            nameStructure_traits::create (i, f, this));

          this->nameStructure_.set (r);
          continue;
        }
      }

      if (!id_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "id",
          "");
      }

      if (!nameStructure_.present ())
      {
        this->nameStructure_.set (nameStructure_default_value ());
      }
    }

    tHeader* tHeader::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class tHeader (*this, f, c);
    }

    tHeader::
    ~tHeader ()
    {
    }

    // tHitem
    //

    tHitem::
    tHitem (const version_type& version,
            const revision_type& revision,
            const when_type& when)
    : ::IEC61850::SCL::tAnyContentFromOtherNamespace (),
      version_ (version, ::xml_schema::flags (), this),
      revision_ (revision, ::xml_schema::flags (), this),
      when_ (when, ::xml_schema::flags (), this),
      who_ (::xml_schema::flags (), this),
      what_ (::xml_schema::flags (), this),
      why_ (::xml_schema::flags (), this)
    {
    }

    tHitem::
    tHitem (const tHitem& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
    : ::IEC61850::SCL::tAnyContentFromOtherNamespace (x, f, c),
      version_ (x.version_, f, this),
      revision_ (x.revision_, f, this),
      when_ (x.when_, f, this),
      who_ (x.who_, f, this),
      what_ (x.what_, f, this),
      why_ (x.why_, f, this)
    {
    }

    tHitem::
    tHitem (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
    : ::IEC61850::SCL::tAnyContentFromOtherNamespace (e, f | ::xml_schema::flags::base, c),
      version_ (f, this),
      revision_ (f, this),
      when_ (f, this),
      who_ (f, this),
      what_ (f, this),
      why_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void tHitem::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::IEC61850::SCL::tAnyContentFromOtherNamespace::parse (p, f);

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "version" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< version_type > r (
            version_traits::create (i, f, this));

          this->version_.set (r);
          continue;
        }

        if (n.name () == "revision" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< revision_type > r (
            revision_traits::create (i, f, this));

          this->revision_.set (r);
          continue;
        }

        if (n.name () == "when" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< when_type > r (
            when_traits::create (i, f, this));

          this->when_.set (r);
          continue;
        }

        if (n.name () == "who" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< who_type > r (
            who_traits::create (i, f, this));

          this->who_.set (r);
          continue;
        }

        if (n.name () == "what" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< what_type > r (
            what_traits::create (i, f, this));

          this->what_.set (r);
          continue;
        }

        if (n.name () == "why" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< why_type > r (
            why_traits::create (i, f, this));

          this->why_.set (r);
          continue;
        }
      }

      if (!version_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "version",
          "");
      }

      if (!revision_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "revision",
          "");
      }

      if (!when_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "when",
          "");
      }
    }

    tHitem* tHitem::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class tHitem (*this, f, c);
    }

    tHitem::
    ~tHitem ()
    {
    }

    // tVal
    //

    tVal::
    tVal ()
    : ::xml_schema::normalized_string (),
      sGroup_ (::xml_schema::flags (), this)
    {
    }

    tVal::
    tVal (const char* _xsd_normalized_string_base)
    : ::xml_schema::normalized_string (_xsd_normalized_string_base),
      sGroup_ (::xml_schema::flags (), this)
    {
    }

    tVal::
    tVal (const ::std::string& _xsd_normalized_string_base)
    : ::xml_schema::normalized_string (_xsd_normalized_string_base),
      sGroup_ (::xml_schema::flags (), this)
    {
    }

    tVal::
    tVal (const ::xml_schema::normalized_string& _xsd_normalized_string_base)
    : ::xml_schema::normalized_string (_xsd_normalized_string_base),
      sGroup_ (::xml_schema::flags (), this)
    {
    }

    tVal::
    tVal (const tVal& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
    : ::xml_schema::normalized_string (x, f, c),
      sGroup_ (x.sGroup_, f, this)
    {
    }

    tVal::
    tVal (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
    : ::xml_schema::normalized_string (e, f | ::xml_schema::flags::base, c),
      sGroup_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
        this->parse (p, f);
      }
    }

    void tVal::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "sGroup" && n.namespace_ ().empty ())
        {
          this->sGroup_.set (sGroup_traits::create (i, f, this));
          continue;
        }
      }
    }

    tVal* tVal::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class tVal (*this, f, c);
    }

    tVal::
    ~tVal ()
    {
    }

    // tValueWithUnit
    //

    tValueWithUnit::
    tValueWithUnit (const ::xml_schema::decimal& _xsd_decimal_base,
                    const unit_type& unit)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (_xsd_decimal_base),
      unit_ (unit, ::xml_schema::flags (), this),
      multiplier_ (::xml_schema::flags (), this)
    {
    }

    tValueWithUnit::
    tValueWithUnit (const tValueWithUnit& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (x, f, c),
      unit_ (x.unit_, f, this),
      multiplier_ (x.multiplier_, f, this)
    {
    }

    tValueWithUnit::
    tValueWithUnit (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (e, f | ::xml_schema::flags::base, c),
      unit_ (f, this),
      multiplier_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
        this->parse (p, f);
      }
    }

    void tValueWithUnit::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "unit" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< unit_type > r (
            unit_traits::create (i, f, this));

          this->unit_.set (r);
          continue;
        }

        if (n.name () == "multiplier" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< multiplier_type > r (
            multiplier_traits::create (i, f, this));

          this->multiplier_.set (r);
          continue;
        }
      }

      if (!unit_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "unit",
          "");
      }
    }

    tValueWithUnit* tValueWithUnit::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class tValueWithUnit (*this, f, c);
    }

    tValueWithUnit::
    ~tValueWithUnit ()
    {
    }

    // tVoltage
    //

    tVoltage::
    tVoltage (const ::xml_schema::decimal& _xsd_decimal_base,
              const unit_type& unit)
    : ::IEC61850::SCL::tValueWithUnit (_xsd_decimal_base,
                                       unit)
    {
    }

    tVoltage::
    tVoltage (const tVoltage& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
    : ::IEC61850::SCL::tValueWithUnit (x, f, c)
    {
    }

    tVoltage::
    tVoltage (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
    : ::IEC61850::SCL::tValueWithUnit (e, f, c)
    {
    }

    tVoltage* tVoltage::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class tVoltage (*this, f, c);
    }

    tVoltage::
    ~tVoltage ()
    {
    }

    // tBitRateInMbPerSec
    //

    tBitRateInMbPerSec::
    tBitRateInMbPerSec (const ::xml_schema::decimal& _xsd_decimal_base,
                        const unit_type& unit)
    : ::IEC61850::SCL::tValueWithUnit (_xsd_decimal_base,
                                       unit)
    {
    }

    tBitRateInMbPerSec::
    tBitRateInMbPerSec (const tBitRateInMbPerSec& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::IEC61850::SCL::tValueWithUnit (x, f, c)
    {
    }

    tBitRateInMbPerSec::
    tBitRateInMbPerSec (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::IEC61850::SCL::tValueWithUnit (e, f, c)
    {
    }

    tBitRateInMbPerSec* tBitRateInMbPerSec::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class tBitRateInMbPerSec (*this, f, c);
    }

    tBitRateInMbPerSec::
    ~tBitRateInMbPerSec ()
    {
    }

    // tDurationInSec
    //

    tDurationInSec::
    tDurationInSec (const ::xml_schema::decimal& _xsd_decimal_base,
                    const unit_type& unit)
    : ::IEC61850::SCL::tValueWithUnit (_xsd_decimal_base,
                                       unit)
    {
    }

    tDurationInSec::
    tDurationInSec (const tDurationInSec& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::IEC61850::SCL::tValueWithUnit (x, f, c)
    {
    }

    tDurationInSec::
    tDurationInSec (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::IEC61850::SCL::tValueWithUnit (e, f, c)
    {
    }

    tDurationInSec* tDurationInSec::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class tDurationInSec (*this, f, c);
    }

    tDurationInSec::
    ~tDurationInSec ()
    {
    }

    // tDurationInMilliSec
    //

    tDurationInMilliSec::
    tDurationInMilliSec (const ::xml_schema::decimal& _xsd_decimal_base,
                         const unit_type& unit)
    : ::IEC61850::SCL::tValueWithUnit (_xsd_decimal_base,
                                       unit)
    {
    }

    tDurationInMilliSec::
    tDurationInMilliSec (const tDurationInMilliSec& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::IEC61850::SCL::tValueWithUnit (x, f, c)
    {
    }

    tDurationInMilliSec::
    tDurationInMilliSec (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::IEC61850::SCL::tValueWithUnit (e, f, c)
    {
    }

    tDurationInMilliSec* tDurationInMilliSec::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class tDurationInMilliSec (*this, f, c);
    }

    tDurationInMilliSec::
    ~tDurationInMilliSec ()
    {
    }

    // History
    //

    History::
    History ()
    : ::xml_schema::type (),
      Hitem_ (::xml_schema::flags (), this)
    {
    }

    History::
    History (const History& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Hitem_ (x.Hitem_, f, this)
    {
    }

    History::
    History (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Hitem_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void History::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Hitem
        //
        if (n.name () == "Hitem" && n.namespace_ () == "http://www.iec.ch/61850/2003/SCL")
        {
          ::std::auto_ptr< Hitem_type > r (
            Hitem_traits::create (i, f, this));

          this->Hitem_.push_back (r);
          continue;
        }

        break;
      }
    }

    History* History::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class History (*this, f, c);
    }

    History::
    ~History ()
    {
    }

    // nameStructure
    //

    nameStructure::
    nameStructure (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xml_schema::name (e, f, c)
    {
      _xsd_nameStructure_convert ();
    }

    nameStructure::
    nameStructure (const ::xercesc::DOMAttr& a,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xml_schema::name (a, f, c)
    {
      _xsd_nameStructure_convert ();
    }

    nameStructure::
    nameStructure (const ::std::string& s,
                   const ::xercesc::DOMElement* e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xml_schema::name (s, e, f, c)
    {
      _xsd_nameStructure_convert ();
    }

    nameStructure* nameStructure::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class nameStructure (*this, f, c);
    }

    nameStructure::value nameStructure::
    _xsd_nameStructure_convert () const
    {
      ::xsd::cxx::tree::enum_comparator< char > c (_xsd_nameStructure_literals_);
      const value* i (::std::lower_bound (
                        _xsd_nameStructure_indexes_,
                        _xsd_nameStructure_indexes_ + 1,
                        *this,
                        c));

      if (i == _xsd_nameStructure_indexes_ + 1 || _xsd_nameStructure_literals_[*i] != *this)
      {
        throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
      }

      return *i;
    }

    const char* const nameStructure::
    _xsd_nameStructure_literals_[1] =
    {
      "IEDName"
    };

    const nameStructure::value nameStructure::
    _xsd_nameStructure_indexes_[1] =
    {
      ::IEC61850::SCL::nameStructure::IEDName
    };
  }
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

namespace IEC61850
{
  namespace SCL
  {
  }
}

#include <ostream>
#include <xsd/cxx/xml/dom/serialization-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

namespace IEC61850
{
  namespace SCL
  {
    void
    operator<< (::xercesc::DOMElement& e, const tBaseElement& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Text
      //
      if (i.Text ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Text",
            "http://www.iec.ch/61850/2003/SCL",
            e));

        s << *i.Text ();
      }

      // Private
      //
      for (tBaseElement::Private_const_iterator
           b (i.Private ().begin ()), n (i.Private ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Private",
            "http://www.iec.ch/61850/2003/SCL",
            e));

        s << *b;
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const tUnNaming& i)
    {
      e << static_cast< const ::IEC61850::SCL::tBaseElement& > (i);

      // desc
      //
      if (i.desc ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "desc",
            e));

        a << *i.desc ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const tNaming& i)
    {
      e << static_cast< const ::IEC61850::SCL::tBaseElement& > (i);

      // name
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "name",
            e));

        a << i.name ();
      }

      // desc
      //
      if (i.desc ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "desc",
            e));

        a << *i.desc ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const tIDNaming& i)
    {
      e << static_cast< const ::IEC61850::SCL::tBaseElement& > (i);

      // id
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "id",
            e));

        a << i.id ();
      }

      // desc
      //
      if (i.desc ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "desc",
            e));

        a << *i.desc ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const tAnyContentFromOtherNamespace& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);
    }

    void
    operator<< (::xercesc::DOMElement& e, const tText& i)
    {
      e << static_cast< const ::IEC61850::SCL::tAnyContentFromOtherNamespace& > (i);

      // source
      //
      if (i.source ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "source",
            e));

        a << *i.source ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const tPrivate& i)
    {
      e << static_cast< const ::IEC61850::SCL::tAnyContentFromOtherNamespace& > (i);

      // type
      //
      if (i.type ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "type",
            e));

        a << *i.type ();
      }

      // source
      //
      if (i.source ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "source",
            e));

        a << *i.source ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const tHeader& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Text
      //
      if (i.Text ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Text",
            "http://www.iec.ch/61850/2003/SCL",
            e));

        s << *i.Text ();
      }

      // History
      //
      if (i.History ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "History",
            "http://www.iec.ch/61850/2003/SCL",
            e));

        s << *i.History ();
      }

      // id
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "id",
            e));

        a << i.id ();
      }

      // version
      //
      if (i.version ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "version",
            e));

        a << *i.version ();
      }

      // revision
      //
      if (i.revision ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "revision",
            e));

        a << *i.revision ();
      }

      // toolID
      //
      if (i.toolID ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "toolID",
            e));

        a << *i.toolID ();
      }

      // nameStructure
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "nameStructure",
            e));

        a << i.nameStructure ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const tHitem& i)
    {
      e << static_cast< const ::IEC61850::SCL::tAnyContentFromOtherNamespace& > (i);

      // version
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "version",
            e));

        a << i.version ();
      }

      // revision
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "revision",
            e));

        a << i.revision ();
      }

      // when
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "when",
            e));

        a << i.when ();
      }

      // who
      //
      if (i.who ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "who",
            e));

        a << *i.who ();
      }

      // what
      //
      if (i.what ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "what",
            e));

        a << *i.what ();
      }

      // why
      //
      if (i.why ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "why",
            e));

        a << *i.why ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const tVal& i)
    {
      e << static_cast< const ::xml_schema::normalized_string& > (i);

      // sGroup
      //
      if (i.sGroup ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "sGroup",
            e));

        a << *i.sGroup ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const tValueWithUnit& i)
    {
      e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal >& > (i);

      // unit
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "unit",
            e));

        a << i.unit ();
      }

      // multiplier
      //
      if (i.multiplier ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "multiplier",
            e));

        a << *i.multiplier ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const tVoltage& i)
    {
      e << static_cast< const ::IEC61850::SCL::tValueWithUnit& > (i);
    }

    void
    operator<< (::xercesc::DOMElement& e, const tBitRateInMbPerSec& i)
    {
      e << static_cast< const ::IEC61850::SCL::tValueWithUnit& > (i);
    }

    void
    operator<< (::xercesc::DOMElement& e, const tDurationInSec& i)
    {
      e << static_cast< const ::IEC61850::SCL::tValueWithUnit& > (i);
    }

    void
    operator<< (::xercesc::DOMElement& e, const tDurationInMilliSec& i)
    {
      e << static_cast< const ::IEC61850::SCL::tValueWithUnit& > (i);
    }

    void
    operator<< (::xercesc::DOMElement& e, const History& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Hitem
      //
      for (History::Hitem_const_iterator
           b (i.Hitem ().begin ()), n (i.Hitem ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Hitem",
            "http://www.iec.ch/61850/2003/SCL",
            e));

        s << *b;
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const nameStructure& i)
    {
      e << static_cast< const ::xml_schema::name& > (i);
    }

    void
    operator<< (::xercesc::DOMAttr& a, const nameStructure& i)
    {
      a << static_cast< const ::xml_schema::name& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const nameStructure& i)
    {
      l << static_cast< const ::xml_schema::name& > (i);
    }
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

