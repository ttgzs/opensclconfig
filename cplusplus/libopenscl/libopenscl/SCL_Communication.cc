// Copyright (C) 2005-2008 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "SCL_Communication.h"

namespace IEC61850
{
  namespace SCL
  {
    // tControlBlock
    // 

    const tControlBlock::Address_optional& tControlBlock::
    Address () const
    {
      return this->Address_;
    }

    tControlBlock::Address_optional& tControlBlock::
    Address ()
    {
      return this->Address_;
    }

    void tControlBlock::
    Address (const Address_type& x)
    {
      this->Address_.set (x);
    }

    void tControlBlock::
    Address (const Address_optional& x)
    {
      this->Address_ = x;
    }

    void tControlBlock::
    Address (::std::auto_ptr< Address_type > x)
    {
      this->Address_.set (x);
    }

    const tControlBlock::ldInst_type& tControlBlock::
    ldInst () const
    {
      return this->ldInst_.get ();
    }

    tControlBlock::ldInst_type& tControlBlock::
    ldInst ()
    {
      return this->ldInst_.get ();
    }

    void tControlBlock::
    ldInst (const ldInst_type& x)
    {
      this->ldInst_.set (x);
    }

    void tControlBlock::
    ldInst (::std::auto_ptr< ldInst_type > x)
    {
      this->ldInst_.set (x);
    }

    const tControlBlock::cbName_type& tControlBlock::
    cbName () const
    {
      return this->cbName_.get ();
    }

    tControlBlock::cbName_type& tControlBlock::
    cbName ()
    {
      return this->cbName_.get ();
    }

    void tControlBlock::
    cbName (const cbName_type& x)
    {
      this->cbName_.set (x);
    }

    void tControlBlock::
    cbName (::std::auto_ptr< cbName_type > x)
    {
      this->cbName_.set (x);
    }


    // tCommunication
    // 

    const tCommunication::SubNetwork_sequence& tCommunication::
    SubNetwork () const
    {
      return this->SubNetwork_;
    }

    tCommunication::SubNetwork_sequence& tCommunication::
    SubNetwork ()
    {
      return this->SubNetwork_;
    }

    void tCommunication::
    SubNetwork (const SubNetwork_sequence& s)
    {
      this->SubNetwork_ = s;
    }


    // tSubNetwork
    // 

    const tSubNetwork::BitRate_optional& tSubNetwork::
    BitRate () const
    {
      return this->BitRate_;
    }

    tSubNetwork::BitRate_optional& tSubNetwork::
    BitRate ()
    {
      return this->BitRate_;
    }

    void tSubNetwork::
    BitRate (const BitRate_type& x)
    {
      this->BitRate_.set (x);
    }

    void tSubNetwork::
    BitRate (const BitRate_optional& x)
    {
      this->BitRate_ = x;
    }

    void tSubNetwork::
    BitRate (::std::auto_ptr< BitRate_type > x)
    {
      this->BitRate_.set (x);
    }

    const tSubNetwork::ConnectedAP_sequence& tSubNetwork::
    ConnectedAP () const
    {
      return this->ConnectedAP_;
    }

    tSubNetwork::ConnectedAP_sequence& tSubNetwork::
    ConnectedAP ()
    {
      return this->ConnectedAP_;
    }

    void tSubNetwork::
    ConnectedAP (const ConnectedAP_sequence& s)
    {
      this->ConnectedAP_ = s;
    }

    const tSubNetwork::type_optional& tSubNetwork::
    type () const
    {
      return this->type_;
    }

    tSubNetwork::type_optional& tSubNetwork::
    type ()
    {
      return this->type_;
    }

    void tSubNetwork::
    type (const type_type& x)
    {
      this->type_.set (x);
    }

    void tSubNetwork::
    type (const type_optional& x)
    {
      this->type_ = x;
    }

    void tSubNetwork::
    type (::std::auto_ptr< type_type > x)
    {
      this->type_.set (x);
    }


    // tConnectedAP
    // 

    const tConnectedAP::Address_optional& tConnectedAP::
    Address () const
    {
      return this->Address_;
    }

    tConnectedAP::Address_optional& tConnectedAP::
    Address ()
    {
      return this->Address_;
    }

    void tConnectedAP::
    Address (const Address_type& x)
    {
      this->Address_.set (x);
    }

    void tConnectedAP::
    Address (const Address_optional& x)
    {
      this->Address_ = x;
    }

    void tConnectedAP::
    Address (::std::auto_ptr< Address_type > x)
    {
      this->Address_.set (x);
    }

    const tConnectedAP::GSE_sequence& tConnectedAP::
    GSE () const
    {
      return this->GSE_;
    }

    tConnectedAP::GSE_sequence& tConnectedAP::
    GSE ()
    {
      return this->GSE_;
    }

    void tConnectedAP::
    GSE (const GSE_sequence& s)
    {
      this->GSE_ = s;
    }

    const tConnectedAP::SMV_sequence& tConnectedAP::
    SMV () const
    {
      return this->SMV_;
    }

    tConnectedAP::SMV_sequence& tConnectedAP::
    SMV ()
    {
      return this->SMV_;
    }

    void tConnectedAP::
    SMV (const SMV_sequence& s)
    {
      this->SMV_ = s;
    }

    const tConnectedAP::PhysConn_sequence& tConnectedAP::
    PhysConn () const
    {
      return this->PhysConn_;
    }

    tConnectedAP::PhysConn_sequence& tConnectedAP::
    PhysConn ()
    {
      return this->PhysConn_;
    }

    void tConnectedAP::
    PhysConn (const PhysConn_sequence& s)
    {
      this->PhysConn_ = s;
    }

    const tConnectedAP::iedName_type& tConnectedAP::
    iedName () const
    {
      return this->iedName_.get ();
    }

    tConnectedAP::iedName_type& tConnectedAP::
    iedName ()
    {
      return this->iedName_.get ();
    }

    void tConnectedAP::
    iedName (const iedName_type& x)
    {
      this->iedName_.set (x);
    }

    void tConnectedAP::
    iedName (::std::auto_ptr< iedName_type > x)
    {
      this->iedName_.set (x);
    }

    const tConnectedAP::apName_type& tConnectedAP::
    apName () const
    {
      return this->apName_.get ();
    }

    tConnectedAP::apName_type& tConnectedAP::
    apName ()
    {
      return this->apName_.get ();
    }

    void tConnectedAP::
    apName (const apName_type& x)
    {
      this->apName_.set (x);
    }

    void tConnectedAP::
    apName (::std::auto_ptr< apName_type > x)
    {
      this->apName_.set (x);
    }


    // tAddress
    // 

    const tAddress::P_sequence& tAddress::
    P () const
    {
      return this->P_;
    }

    tAddress::P_sequence& tAddress::
    P ()
    {
      return this->P_;
    }

    void tAddress::
    P (const P_sequence& s)
    {
      this->P_ = s;
    }


    // tGSE
    // 

    const tGSE::MinTime_optional& tGSE::
    MinTime () const
    {
      return this->MinTime_;
    }

    tGSE::MinTime_optional& tGSE::
    MinTime ()
    {
      return this->MinTime_;
    }

    void tGSE::
    MinTime (const MinTime_type& x)
    {
      this->MinTime_.set (x);
    }

    void tGSE::
    MinTime (const MinTime_optional& x)
    {
      this->MinTime_ = x;
    }

    void tGSE::
    MinTime (::std::auto_ptr< MinTime_type > x)
    {
      this->MinTime_.set (x);
    }

    const tGSE::MaxTime_optional& tGSE::
    MaxTime () const
    {
      return this->MaxTime_;
    }

    tGSE::MaxTime_optional& tGSE::
    MaxTime ()
    {
      return this->MaxTime_;
    }

    void tGSE::
    MaxTime (const MaxTime_type& x)
    {
      this->MaxTime_.set (x);
    }

    void tGSE::
    MaxTime (const MaxTime_optional& x)
    {
      this->MaxTime_ = x;
    }

    void tGSE::
    MaxTime (::std::auto_ptr< MaxTime_type > x)
    {
      this->MaxTime_.set (x);
    }


    // tSMV
    // 


    // tPhysConn
    // 

    const tPhysConn::P_sequence& tPhysConn::
    P () const
    {
      return this->P_;
    }

    tPhysConn::P_sequence& tPhysConn::
    P ()
    {
      return this->P_;
    }

    void tPhysConn::
    P (const P_sequence& s)
    {
      this->P_ = s;
    }

    const tPhysConn::type_type& tPhysConn::
    type () const
    {
      return this->type_.get ();
    }

    tPhysConn::type_type& tPhysConn::
    type ()
    {
      return this->type_.get ();
    }

    void tPhysConn::
    type (const type_type& x)
    {
      this->type_.set (x);
    }

    void tPhysConn::
    type (::std::auto_ptr< type_type > x)
    {
      this->type_.set (x);
    }


    // tP
    // 

    const tP::type_type& tP::
    type () const
    {
      return this->type_.get ();
    }

    tP::type_type& tP::
    type ()
    {
      return this->type_.get ();
    }

    void tP::
    type (const type_type& x)
    {
      this->type_.set (x);
    }

    void tP::
    type (::std::auto_ptr< type_type > x)
    {
      this->type_.set (x);
    }


    // tP_IP
    // 


    // tP_IP_SUBNET
    // 


    // tP_IP_GATEWAY
    // 


    // tP_OSI_NSAP
    // 


    // tP_OSI_TSEL
    // 


    // tP_OSI_SSEL
    // 


    // tP_OSI_PSEL
    // 


    // tP_OSI_AP_Title
    // 


    // tP_OSI_AP_Invoke
    // 


    // tP_OSI_AE_Qualifier
    // 


    // tP_OSI_AE_Invoke
    // 


    // tP_MAC_Address
    // 


    // tP_APPID
    // 


    // tP_VLAN_PRIORITY
    // 


    // tP_VLAN_ID
    // 
  }
}

#include <xsd/cxx/xml/dom/parsing-source.hxx>

namespace IEC61850
{
  namespace SCL
  {
    // tControlBlock
    //

    tControlBlock::
    tControlBlock (const ldInst_type& ldInst,
                   const cbName_type& cbName)
    : ::IEC61850::SCL::tUnNaming (),
      Address_ (::xml_schema::flags (), this),
      ldInst_ (ldInst, ::xml_schema::flags (), this),
      cbName_ (cbName, ::xml_schema::flags (), this)
    {
    }

    tControlBlock::
    tControlBlock (const tControlBlock& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::IEC61850::SCL::tUnNaming (x, f, c),
      Address_ (x.Address_, f, this),
      ldInst_ (x.ldInst_, f, this),
      cbName_ (x.cbName_, f, this)
    {
    }

    tControlBlock::
    tControlBlock (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::IEC61850::SCL::tUnNaming (e, f | ::xml_schema::flags::base, c),
      Address_ (f, this),
      ldInst_ (f, this),
      cbName_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void tControlBlock::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::IEC61850::SCL::tUnNaming::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Address
        //
        if (n.name () == "Address" && n.namespace_ () == "http://www.iec.ch/61850/2003/SCL")
        {
          ::std::auto_ptr< Address_type > r (
            Address_traits::create (i, f, this));

          if (!this->Address_)
          {
            this->Address_.set (r);
            continue;
          }
        }

        break;
      }

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "ldInst" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< ldInst_type > r (
            ldInst_traits::create (i, f, this));

          this->ldInst_.set (r);
          continue;
        }

        if (n.name () == "cbName" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< cbName_type > r (
            cbName_traits::create (i, f, this));

          this->cbName_.set (r);
          continue;
        }
      }

      if (!ldInst_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "ldInst",
          "");
      }

      if (!cbName_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "cbName",
          "");
      }
    }

    tControlBlock* tControlBlock::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class tControlBlock (*this, f, c);
    }

    tControlBlock::
    ~tControlBlock ()
    {
    }

    // tCommunication
    //

    tCommunication::
    tCommunication ()
    : ::IEC61850::SCL::tUnNaming (),
      SubNetwork_ (::xml_schema::flags (), this)
    {
    }

    tCommunication::
    tCommunication (const tCommunication& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::IEC61850::SCL::tUnNaming (x, f, c),
      SubNetwork_ (x.SubNetwork_, f, this)
    {
    }

    tCommunication::
    tCommunication (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::IEC61850::SCL::tUnNaming (e, f | ::xml_schema::flags::base, c),
      SubNetwork_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void tCommunication::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::IEC61850::SCL::tUnNaming::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // SubNetwork
        //
        if (n.name () == "SubNetwork" && n.namespace_ () == "http://www.iec.ch/61850/2003/SCL")
        {
          ::std::auto_ptr< SubNetwork_type > r (
            SubNetwork_traits::create (i, f, this));

          this->SubNetwork_.push_back (r);
          continue;
        }

        break;
      }
    }

    tCommunication* tCommunication::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class tCommunication (*this, f, c);
    }

    tCommunication::
    ~tCommunication ()
    {
    }

    // tSubNetwork
    //

    tSubNetwork::
    tSubNetwork (const name_type& name)
    : ::IEC61850::SCL::tNaming (name),
      BitRate_ (::xml_schema::flags (), this),
      ConnectedAP_ (::xml_schema::flags (), this),
      type_ (::xml_schema::flags (), this)
    {
    }

    tSubNetwork::
    tSubNetwork (const tSubNetwork& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::IEC61850::SCL::tNaming (x, f, c),
      BitRate_ (x.BitRate_, f, this),
      ConnectedAP_ (x.ConnectedAP_, f, this),
      type_ (x.type_, f, this)
    {
    }

    tSubNetwork::
    tSubNetwork (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::IEC61850::SCL::tNaming (e, f | ::xml_schema::flags::base, c),
      BitRate_ (f, this),
      ConnectedAP_ (f, this),
      type_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void tSubNetwork::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::IEC61850::SCL::tNaming::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BitRate
        //
        if (n.name () == "BitRate" && n.namespace_ () == "http://www.iec.ch/61850/2003/SCL")
        {
          ::std::auto_ptr< BitRate_type > r (
            BitRate_traits::create (i, f, this));

          if (!this->BitRate_)
          {
            this->BitRate_.set (r);
            continue;
          }
        }

        // ConnectedAP
        //
        if (n.name () == "ConnectedAP" && n.namespace_ () == "http://www.iec.ch/61850/2003/SCL")
        {
          ::std::auto_ptr< ConnectedAP_type > r (
            ConnectedAP_traits::create (i, f, this));

          this->ConnectedAP_.push_back (r);
          continue;
        }

        break;
      }

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "type" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< type_type > r (
            type_traits::create (i, f, this));

          this->type_.set (r);
          continue;
        }
      }
    }

    tSubNetwork* tSubNetwork::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class tSubNetwork (*this, f, c);
    }

    tSubNetwork::
    ~tSubNetwork ()
    {
    }

    // tConnectedAP
    //

    tConnectedAP::
    tConnectedAP (const iedName_type& iedName,
                  const apName_type& apName)
    : ::IEC61850::SCL::tUnNaming (),
      Address_ (::xml_schema::flags (), this),
      GSE_ (::xml_schema::flags (), this),
      SMV_ (::xml_schema::flags (), this),
      PhysConn_ (::xml_schema::flags (), this),
      iedName_ (iedName, ::xml_schema::flags (), this),
      apName_ (apName, ::xml_schema::flags (), this)
    {
    }

    tConnectedAP::
    tConnectedAP (const tConnectedAP& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::IEC61850::SCL::tUnNaming (x, f, c),
      Address_ (x.Address_, f, this),
      GSE_ (x.GSE_, f, this),
      SMV_ (x.SMV_, f, this),
      PhysConn_ (x.PhysConn_, f, this),
      iedName_ (x.iedName_, f, this),
      apName_ (x.apName_, f, this)
    {
    }

    tConnectedAP::
    tConnectedAP (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::IEC61850::SCL::tUnNaming (e, f | ::xml_schema::flags::base, c),
      Address_ (f, this),
      GSE_ (f, this),
      SMV_ (f, this),
      PhysConn_ (f, this),
      iedName_ (f, this),
      apName_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void tConnectedAP::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::IEC61850::SCL::tUnNaming::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Address
        //
        if (n.name () == "Address" && n.namespace_ () == "http://www.iec.ch/61850/2003/SCL")
        {
          ::std::auto_ptr< Address_type > r (
            Address_traits::create (i, f, this));

          if (!this->Address_)
          {
            this->Address_.set (r);
            continue;
          }
        }

        // GSE
        //
        if (n.name () == "GSE" && n.namespace_ () == "http://www.iec.ch/61850/2003/SCL")
        {
          ::std::auto_ptr< GSE_type > r (
            GSE_traits::create (i, f, this));

          this->GSE_.push_back (r);
          continue;
        }

        // SMV
        //
        if (n.name () == "SMV" && n.namespace_ () == "http://www.iec.ch/61850/2003/SCL")
        {
          ::std::auto_ptr< SMV_type > r (
            SMV_traits::create (i, f, this));

          this->SMV_.push_back (r);
          continue;
        }

        // PhysConn
        //
        if (n.name () == "PhysConn" && n.namespace_ () == "http://www.iec.ch/61850/2003/SCL")
        {
          ::std::auto_ptr< PhysConn_type > r (
            PhysConn_traits::create (i, f, this));

          this->PhysConn_.push_back (r);
          continue;
        }

        break;
      }

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "iedName" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< iedName_type > r (
            iedName_traits::create (i, f, this));

          this->iedName_.set (r);
          continue;
        }

        if (n.name () == "apName" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< apName_type > r (
            apName_traits::create (i, f, this));

          this->apName_.set (r);
          continue;
        }
      }

      if (!iedName_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "iedName",
          "");
      }

      if (!apName_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "apName",
          "");
      }
    }

    tConnectedAP* tConnectedAP::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class tConnectedAP (*this, f, c);
    }

    tConnectedAP::
    ~tConnectedAP ()
    {
    }

    // tAddress
    //

    tAddress::
    tAddress ()
    : ::xml_schema::type (),
      P_ (::xml_schema::flags (), this)
    {
    }

    tAddress::
    tAddress (const tAddress& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      P_ (x.P_, f, this)
    {
    }

    tAddress::
    tAddress (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      P_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void tAddress::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // P
        //
        if (n.name () == "P" && n.namespace_ () == "http://www.iec.ch/61850/2003/SCL")
        {
          ::std::auto_ptr< P_type > r (
            P_traits::create (i, f, this));

          this->P_.push_back (r);
          continue;
        }

        break;
      }
    }

    tAddress* tAddress::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class tAddress (*this, f, c);
    }

    tAddress::
    ~tAddress ()
    {
    }

    // tGSE
    //

    tGSE::
    tGSE (const ldInst_type& ldInst,
          const cbName_type& cbName)
    : ::IEC61850::SCL::tControlBlock (ldInst,
                                      cbName),
      MinTime_ (::xml_schema::flags (), this),
      MaxTime_ (::xml_schema::flags (), this)
    {
    }

    tGSE::
    tGSE (const tGSE& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
    : ::IEC61850::SCL::tControlBlock (x, f, c),
      MinTime_ (x.MinTime_, f, this),
      MaxTime_ (x.MaxTime_, f, this)
    {
    }

    tGSE::
    tGSE (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
    : ::IEC61850::SCL::tControlBlock (e, f | ::xml_schema::flags::base, c),
      MinTime_ (f, this),
      MaxTime_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void tGSE::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::IEC61850::SCL::tControlBlock::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // MinTime
        //
        if (n.name () == "MinTime" && n.namespace_ () == "http://www.iec.ch/61850/2003/SCL")
        {
          ::std::auto_ptr< MinTime_type > r (
            MinTime_traits::create (i, f, this));

          if (!this->MinTime_)
          {
            this->MinTime_.set (r);
            continue;
          }
        }

        // MaxTime
        //
        if (n.name () == "MaxTime" && n.namespace_ () == "http://www.iec.ch/61850/2003/SCL")
        {
          ::std::auto_ptr< MaxTime_type > r (
            MaxTime_traits::create (i, f, this));

          if (!this->MaxTime_)
          {
            this->MaxTime_.set (r);
            continue;
          }
        }

        break;
      }
    }

    tGSE* tGSE::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class tGSE (*this, f, c);
    }

    tGSE::
    ~tGSE ()
    {
    }

    // tSMV
    //

    tSMV::
    tSMV (const ldInst_type& ldInst,
          const cbName_type& cbName)
    : ::IEC61850::SCL::tControlBlock (ldInst,
                                      cbName)
    {
    }

    tSMV::
    tSMV (const tSMV& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
    : ::IEC61850::SCL::tControlBlock (x, f, c)
    {
    }

    tSMV::
    tSMV (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
    : ::IEC61850::SCL::tControlBlock (e, f, c)
    {
    }

    tSMV* tSMV::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class tSMV (*this, f, c);
    }

    tSMV::
    ~tSMV ()
    {
    }

    // tPhysConn
    //

    tPhysConn::
    tPhysConn (const type_type& type)
    : ::xml_schema::type (),
      P_ (::xml_schema::flags (), this),
      type_ (type, ::xml_schema::flags (), this)
    {
    }

    tPhysConn::
    tPhysConn (const tPhysConn& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      P_ (x.P_, f, this),
      type_ (x.type_, f, this)
    {
    }

    tPhysConn::
    tPhysConn (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      P_ (f, this),
      type_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void tPhysConn::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // P
        //
        if (n.name () == "P" && n.namespace_ () == "http://www.iec.ch/61850/2003/SCL")
        {
          ::std::auto_ptr< P_type > r (
            P_traits::create (i, f, this));

          this->P_.push_back (r);
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "type" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< type_type > r (
            type_traits::create (i, f, this));

          this->type_.set (r);
          continue;
        }
      }

      if (!type_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "type",
          "");
      }
    }

    tPhysConn* tPhysConn::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class tPhysConn (*this, f, c);
    }

    tPhysConn::
    ~tPhysConn ()
    {
    }

    // tP
    //

    tP::
    tP (const type_type& type)
    : ::IEC61850::SCL::tPAddr (),
      type_ (type, ::xml_schema::flags (), this)
    {
    }

    tP::
    tP (const char* _xsd_normalized_string_base,
        const type_type& type)
    : ::IEC61850::SCL::tPAddr (_xsd_normalized_string_base),
      type_ (type, ::xml_schema::flags (), this)
    {
    }

    tP::
    tP (const ::std::string& _xsd_normalized_string_base,
        const type_type& type)
    : ::IEC61850::SCL::tPAddr (_xsd_normalized_string_base),
      type_ (type, ::xml_schema::flags (), this)
    {
    }

    tP::
    tP (const ::xml_schema::normalized_string& _xsd_normalized_string_base,
        const type_type& type)
    : ::IEC61850::SCL::tPAddr (_xsd_normalized_string_base),
      type_ (type, ::xml_schema::flags (), this)
    {
    }

    tP::
    tP (const tP& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
    : ::IEC61850::SCL::tPAddr (x, f, c),
      type_ (x.type_, f, this)
    {
    }

    tP::
    tP (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
    : ::IEC61850::SCL::tPAddr (e, f | ::xml_schema::flags::base, c),
      type_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
        this->parse (p, f);
      }
    }

    void tP::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "type" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< type_type > r (
            type_traits::create (i, f, this));

          this->type_.set (r);
          continue;
        }
      }

      if (!type_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "type",
          "");
      }
    }

    tP* tP::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class tP (*this, f, c);
    }

    tP::
    ~tP ()
    {
    }

    // tP_IP
    //

    tP_IP::
    tP_IP (const type_type& type)
    : ::IEC61850::SCL::tP (type)
    {
    }

    tP_IP::
    tP_IP (const char* _xsd_normalized_string_base,
           const type_type& type)
    : ::IEC61850::SCL::tP (_xsd_normalized_string_base,
                           type)
    {
    }

    tP_IP::
    tP_IP (const ::std::string& _xsd_normalized_string_base,
           const type_type& type)
    : ::IEC61850::SCL::tP (_xsd_normalized_string_base,
                           type)
    {
    }

    tP_IP::
    tP_IP (const ::xml_schema::normalized_string& _xsd_normalized_string_base,
           const type_type& type)
    : ::IEC61850::SCL::tP (_xsd_normalized_string_base,
                           type)
    {
    }

    tP_IP::
    tP_IP (const tP_IP& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
    : ::IEC61850::SCL::tP (x, f, c)
    {
    }

    tP_IP::
    tP_IP (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
    : ::IEC61850::SCL::tP (e, f, c)
    {
    }

    tP_IP* tP_IP::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class tP_IP (*this, f, c);
    }

    tP_IP::
    ~tP_IP ()
    {
    }

    // tP_IP_SUBNET
    //

    tP_IP_SUBNET::
    tP_IP_SUBNET (const type_type& type)
    : ::IEC61850::SCL::tP (type)
    {
    }

    tP_IP_SUBNET::
    tP_IP_SUBNET (const char* _xsd_normalized_string_base,
                  const type_type& type)
    : ::IEC61850::SCL::tP (_xsd_normalized_string_base,
                           type)
    {
    }

    tP_IP_SUBNET::
    tP_IP_SUBNET (const ::std::string& _xsd_normalized_string_base,
                  const type_type& type)
    : ::IEC61850::SCL::tP (_xsd_normalized_string_base,
                           type)
    {
    }

    tP_IP_SUBNET::
    tP_IP_SUBNET (const ::xml_schema::normalized_string& _xsd_normalized_string_base,
                  const type_type& type)
    : ::IEC61850::SCL::tP (_xsd_normalized_string_base,
                           type)
    {
    }

    tP_IP_SUBNET::
    tP_IP_SUBNET (const tP_IP_SUBNET& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::IEC61850::SCL::tP (x, f, c)
    {
    }

    tP_IP_SUBNET::
    tP_IP_SUBNET (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::IEC61850::SCL::tP (e, f, c)
    {
    }

    tP_IP_SUBNET* tP_IP_SUBNET::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class tP_IP_SUBNET (*this, f, c);
    }

    tP_IP_SUBNET::
    ~tP_IP_SUBNET ()
    {
    }

    // tP_IP_GATEWAY
    //

    tP_IP_GATEWAY::
    tP_IP_GATEWAY (const type_type& type)
    : ::IEC61850::SCL::tP (type)
    {
    }

    tP_IP_GATEWAY::
    tP_IP_GATEWAY (const char* _xsd_normalized_string_base,
                   const type_type& type)
    : ::IEC61850::SCL::tP (_xsd_normalized_string_base,
                           type)
    {
    }

    tP_IP_GATEWAY::
    tP_IP_GATEWAY (const ::std::string& _xsd_normalized_string_base,
                   const type_type& type)
    : ::IEC61850::SCL::tP (_xsd_normalized_string_base,
                           type)
    {
    }

    tP_IP_GATEWAY::
    tP_IP_GATEWAY (const ::xml_schema::normalized_string& _xsd_normalized_string_base,
                   const type_type& type)
    : ::IEC61850::SCL::tP (_xsd_normalized_string_base,
                           type)
    {
    }

    tP_IP_GATEWAY::
    tP_IP_GATEWAY (const tP_IP_GATEWAY& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::IEC61850::SCL::tP (x, f, c)
    {
    }

    tP_IP_GATEWAY::
    tP_IP_GATEWAY (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::IEC61850::SCL::tP (e, f, c)
    {
    }

    tP_IP_GATEWAY* tP_IP_GATEWAY::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class tP_IP_GATEWAY (*this, f, c);
    }

    tP_IP_GATEWAY::
    ~tP_IP_GATEWAY ()
    {
    }

    // tP_OSI_NSAP
    //

    tP_OSI_NSAP::
    tP_OSI_NSAP (const type_type& type)
    : ::IEC61850::SCL::tP (type)
    {
    }

    tP_OSI_NSAP::
    tP_OSI_NSAP (const char* _xsd_normalized_string_base,
                 const type_type& type)
    : ::IEC61850::SCL::tP (_xsd_normalized_string_base,
                           type)
    {
    }

    tP_OSI_NSAP::
    tP_OSI_NSAP (const ::std::string& _xsd_normalized_string_base,
                 const type_type& type)
    : ::IEC61850::SCL::tP (_xsd_normalized_string_base,
                           type)
    {
    }

    tP_OSI_NSAP::
    tP_OSI_NSAP (const ::xml_schema::normalized_string& _xsd_normalized_string_base,
                 const type_type& type)
    : ::IEC61850::SCL::tP (_xsd_normalized_string_base,
                           type)
    {
    }

    tP_OSI_NSAP::
    tP_OSI_NSAP (const tP_OSI_NSAP& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::IEC61850::SCL::tP (x, f, c)
    {
    }

    tP_OSI_NSAP::
    tP_OSI_NSAP (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::IEC61850::SCL::tP (e, f, c)
    {
    }

    tP_OSI_NSAP* tP_OSI_NSAP::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class tP_OSI_NSAP (*this, f, c);
    }

    tP_OSI_NSAP::
    ~tP_OSI_NSAP ()
    {
    }

    // tP_OSI_TSEL
    //

    tP_OSI_TSEL::
    tP_OSI_TSEL (const type_type& type)
    : ::IEC61850::SCL::tP (type)
    {
    }

    tP_OSI_TSEL::
    tP_OSI_TSEL (const char* _xsd_normalized_string_base,
                 const type_type& type)
    : ::IEC61850::SCL::tP (_xsd_normalized_string_base,
                           type)
    {
    }

    tP_OSI_TSEL::
    tP_OSI_TSEL (const ::std::string& _xsd_normalized_string_base,
                 const type_type& type)
    : ::IEC61850::SCL::tP (_xsd_normalized_string_base,
                           type)
    {
    }

    tP_OSI_TSEL::
    tP_OSI_TSEL (const ::xml_schema::normalized_string& _xsd_normalized_string_base,
                 const type_type& type)
    : ::IEC61850::SCL::tP (_xsd_normalized_string_base,
                           type)
    {
    }

    tP_OSI_TSEL::
    tP_OSI_TSEL (const tP_OSI_TSEL& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::IEC61850::SCL::tP (x, f, c)
    {
    }

    tP_OSI_TSEL::
    tP_OSI_TSEL (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::IEC61850::SCL::tP (e, f, c)
    {
    }

    tP_OSI_TSEL* tP_OSI_TSEL::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class tP_OSI_TSEL (*this, f, c);
    }

    tP_OSI_TSEL::
    ~tP_OSI_TSEL ()
    {
    }

    // tP_OSI_SSEL
    //

    tP_OSI_SSEL::
    tP_OSI_SSEL (const type_type& type)
    : ::IEC61850::SCL::tP (type)
    {
    }

    tP_OSI_SSEL::
    tP_OSI_SSEL (const char* _xsd_normalized_string_base,
                 const type_type& type)
    : ::IEC61850::SCL::tP (_xsd_normalized_string_base,
                           type)
    {
    }

    tP_OSI_SSEL::
    tP_OSI_SSEL (const ::std::string& _xsd_normalized_string_base,
                 const type_type& type)
    : ::IEC61850::SCL::tP (_xsd_normalized_string_base,
                           type)
    {
    }

    tP_OSI_SSEL::
    tP_OSI_SSEL (const ::xml_schema::normalized_string& _xsd_normalized_string_base,
                 const type_type& type)
    : ::IEC61850::SCL::tP (_xsd_normalized_string_base,
                           type)
    {
    }

    tP_OSI_SSEL::
    tP_OSI_SSEL (const tP_OSI_SSEL& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::IEC61850::SCL::tP (x, f, c)
    {
    }

    tP_OSI_SSEL::
    tP_OSI_SSEL (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::IEC61850::SCL::tP (e, f, c)
    {
    }

    tP_OSI_SSEL* tP_OSI_SSEL::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class tP_OSI_SSEL (*this, f, c);
    }

    tP_OSI_SSEL::
    ~tP_OSI_SSEL ()
    {
    }

    // tP_OSI_PSEL
    //

    tP_OSI_PSEL::
    tP_OSI_PSEL (const type_type& type)
    : ::IEC61850::SCL::tP (type)
    {
    }

    tP_OSI_PSEL::
    tP_OSI_PSEL (const char* _xsd_normalized_string_base,
                 const type_type& type)
    : ::IEC61850::SCL::tP (_xsd_normalized_string_base,
                           type)
    {
    }

    tP_OSI_PSEL::
    tP_OSI_PSEL (const ::std::string& _xsd_normalized_string_base,
                 const type_type& type)
    : ::IEC61850::SCL::tP (_xsd_normalized_string_base,
                           type)
    {
    }

    tP_OSI_PSEL::
    tP_OSI_PSEL (const ::xml_schema::normalized_string& _xsd_normalized_string_base,
                 const type_type& type)
    : ::IEC61850::SCL::tP (_xsd_normalized_string_base,
                           type)
    {
    }

    tP_OSI_PSEL::
    tP_OSI_PSEL (const tP_OSI_PSEL& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::IEC61850::SCL::tP (x, f, c)
    {
    }

    tP_OSI_PSEL::
    tP_OSI_PSEL (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::IEC61850::SCL::tP (e, f, c)
    {
    }

    tP_OSI_PSEL* tP_OSI_PSEL::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class tP_OSI_PSEL (*this, f, c);
    }

    tP_OSI_PSEL::
    ~tP_OSI_PSEL ()
    {
    }

    // tP_OSI_AP_Title
    //

    tP_OSI_AP_Title::
    tP_OSI_AP_Title (const type_type& type)
    : ::IEC61850::SCL::tP (type)
    {
    }

    tP_OSI_AP_Title::
    tP_OSI_AP_Title (const char* _xsd_normalized_string_base,
                     const type_type& type)
    : ::IEC61850::SCL::tP (_xsd_normalized_string_base,
                           type)
    {
    }

    tP_OSI_AP_Title::
    tP_OSI_AP_Title (const ::std::string& _xsd_normalized_string_base,
                     const type_type& type)
    : ::IEC61850::SCL::tP (_xsd_normalized_string_base,
                           type)
    {
    }

    tP_OSI_AP_Title::
    tP_OSI_AP_Title (const ::xml_schema::normalized_string& _xsd_normalized_string_base,
                     const type_type& type)
    : ::IEC61850::SCL::tP (_xsd_normalized_string_base,
                           type)
    {
    }

    tP_OSI_AP_Title::
    tP_OSI_AP_Title (const tP_OSI_AP_Title& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::IEC61850::SCL::tP (x, f, c)
    {
    }

    tP_OSI_AP_Title::
    tP_OSI_AP_Title (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::IEC61850::SCL::tP (e, f, c)
    {
    }

    tP_OSI_AP_Title* tP_OSI_AP_Title::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class tP_OSI_AP_Title (*this, f, c);
    }

    tP_OSI_AP_Title::
    ~tP_OSI_AP_Title ()
    {
    }

    // tP_OSI_AP_Invoke
    //

    tP_OSI_AP_Invoke::
    tP_OSI_AP_Invoke (const type_type& type)
    : ::IEC61850::SCL::tP (type)
    {
    }

    tP_OSI_AP_Invoke::
    tP_OSI_AP_Invoke (const char* _xsd_normalized_string_base,
                      const type_type& type)
    : ::IEC61850::SCL::tP (_xsd_normalized_string_base,
                           type)
    {
    }

    tP_OSI_AP_Invoke::
    tP_OSI_AP_Invoke (const ::std::string& _xsd_normalized_string_base,
                      const type_type& type)
    : ::IEC61850::SCL::tP (_xsd_normalized_string_base,
                           type)
    {
    }

    tP_OSI_AP_Invoke::
    tP_OSI_AP_Invoke (const ::xml_schema::normalized_string& _xsd_normalized_string_base,
                      const type_type& type)
    : ::IEC61850::SCL::tP (_xsd_normalized_string_base,
                           type)
    {
    }

    tP_OSI_AP_Invoke::
    tP_OSI_AP_Invoke (const tP_OSI_AP_Invoke& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::IEC61850::SCL::tP (x, f, c)
    {
    }

    tP_OSI_AP_Invoke::
    tP_OSI_AP_Invoke (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::IEC61850::SCL::tP (e, f, c)
    {
    }

    tP_OSI_AP_Invoke* tP_OSI_AP_Invoke::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class tP_OSI_AP_Invoke (*this, f, c);
    }

    tP_OSI_AP_Invoke::
    ~tP_OSI_AP_Invoke ()
    {
    }

    // tP_OSI_AE_Qualifier
    //

    tP_OSI_AE_Qualifier::
    tP_OSI_AE_Qualifier (const type_type& type)
    : ::IEC61850::SCL::tP (type)
    {
    }

    tP_OSI_AE_Qualifier::
    tP_OSI_AE_Qualifier (const char* _xsd_normalized_string_base,
                         const type_type& type)
    : ::IEC61850::SCL::tP (_xsd_normalized_string_base,
                           type)
    {
    }

    tP_OSI_AE_Qualifier::
    tP_OSI_AE_Qualifier (const ::std::string& _xsd_normalized_string_base,
                         const type_type& type)
    : ::IEC61850::SCL::tP (_xsd_normalized_string_base,
                           type)
    {
    }

    tP_OSI_AE_Qualifier::
    tP_OSI_AE_Qualifier (const ::xml_schema::normalized_string& _xsd_normalized_string_base,
                         const type_type& type)
    : ::IEC61850::SCL::tP (_xsd_normalized_string_base,
                           type)
    {
    }

    tP_OSI_AE_Qualifier::
    tP_OSI_AE_Qualifier (const tP_OSI_AE_Qualifier& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::IEC61850::SCL::tP (x, f, c)
    {
    }

    tP_OSI_AE_Qualifier::
    tP_OSI_AE_Qualifier (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::IEC61850::SCL::tP (e, f, c)
    {
    }

    tP_OSI_AE_Qualifier* tP_OSI_AE_Qualifier::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class tP_OSI_AE_Qualifier (*this, f, c);
    }

    tP_OSI_AE_Qualifier::
    ~tP_OSI_AE_Qualifier ()
    {
    }

    // tP_OSI_AE_Invoke
    //

    tP_OSI_AE_Invoke::
    tP_OSI_AE_Invoke (const type_type& type)
    : ::IEC61850::SCL::tP (type)
    {
    }

    tP_OSI_AE_Invoke::
    tP_OSI_AE_Invoke (const char* _xsd_normalized_string_base,
                      const type_type& type)
    : ::IEC61850::SCL::tP (_xsd_normalized_string_base,
                           type)
    {
    }

    tP_OSI_AE_Invoke::
    tP_OSI_AE_Invoke (const ::std::string& _xsd_normalized_string_base,
                      const type_type& type)
    : ::IEC61850::SCL::tP (_xsd_normalized_string_base,
                           type)
    {
    }

    tP_OSI_AE_Invoke::
    tP_OSI_AE_Invoke (const ::xml_schema::normalized_string& _xsd_normalized_string_base,
                      const type_type& type)
    : ::IEC61850::SCL::tP (_xsd_normalized_string_base,
                           type)
    {
    }

    tP_OSI_AE_Invoke::
    tP_OSI_AE_Invoke (const tP_OSI_AE_Invoke& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::IEC61850::SCL::tP (x, f, c)
    {
    }

    tP_OSI_AE_Invoke::
    tP_OSI_AE_Invoke (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::IEC61850::SCL::tP (e, f, c)
    {
    }

    tP_OSI_AE_Invoke* tP_OSI_AE_Invoke::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class tP_OSI_AE_Invoke (*this, f, c);
    }

    tP_OSI_AE_Invoke::
    ~tP_OSI_AE_Invoke ()
    {
    }

    // tP_MAC_Address
    //

    tP_MAC_Address::
    tP_MAC_Address (const type_type& type)
    : ::IEC61850::SCL::tP (type)
    {
    }

    tP_MAC_Address::
    tP_MAC_Address (const char* _xsd_normalized_string_base,
                    const type_type& type)
    : ::IEC61850::SCL::tP (_xsd_normalized_string_base,
                           type)
    {
    }

    tP_MAC_Address::
    tP_MAC_Address (const ::std::string& _xsd_normalized_string_base,
                    const type_type& type)
    : ::IEC61850::SCL::tP (_xsd_normalized_string_base,
                           type)
    {
    }

    tP_MAC_Address::
    tP_MAC_Address (const ::xml_schema::normalized_string& _xsd_normalized_string_base,
                    const type_type& type)
    : ::IEC61850::SCL::tP (_xsd_normalized_string_base,
                           type)
    {
    }

    tP_MAC_Address::
    tP_MAC_Address (const tP_MAC_Address& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::IEC61850::SCL::tP (x, f, c)
    {
    }

    tP_MAC_Address::
    tP_MAC_Address (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::IEC61850::SCL::tP (e, f, c)
    {
    }

    tP_MAC_Address* tP_MAC_Address::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class tP_MAC_Address (*this, f, c);
    }

    tP_MAC_Address::
    ~tP_MAC_Address ()
    {
    }

    // tP_APPID
    //

    tP_APPID::
    tP_APPID (const type_type& type)
    : ::IEC61850::SCL::tP (type)
    {
    }

    tP_APPID::
    tP_APPID (const char* _xsd_normalized_string_base,
              const type_type& type)
    : ::IEC61850::SCL::tP (_xsd_normalized_string_base,
                           type)
    {
    }

    tP_APPID::
    tP_APPID (const ::std::string& _xsd_normalized_string_base,
              const type_type& type)
    : ::IEC61850::SCL::tP (_xsd_normalized_string_base,
                           type)
    {
    }

    tP_APPID::
    tP_APPID (const ::xml_schema::normalized_string& _xsd_normalized_string_base,
              const type_type& type)
    : ::IEC61850::SCL::tP (_xsd_normalized_string_base,
                           type)
    {
    }

    tP_APPID::
    tP_APPID (const tP_APPID& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
    : ::IEC61850::SCL::tP (x, f, c)
    {
    }

    tP_APPID::
    tP_APPID (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
    : ::IEC61850::SCL::tP (e, f, c)
    {
    }

    tP_APPID* tP_APPID::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class tP_APPID (*this, f, c);
    }

    tP_APPID::
    ~tP_APPID ()
    {
    }

    // tP_VLAN_PRIORITY
    //

    tP_VLAN_PRIORITY::
    tP_VLAN_PRIORITY (const type_type& type)
    : ::IEC61850::SCL::tP (type)
    {
    }

    tP_VLAN_PRIORITY::
    tP_VLAN_PRIORITY (const char* _xsd_normalized_string_base,
                      const type_type& type)
    : ::IEC61850::SCL::tP (_xsd_normalized_string_base,
                           type)
    {
    }

    tP_VLAN_PRIORITY::
    tP_VLAN_PRIORITY (const ::std::string& _xsd_normalized_string_base,
                      const type_type& type)
    : ::IEC61850::SCL::tP (_xsd_normalized_string_base,
                           type)
    {
    }

    tP_VLAN_PRIORITY::
    tP_VLAN_PRIORITY (const ::xml_schema::normalized_string& _xsd_normalized_string_base,
                      const type_type& type)
    : ::IEC61850::SCL::tP (_xsd_normalized_string_base,
                           type)
    {
    }

    tP_VLAN_PRIORITY::
    tP_VLAN_PRIORITY (const tP_VLAN_PRIORITY& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::IEC61850::SCL::tP (x, f, c)
    {
    }

    tP_VLAN_PRIORITY::
    tP_VLAN_PRIORITY (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::IEC61850::SCL::tP (e, f, c)
    {
    }

    tP_VLAN_PRIORITY* tP_VLAN_PRIORITY::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class tP_VLAN_PRIORITY (*this, f, c);
    }

    tP_VLAN_PRIORITY::
    ~tP_VLAN_PRIORITY ()
    {
    }

    // tP_VLAN_ID
    //

    tP_VLAN_ID::
    tP_VLAN_ID (const type_type& type)
    : ::IEC61850::SCL::tP (type)
    {
    }

    tP_VLAN_ID::
    tP_VLAN_ID (const char* _xsd_normalized_string_base,
                const type_type& type)
    : ::IEC61850::SCL::tP (_xsd_normalized_string_base,
                           type)
    {
    }

    tP_VLAN_ID::
    tP_VLAN_ID (const ::std::string& _xsd_normalized_string_base,
                const type_type& type)
    : ::IEC61850::SCL::tP (_xsd_normalized_string_base,
                           type)
    {
    }

    tP_VLAN_ID::
    tP_VLAN_ID (const ::xml_schema::normalized_string& _xsd_normalized_string_base,
                const type_type& type)
    : ::IEC61850::SCL::tP (_xsd_normalized_string_base,
                           type)
    {
    }

    tP_VLAN_ID::
    tP_VLAN_ID (const tP_VLAN_ID& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
    : ::IEC61850::SCL::tP (x, f, c)
    {
    }

    tP_VLAN_ID::
    tP_VLAN_ID (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
    : ::IEC61850::SCL::tP (e, f, c)
    {
    }

    tP_VLAN_ID* tP_VLAN_ID::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class tP_VLAN_ID (*this, f, c);
    }

    tP_VLAN_ID::
    ~tP_VLAN_ID ()
    {
    }
  }
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

namespace IEC61850
{
  namespace SCL
  {
  }
}

#include <ostream>
#include <xsd/cxx/xml/dom/serialization-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

namespace IEC61850
{
  namespace SCL
  {
    void
    operator<< (::xercesc::DOMElement& e, const tControlBlock& i)
    {
      e << static_cast< const ::IEC61850::SCL::tUnNaming& > (i);

      // Address
      //
      if (i.Address ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Address",
            "http://www.iec.ch/61850/2003/SCL",
            e));

        s << *i.Address ();
      }

      // ldInst
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "ldInst",
            e));

        a << i.ldInst ();
      }

      // cbName
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "cbName",
            e));

        a << i.cbName ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const tCommunication& i)
    {
      e << static_cast< const ::IEC61850::SCL::tUnNaming& > (i);

      // SubNetwork
      //
      for (tCommunication::SubNetwork_const_iterator
           b (i.SubNetwork ().begin ()), n (i.SubNetwork ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "SubNetwork",
            "http://www.iec.ch/61850/2003/SCL",
            e));

        s << *b;
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const tSubNetwork& i)
    {
      e << static_cast< const ::IEC61850::SCL::tNaming& > (i);

      // BitRate
      //
      if (i.BitRate ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "BitRate",
            "http://www.iec.ch/61850/2003/SCL",
            e));

        s << *i.BitRate ();
      }

      // ConnectedAP
      //
      for (tSubNetwork::ConnectedAP_const_iterator
           b (i.ConnectedAP ().begin ()), n (i.ConnectedAP ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "ConnectedAP",
            "http://www.iec.ch/61850/2003/SCL",
            e));

        s << *b;
      }

      // type
      //
      if (i.type ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "type",
            e));

        a << *i.type ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const tConnectedAP& i)
    {
      e << static_cast< const ::IEC61850::SCL::tUnNaming& > (i);

      // Address
      //
      if (i.Address ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Address",
            "http://www.iec.ch/61850/2003/SCL",
            e));

        s << *i.Address ();
      }

      // GSE
      //
      for (tConnectedAP::GSE_const_iterator
           b (i.GSE ().begin ()), n (i.GSE ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "GSE",
            "http://www.iec.ch/61850/2003/SCL",
            e));

        s << *b;
      }

      // SMV
      //
      for (tConnectedAP::SMV_const_iterator
           b (i.SMV ().begin ()), n (i.SMV ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "SMV",
            "http://www.iec.ch/61850/2003/SCL",
            e));

        s << *b;
      }

      // PhysConn
      //
      for (tConnectedAP::PhysConn_const_iterator
           b (i.PhysConn ().begin ()), n (i.PhysConn ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "PhysConn",
            "http://www.iec.ch/61850/2003/SCL",
            e));

        s << *b;
      }

      // iedName
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "iedName",
            e));

        a << i.iedName ();
      }

      // apName
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "apName",
            e));

        a << i.apName ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const tAddress& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // P
      //
      for (tAddress::P_const_iterator
           b (i.P ().begin ()), n (i.P ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "P",
            "http://www.iec.ch/61850/2003/SCL",
            e));

        s << *b;
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const tGSE& i)
    {
      e << static_cast< const ::IEC61850::SCL::tControlBlock& > (i);

      // MinTime
      //
      if (i.MinTime ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "MinTime",
            "http://www.iec.ch/61850/2003/SCL",
            e));

        s << *i.MinTime ();
      }

      // MaxTime
      //
      if (i.MaxTime ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "MaxTime",
            "http://www.iec.ch/61850/2003/SCL",
            e));

        s << *i.MaxTime ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const tSMV& i)
    {
      e << static_cast< const ::IEC61850::SCL::tControlBlock& > (i);
    }

    void
    operator<< (::xercesc::DOMElement& e, const tPhysConn& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // P
      //
      for (tPhysConn::P_const_iterator
           b (i.P ().begin ()), n (i.P ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "P",
            "http://www.iec.ch/61850/2003/SCL",
            e));

        s << *b;
      }

      // type
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "type",
            e));

        a << i.type ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const tP& i)
    {
      e << static_cast< const ::IEC61850::SCL::tPAddr& > (i);

      // type
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "type",
            e));

        a << i.type ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const tP_IP& i)
    {
      e << static_cast< const ::IEC61850::SCL::tP& > (i);
    }

    void
    operator<< (::xercesc::DOMElement& e, const tP_IP_SUBNET& i)
    {
      e << static_cast< const ::IEC61850::SCL::tP& > (i);
    }

    void
    operator<< (::xercesc::DOMElement& e, const tP_IP_GATEWAY& i)
    {
      e << static_cast< const ::IEC61850::SCL::tP& > (i);
    }

    void
    operator<< (::xercesc::DOMElement& e, const tP_OSI_NSAP& i)
    {
      e << static_cast< const ::IEC61850::SCL::tP& > (i);
    }

    void
    operator<< (::xercesc::DOMElement& e, const tP_OSI_TSEL& i)
    {
      e << static_cast< const ::IEC61850::SCL::tP& > (i);
    }

    void
    operator<< (::xercesc::DOMElement& e, const tP_OSI_SSEL& i)
    {
      e << static_cast< const ::IEC61850::SCL::tP& > (i);
    }

    void
    operator<< (::xercesc::DOMElement& e, const tP_OSI_PSEL& i)
    {
      e << static_cast< const ::IEC61850::SCL::tP& > (i);
    }

    void
    operator<< (::xercesc::DOMElement& e, const tP_OSI_AP_Title& i)
    {
      e << static_cast< const ::IEC61850::SCL::tP& > (i);
    }

    void
    operator<< (::xercesc::DOMElement& e, const tP_OSI_AP_Invoke& i)
    {
      e << static_cast< const ::IEC61850::SCL::tP& > (i);
    }

    void
    operator<< (::xercesc::DOMElement& e, const tP_OSI_AE_Qualifier& i)
    {
      e << static_cast< const ::IEC61850::SCL::tP& > (i);
    }

    void
    operator<< (::xercesc::DOMElement& e, const tP_OSI_AE_Invoke& i)
    {
      e << static_cast< const ::IEC61850::SCL::tP& > (i);
    }

    void
    operator<< (::xercesc::DOMElement& e, const tP_MAC_Address& i)
    {
      e << static_cast< const ::IEC61850::SCL::tP& > (i);
    }

    void
    operator<< (::xercesc::DOMElement& e, const tP_APPID& i)
    {
      e << static_cast< const ::IEC61850::SCL::tP& > (i);
    }

    void
    operator<< (::xercesc::DOMElement& e, const tP_VLAN_PRIORITY& i)
    {
      e << static_cast< const ::IEC61850::SCL::tP& > (i);
    }

    void
    operator<< (::xercesc::DOMElement& e, const tP_VLAN_ID& i)
    {
      e << static_cast< const ::IEC61850::SCL::tP& > (i);
    }
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

