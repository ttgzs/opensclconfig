// Copyright (C) 2005-2008 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include "SCL_Substation-pskel.h"

namespace IEC61850
{
  namespace SCL
  {
    namespace Validation
    {
      // tLNodeContainer_pskel
      //

      void tLNodeContainer_pskel::
      LNode_parser (::IEC61850::SCL::Validation::tLNode_pskel& p)
      {
        this->LNode_parser_ = &p;
      }

      void tLNodeContainer_pskel::
      parsers (::IEC61850::SCL::Validation::tText_pskel& Text,
               ::IEC61850::SCL::Validation::tPrivate_pskel& Private,
               ::IEC61850::SCL::Validation::tName_pskel& name,
               ::xml_schema::normalized_string_pskel& desc,
               ::IEC61850::SCL::Validation::tLNode_pskel& LNode)
      {
        this->Text_parser_ = &Text;
        this->Private_parser_ = &Private;
        this->name_parser_ = &name;
        this->desc_parser_ = &desc;
        this->LNode_parser_ = &LNode;
      }

      tLNodeContainer_pskel::
      tLNodeContainer_pskel ()
      : LNode_parser_ (0),
        v_state_stack_ (sizeof (v_state_), &v_state_first_)
      {
      }

      // tEquipmentContainer_pskel
      //

      void tEquipmentContainer_pskel::
      PowerTransformer_parser (::IEC61850::SCL::Validation::tPowerTransformer_pskel& p)
      {
        this->PowerTransformer_parser_ = &p;
      }

      void tEquipmentContainer_pskel::
      GeneralEquipment_parser (::IEC61850::SCL::Validation::tGeneralEquipment_pskel& p)
      {
        this->GeneralEquipment_parser_ = &p;
      }

      void tEquipmentContainer_pskel::
      parsers (::IEC61850::SCL::Validation::tText_pskel& Text,
               ::IEC61850::SCL::Validation::tPrivate_pskel& Private,
               ::IEC61850::SCL::Validation::tName_pskel& name,
               ::xml_schema::normalized_string_pskel& desc,
               ::IEC61850::SCL::Validation::tLNode_pskel& LNode,
               ::IEC61850::SCL::Validation::tPowerTransformer_pskel& PowerTransformer,
               ::IEC61850::SCL::Validation::tGeneralEquipment_pskel& GeneralEquipment)
      {
        this->Text_parser_ = &Text;
        this->Private_parser_ = &Private;
        this->name_parser_ = &name;
        this->desc_parser_ = &desc;
        this->LNode_parser_ = &LNode;
        this->PowerTransformer_parser_ = &PowerTransformer;
        this->GeneralEquipment_parser_ = &GeneralEquipment;
      }

      tEquipmentContainer_pskel::
      tEquipmentContainer_pskel ()
      : PowerTransformer_parser_ (0),
        GeneralEquipment_parser_ (0),
        v_state_stack_ (sizeof (v_state_), &v_state_first_)
      {
      }

      // tEquipment_pskel
      //

      void tEquipment_pskel::
      virtual_parser (::xml_schema::boolean_pskel& p)
      {
        this->virtual__parser_ = &p;
      }

      void tEquipment_pskel::
      parsers (::IEC61850::SCL::Validation::tText_pskel& Text,
               ::IEC61850::SCL::Validation::tPrivate_pskel& Private,
               ::IEC61850::SCL::Validation::tName_pskel& name,
               ::xml_schema::normalized_string_pskel& desc,
               ::IEC61850::SCL::Validation::tLNode_pskel& LNode,
               ::xml_schema::boolean_pskel& virtual_)
      {
        this->Text_parser_ = &Text;
        this->Private_parser_ = &Private;
        this->name_parser_ = &name;
        this->desc_parser_ = &desc;
        this->LNode_parser_ = &LNode;
        this->virtual__parser_ = &virtual_;
      }

      tEquipment_pskel::
      tEquipment_pskel ()
      : virtual__parser_ (0)
      {
      }

      // tAbstractConductingEquipment_pskel
      //

      void tAbstractConductingEquipment_pskel::
      Terminal_parser (::IEC61850::SCL::Validation::tTerminal_pskel& p)
      {
        this->Terminal_parser_ = &p;
      }

      void tAbstractConductingEquipment_pskel::
      SubEquipment_parser (::IEC61850::SCL::Validation::tSubEquipment_pskel& p)
      {
        this->SubEquipment_parser_ = &p;
      }

      void tAbstractConductingEquipment_pskel::
      parsers (::IEC61850::SCL::Validation::tText_pskel& Text,
               ::IEC61850::SCL::Validation::tPrivate_pskel& Private,
               ::IEC61850::SCL::Validation::tName_pskel& name,
               ::xml_schema::normalized_string_pskel& desc,
               ::IEC61850::SCL::Validation::tLNode_pskel& LNode,
               ::xml_schema::boolean_pskel& virtual_,
               ::IEC61850::SCL::Validation::tTerminal_pskel& Terminal,
               ::IEC61850::SCL::Validation::tSubEquipment_pskel& SubEquipment)
      {
        this->Text_parser_ = &Text;
        this->Private_parser_ = &Private;
        this->name_parser_ = &name;
        this->desc_parser_ = &desc;
        this->LNode_parser_ = &LNode;
        this->virtual__parser_ = &virtual_;
        this->Terminal_parser_ = &Terminal;
        this->SubEquipment_parser_ = &SubEquipment;
      }

      tAbstractConductingEquipment_pskel::
      tAbstractConductingEquipment_pskel ()
      : Terminal_parser_ (0),
        SubEquipment_parser_ (0),
        v_state_stack_ (sizeof (v_state_), &v_state_first_)
      {
      }

      // tConductingEquipment_pskel
      //

      void tConductingEquipment_pskel::
      type_parser (::IEC61850::SCL::Validation::tCommonConductingEquipmentEnum_pskel& p)
      {
        this->type_parser_ = &p;
      }

      void tConductingEquipment_pskel::
      parsers (::IEC61850::SCL::Validation::tText_pskel& Text,
               ::IEC61850::SCL::Validation::tPrivate_pskel& Private,
               ::IEC61850::SCL::Validation::tName_pskel& name,
               ::xml_schema::normalized_string_pskel& desc,
               ::IEC61850::SCL::Validation::tLNode_pskel& LNode,
               ::xml_schema::boolean_pskel& virtual_,
               ::IEC61850::SCL::Validation::tTerminal_pskel& Terminal,
               ::IEC61850::SCL::Validation::tSubEquipment_pskel& SubEquipment,
               ::IEC61850::SCL::Validation::tCommonConductingEquipmentEnum_pskel& type)
      {
        this->Text_parser_ = &Text;
        this->Private_parser_ = &Private;
        this->name_parser_ = &name;
        this->desc_parser_ = &desc;
        this->LNode_parser_ = &LNode;
        this->virtual__parser_ = &virtual_;
        this->Terminal_parser_ = &Terminal;
        this->SubEquipment_parser_ = &SubEquipment;
        this->type_parser_ = &type;
      }

      tConductingEquipment_pskel::
      tConductingEquipment_pskel ()
      : type_parser_ (0),
        v_state_attr_stack_ (sizeof (v_state_attr_), &v_state_attr_first_)
      {
      }

      // tSubEquipment_pskel
      //

      void tSubEquipment_pskel::
      phase_parser (::IEC61850::SCL::Validation::tPhaseEnum_pskel& p)
      {
        this->phase_parser_ = &p;
      }

      void tSubEquipment_pskel::
      virtual_parser (::xml_schema::boolean_pskel& p)
      {
        this->virtual__parser_ = &p;
      }

      void tSubEquipment_pskel::
      parsers (::IEC61850::SCL::Validation::tText_pskel& Text,
               ::IEC61850::SCL::Validation::tPrivate_pskel& Private,
               ::IEC61850::SCL::Validation::tName_pskel& name,
               ::xml_schema::normalized_string_pskel& desc,
               ::IEC61850::SCL::Validation::tLNode_pskel& LNode,
               ::IEC61850::SCL::Validation::tPhaseEnum_pskel& phase,
               ::xml_schema::boolean_pskel& virtual_)
      {
        this->Text_parser_ = &Text;
        this->Private_parser_ = &Private;
        this->name_parser_ = &name;
        this->desc_parser_ = &desc;
        this->LNode_parser_ = &LNode;
        this->phase_parser_ = &phase;
        this->virtual__parser_ = &virtual_;
      }

      tSubEquipment_pskel::
      tSubEquipment_pskel ()
      : phase_parser_ (0),
        virtual__parser_ (0)
      {
      }

      // tPowerTransformer_pskel
      //

      void tPowerTransformer_pskel::
      TransformerWinding_parser (::IEC61850::SCL::Validation::tTransformerWinding_pskel& p)
      {
        this->TransformerWinding_parser_ = &p;
      }

      void tPowerTransformer_pskel::
      type_parser (::IEC61850::SCL::Validation::tPowerTransformerEnum_pskel& p)
      {
        this->type_parser_ = &p;
      }

      void tPowerTransformer_pskel::
      parsers (::IEC61850::SCL::Validation::tText_pskel& Text,
               ::IEC61850::SCL::Validation::tPrivate_pskel& Private,
               ::IEC61850::SCL::Validation::tName_pskel& name,
               ::xml_schema::normalized_string_pskel& desc,
               ::IEC61850::SCL::Validation::tLNode_pskel& LNode,
               ::xml_schema::boolean_pskel& virtual_,
               ::IEC61850::SCL::Validation::tTransformerWinding_pskel& TransformerWinding,
               ::IEC61850::SCL::Validation::tPowerTransformerEnum_pskel& type)
      {
        this->Text_parser_ = &Text;
        this->Private_parser_ = &Private;
        this->name_parser_ = &name;
        this->desc_parser_ = &desc;
        this->LNode_parser_ = &LNode;
        this->virtual__parser_ = &virtual_;
        this->TransformerWinding_parser_ = &TransformerWinding;
        this->type_parser_ = &type;
      }

      tPowerTransformer_pskel::
      tPowerTransformer_pskel ()
      : TransformerWinding_parser_ (0),
        type_parser_ (0),
        v_state_stack_ (sizeof (v_state_), &v_state_first_),
        v_state_attr_stack_ (sizeof (v_state_attr_), &v_state_attr_first_)
      {
      }

      // tTransformerWinding_pskel
      //

      void tTransformerWinding_pskel::
      TapChanger_parser (::IEC61850::SCL::Validation::tTapChanger_pskel& p)
      {
        this->TapChanger_parser_ = &p;
      }

      void tTransformerWinding_pskel::
      type_parser (::IEC61850::SCL::Validation::tTransformerWindingEnum_pskel& p)
      {
        this->type_parser_ = &p;
      }

      void tTransformerWinding_pskel::
      parsers (::IEC61850::SCL::Validation::tText_pskel& Text,
               ::IEC61850::SCL::Validation::tPrivate_pskel& Private,
               ::IEC61850::SCL::Validation::tName_pskel& name,
               ::xml_schema::normalized_string_pskel& desc,
               ::IEC61850::SCL::Validation::tLNode_pskel& LNode,
               ::xml_schema::boolean_pskel& virtual_,
               ::IEC61850::SCL::Validation::tTerminal_pskel& Terminal,
               ::IEC61850::SCL::Validation::tSubEquipment_pskel& SubEquipment,
               ::IEC61850::SCL::Validation::tTapChanger_pskel& TapChanger,
               ::IEC61850::SCL::Validation::tTransformerWindingEnum_pskel& type)
      {
        this->Text_parser_ = &Text;
        this->Private_parser_ = &Private;
        this->name_parser_ = &name;
        this->desc_parser_ = &desc;
        this->LNode_parser_ = &LNode;
        this->virtual__parser_ = &virtual_;
        this->Terminal_parser_ = &Terminal;
        this->SubEquipment_parser_ = &SubEquipment;
        this->TapChanger_parser_ = &TapChanger;
        this->type_parser_ = &type;
      }

      tTransformerWinding_pskel::
      tTransformerWinding_pskel ()
      : TapChanger_parser_ (0),
        type_parser_ (0),
        v_state_stack_ (sizeof (v_state_), &v_state_first_),
        v_state_attr_stack_ (sizeof (v_state_attr_), &v_state_attr_first_)
      {
      }

      // tTapChanger_pskel
      //

      void tTapChanger_pskel::
      type_parser (::xml_schema::name_pskel& p)
      {
        this->type_parser_ = &p;
      }

      void tTapChanger_pskel::
      virtual_parser (::xml_schema::boolean_pskel& p)
      {
        this->virtual__parser_ = &p;
      }

      void tTapChanger_pskel::
      parsers (::IEC61850::SCL::Validation::tText_pskel& Text,
               ::IEC61850::SCL::Validation::tPrivate_pskel& Private,
               ::IEC61850::SCL::Validation::tName_pskel& name,
               ::xml_schema::normalized_string_pskel& desc,
               ::IEC61850::SCL::Validation::tLNode_pskel& LNode,
               ::xml_schema::name_pskel& type,
               ::xml_schema::boolean_pskel& virtual_)
      {
        this->Text_parser_ = &Text;
        this->Private_parser_ = &Private;
        this->name_parser_ = &name;
        this->desc_parser_ = &desc;
        this->LNode_parser_ = &LNode;
        this->type_parser_ = &type;
        this->virtual__parser_ = &virtual_;
      }

      tTapChanger_pskel::
      tTapChanger_pskel ()
      : type_parser_ (0),
        virtual__parser_ (0),
        v_state_attr_stack_ (sizeof (v_state_attr_), &v_state_attr_first_)
      {
      }

      // tGeneralEquipment_pskel
      //

      void tGeneralEquipment_pskel::
      type_parser (::IEC61850::SCL::Validation::tGeneralEquipmentEnum_pskel& p)
      {
        this->type_parser_ = &p;
      }

      void tGeneralEquipment_pskel::
      parsers (::IEC61850::SCL::Validation::tText_pskel& Text,
               ::IEC61850::SCL::Validation::tPrivate_pskel& Private,
               ::IEC61850::SCL::Validation::tName_pskel& name,
               ::xml_schema::normalized_string_pskel& desc,
               ::IEC61850::SCL::Validation::tLNode_pskel& LNode,
               ::xml_schema::boolean_pskel& virtual_,
               ::IEC61850::SCL::Validation::tGeneralEquipmentEnum_pskel& type)
      {
        this->Text_parser_ = &Text;
        this->Private_parser_ = &Private;
        this->name_parser_ = &name;
        this->desc_parser_ = &desc;
        this->LNode_parser_ = &LNode;
        this->virtual__parser_ = &virtual_;
        this->type_parser_ = &type;
      }

      tGeneralEquipment_pskel::
      tGeneralEquipment_pskel ()
      : type_parser_ (0),
        v_state_attr_stack_ (sizeof (v_state_attr_), &v_state_attr_first_)
      {
      }

      // tSubstation_pskel
      //

      void tSubstation_pskel::
      VoltageLevel_parser (::IEC61850::SCL::Validation::tVoltageLevel_pskel& p)
      {
        this->VoltageLevel_parser_ = &p;
      }

      void tSubstation_pskel::
      Function_parser (::IEC61850::SCL::Validation::tFunction_pskel& p)
      {
        this->Function_parser_ = &p;
      }

      void tSubstation_pskel::
      parsers (::IEC61850::SCL::Validation::tText_pskel& Text,
               ::IEC61850::SCL::Validation::tPrivate_pskel& Private,
               ::IEC61850::SCL::Validation::tName_pskel& name,
               ::xml_schema::normalized_string_pskel& desc,
               ::IEC61850::SCL::Validation::tLNode_pskel& LNode,
               ::IEC61850::SCL::Validation::tPowerTransformer_pskel& PowerTransformer,
               ::IEC61850::SCL::Validation::tGeneralEquipment_pskel& GeneralEquipment,
               ::IEC61850::SCL::Validation::tVoltageLevel_pskel& VoltageLevel,
               ::IEC61850::SCL::Validation::tFunction_pskel& Function)
      {
        this->Text_parser_ = &Text;
        this->Private_parser_ = &Private;
        this->name_parser_ = &name;
        this->desc_parser_ = &desc;
        this->LNode_parser_ = &LNode;
        this->PowerTransformer_parser_ = &PowerTransformer;
        this->GeneralEquipment_parser_ = &GeneralEquipment;
        this->VoltageLevel_parser_ = &VoltageLevel;
        this->Function_parser_ = &Function;
      }

      tSubstation_pskel::
      tSubstation_pskel ()
      : VoltageLevel_parser_ (0),
        Function_parser_ (0),
        v_state_stack_ (sizeof (v_state_), &v_state_first_)
      {
      }

      // tVoltageLevel_pskel
      //

      void tVoltageLevel_pskel::
      Voltage_parser (::IEC61850::SCL::Validation::tVoltage_pskel& p)
      {
        this->Voltage_parser_ = &p;
      }

      void tVoltageLevel_pskel::
      Bay_parser (::IEC61850::SCL::Validation::tBay_pskel& p)
      {
        this->Bay_parser_ = &p;
      }

      void tVoltageLevel_pskel::
      Function_parser (::IEC61850::SCL::Validation::tFunction_pskel& p)
      {
        this->Function_parser_ = &p;
      }

      void tVoltageLevel_pskel::
      parsers (::IEC61850::SCL::Validation::tText_pskel& Text,
               ::IEC61850::SCL::Validation::tPrivate_pskel& Private,
               ::IEC61850::SCL::Validation::tName_pskel& name,
               ::xml_schema::normalized_string_pskel& desc,
               ::IEC61850::SCL::Validation::tLNode_pskel& LNode,
               ::IEC61850::SCL::Validation::tPowerTransformer_pskel& PowerTransformer,
               ::IEC61850::SCL::Validation::tGeneralEquipment_pskel& GeneralEquipment,
               ::IEC61850::SCL::Validation::tVoltage_pskel& Voltage,
               ::IEC61850::SCL::Validation::tBay_pskel& Bay,
               ::IEC61850::SCL::Validation::tFunction_pskel& Function)
      {
        this->Text_parser_ = &Text;
        this->Private_parser_ = &Private;
        this->name_parser_ = &name;
        this->desc_parser_ = &desc;
        this->LNode_parser_ = &LNode;
        this->PowerTransformer_parser_ = &PowerTransformer;
        this->GeneralEquipment_parser_ = &GeneralEquipment;
        this->Voltage_parser_ = &Voltage;
        this->Bay_parser_ = &Bay;
        this->Function_parser_ = &Function;
      }

      tVoltageLevel_pskel::
      tVoltageLevel_pskel ()
      : Voltage_parser_ (0),
        Bay_parser_ (0),
        Function_parser_ (0),
        v_state_stack_ (sizeof (v_state_), &v_state_first_)
      {
      }

      // tBay_pskel
      //

      void tBay_pskel::
      ConductingEquipment_parser (::IEC61850::SCL::Validation::tConductingEquipment_pskel& p)
      {
        this->ConductingEquipment_parser_ = &p;
      }

      void tBay_pskel::
      ConnectivityNode_parser (::IEC61850::SCL::Validation::tConnectivityNode_pskel& p)
      {
        this->ConnectivityNode_parser_ = &p;
      }

      void tBay_pskel::
      Function_parser (::IEC61850::SCL::Validation::tFunction_pskel& p)
      {
        this->Function_parser_ = &p;
      }

      void tBay_pskel::
      parsers (::IEC61850::SCL::Validation::tText_pskel& Text,
               ::IEC61850::SCL::Validation::tPrivate_pskel& Private,
               ::IEC61850::SCL::Validation::tName_pskel& name,
               ::xml_schema::normalized_string_pskel& desc,
               ::IEC61850::SCL::Validation::tLNode_pskel& LNode,
               ::IEC61850::SCL::Validation::tPowerTransformer_pskel& PowerTransformer,
               ::IEC61850::SCL::Validation::tGeneralEquipment_pskel& GeneralEquipment,
               ::IEC61850::SCL::Validation::tConductingEquipment_pskel& ConductingEquipment,
               ::IEC61850::SCL::Validation::tConnectivityNode_pskel& ConnectivityNode,
               ::IEC61850::SCL::Validation::tFunction_pskel& Function)
      {
        this->Text_parser_ = &Text;
        this->Private_parser_ = &Private;
        this->name_parser_ = &name;
        this->desc_parser_ = &desc;
        this->LNode_parser_ = &LNode;
        this->PowerTransformer_parser_ = &PowerTransformer;
        this->GeneralEquipment_parser_ = &GeneralEquipment;
        this->ConductingEquipment_parser_ = &ConductingEquipment;
        this->ConnectivityNode_parser_ = &ConnectivityNode;
        this->Function_parser_ = &Function;
      }

      tBay_pskel::
      tBay_pskel ()
      : ConductingEquipment_parser_ (0),
        ConnectivityNode_parser_ (0),
        Function_parser_ (0),
        v_state_stack_ (sizeof (v_state_), &v_state_first_)
      {
      }

      // tLNode_pskel
      //

      void tLNode_pskel::
      lnInst_parser (::IEC61850::SCL::Validation::tAnyName_pskel& p)
      {
        this->lnInst_parser_ = &p;
      }

      void tLNode_pskel::
      lnClass_parser (::IEC61850::SCL::Validation::tLNClassEnum_pskel& p)
      {
        this->lnClass_parser_ = &p;
      }

      void tLNode_pskel::
      iedName_parser (::IEC61850::SCL::Validation::tName_pskel& p)
      {
        this->iedName_parser_ = &p;
      }

      void tLNode_pskel::
      ldInst_parser (::IEC61850::SCL::Validation::tAnyName_pskel& p)
      {
        this->ldInst_parser_ = &p;
      }

      void tLNode_pskel::
      prefix_parser (::IEC61850::SCL::Validation::tAnyName_pskel& p)
      {
        this->prefix_parser_ = &p;
      }

      void tLNode_pskel::
      lnType_parser (::IEC61850::SCL::Validation::tName_pskel& p)
      {
        this->lnType_parser_ = &p;
      }

      void tLNode_pskel::
      parsers (::IEC61850::SCL::Validation::tText_pskel& Text,
               ::IEC61850::SCL::Validation::tPrivate_pskel& Private,
               ::xml_schema::normalized_string_pskel& desc,
               ::IEC61850::SCL::Validation::tAnyName_pskel& lnInst,
               ::IEC61850::SCL::Validation::tLNClassEnum_pskel& lnClass,
               ::IEC61850::SCL::Validation::tName_pskel& iedName,
               ::IEC61850::SCL::Validation::tAnyName_pskel& ldInst,
               ::IEC61850::SCL::Validation::tAnyName_pskel& prefix,
               ::IEC61850::SCL::Validation::tName_pskel& lnType)
      {
        this->Text_parser_ = &Text;
        this->Private_parser_ = &Private;
        this->desc_parser_ = &desc;
        this->lnInst_parser_ = &lnInst;
        this->lnClass_parser_ = &lnClass;
        this->iedName_parser_ = &iedName;
        this->ldInst_parser_ = &ldInst;
        this->prefix_parser_ = &prefix;
        this->lnType_parser_ = &lnType;
      }

      tLNode_pskel::
      tLNode_pskel ()
      : lnInst_parser_ (0),
        lnClass_parser_ (0),
        iedName_parser_ (0),
        ldInst_parser_ (0),
        prefix_parser_ (0),
        lnType_parser_ (0),
        v_state_attr_stack_ (sizeof (v_state_attr_), &v_state_attr_first_)
      {
      }

      // tFunction_pskel
      //

      void tFunction_pskel::
      SubFunction_parser (::IEC61850::SCL::Validation::tSubFunction_pskel& p)
      {
        this->SubFunction_parser_ = &p;
      }

      void tFunction_pskel::
      GeneralEquipment_parser (::IEC61850::SCL::Validation::tGeneralEquipment_pskel& p)
      {
        this->GeneralEquipment_parser_ = &p;
      }

      void tFunction_pskel::
      parsers (::IEC61850::SCL::Validation::tText_pskel& Text,
               ::IEC61850::SCL::Validation::tPrivate_pskel& Private,
               ::IEC61850::SCL::Validation::tName_pskel& name,
               ::xml_schema::normalized_string_pskel& desc,
               ::IEC61850::SCL::Validation::tLNode_pskel& LNode,
               ::IEC61850::SCL::Validation::tSubFunction_pskel& SubFunction,
               ::IEC61850::SCL::Validation::tGeneralEquipment_pskel& GeneralEquipment)
      {
        this->Text_parser_ = &Text;
        this->Private_parser_ = &Private;
        this->name_parser_ = &name;
        this->desc_parser_ = &desc;
        this->LNode_parser_ = &LNode;
        this->SubFunction_parser_ = &SubFunction;
        this->GeneralEquipment_parser_ = &GeneralEquipment;
      }

      tFunction_pskel::
      tFunction_pskel ()
      : SubFunction_parser_ (0),
        GeneralEquipment_parser_ (0),
        v_state_stack_ (sizeof (v_state_), &v_state_first_)
      {
      }

      // tSubFunction_pskel
      //

      void tSubFunction_pskel::
      GeneralEquipment_parser (::IEC61850::SCL::Validation::tGeneralEquipment_pskel& p)
      {
        this->GeneralEquipment_parser_ = &p;
      }

      void tSubFunction_pskel::
      parsers (::IEC61850::SCL::Validation::tText_pskel& Text,
               ::IEC61850::SCL::Validation::tPrivate_pskel& Private,
               ::IEC61850::SCL::Validation::tName_pskel& name,
               ::xml_schema::normalized_string_pskel& desc,
               ::IEC61850::SCL::Validation::tLNode_pskel& LNode,
               ::IEC61850::SCL::Validation::tGeneralEquipment_pskel& GeneralEquipment)
      {
        this->Text_parser_ = &Text;
        this->Private_parser_ = &Private;
        this->name_parser_ = &name;
        this->desc_parser_ = &desc;
        this->LNode_parser_ = &LNode;
        this->GeneralEquipment_parser_ = &GeneralEquipment;
      }

      tSubFunction_pskel::
      tSubFunction_pskel ()
      : GeneralEquipment_parser_ (0),
        v_state_stack_ (sizeof (v_state_), &v_state_first_)
      {
      }

      // tConnectivityNode_pskel
      //

      void tConnectivityNode_pskel::
      pathName_parser (::IEC61850::SCL::Validation::tRef_pskel& p)
      {
        this->pathName_parser_ = &p;
      }

      void tConnectivityNode_pskel::
      parsers (::IEC61850::SCL::Validation::tText_pskel& Text,
               ::IEC61850::SCL::Validation::tPrivate_pskel& Private,
               ::IEC61850::SCL::Validation::tName_pskel& name,
               ::xml_schema::normalized_string_pskel& desc,
               ::IEC61850::SCL::Validation::tLNode_pskel& LNode,
               ::IEC61850::SCL::Validation::tRef_pskel& pathName)
      {
        this->Text_parser_ = &Text;
        this->Private_parser_ = &Private;
        this->name_parser_ = &name;
        this->desc_parser_ = &desc;
        this->LNode_parser_ = &LNode;
        this->pathName_parser_ = &pathName;
      }

      tConnectivityNode_pskel::
      tConnectivityNode_pskel ()
      : pathName_parser_ (0),
        v_state_attr_stack_ (sizeof (v_state_attr_), &v_state_attr_first_)
      {
      }

      // tTerminal_pskel
      //

      void tTerminal_pskel::
      name_parser (::IEC61850::SCL::Validation::tAnyName_pskel& p)
      {
        this->name_parser_ = &p;
      }

      void tTerminal_pskel::
      connectivityNode_parser (::IEC61850::SCL::Validation::tRef_pskel& p)
      {
        this->connectivityNode_parser_ = &p;
      }

      void tTerminal_pskel::
      substationName_parser (::IEC61850::SCL::Validation::tName_pskel& p)
      {
        this->substationName_parser_ = &p;
      }

      void tTerminal_pskel::
      voltageLevelName_parser (::IEC61850::SCL::Validation::tName_pskel& p)
      {
        this->voltageLevelName_parser_ = &p;
      }

      void tTerminal_pskel::
      bayName_parser (::IEC61850::SCL::Validation::tName_pskel& p)
      {
        this->bayName_parser_ = &p;
      }

      void tTerminal_pskel::
      cNodeName_parser (::IEC61850::SCL::Validation::tName_pskel& p)
      {
        this->cNodeName_parser_ = &p;
      }

      void tTerminal_pskel::
      parsers (::IEC61850::SCL::Validation::tText_pskel& Text,
               ::IEC61850::SCL::Validation::tPrivate_pskel& Private,
               ::xml_schema::normalized_string_pskel& desc,
               ::IEC61850::SCL::Validation::tAnyName_pskel& name,
               ::IEC61850::SCL::Validation::tRef_pskel& connectivityNode,
               ::IEC61850::SCL::Validation::tName_pskel& substationName,
               ::IEC61850::SCL::Validation::tName_pskel& voltageLevelName,
               ::IEC61850::SCL::Validation::tName_pskel& bayName,
               ::IEC61850::SCL::Validation::tName_pskel& cNodeName)
      {
        this->Text_parser_ = &Text;
        this->Private_parser_ = &Private;
        this->desc_parser_ = &desc;
        this->name_parser_ = &name;
        this->connectivityNode_parser_ = &connectivityNode;
        this->substationName_parser_ = &substationName;
        this->voltageLevelName_parser_ = &voltageLevelName;
        this->bayName_parser_ = &bayName;
        this->cNodeName_parser_ = &cNodeName;
      }

      tTerminal_pskel::
      tTerminal_pskel ()
      : name_parser_ (0),
        connectivityNode_parser_ (0),
        substationName_parser_ (0),
        voltageLevelName_parser_ (0),
        bayName_parser_ (0),
        cNodeName_parser_ (0),
        v_state_attr_stack_ (sizeof (v_state_attr_), &v_state_attr_first_)
      {
      }
    }
  }
}

namespace IEC61850
{
  namespace SCL
  {
    namespace Validation
    {
      // tLNodeContainer_pskel
      //

      void tLNodeContainer_pskel::
      LNode ()
      {
      }

      void tLNodeContainer_pskel::
      post_tLNodeContainer ()
      {
        post_tNaming ();
      }

      // tPowerSystemResource_pskel
      //

      void tPowerSystemResource_pskel::
      post_tPowerSystemResource ()
      {
        post_tLNodeContainer ();
      }

      // tEquipmentContainer_pskel
      //

      void tEquipmentContainer_pskel::
      PowerTransformer ()
      {
      }

      void tEquipmentContainer_pskel::
      GeneralEquipment ()
      {
      }

      void tEquipmentContainer_pskel::
      post_tEquipmentContainer ()
      {
        post_tPowerSystemResource ();
      }

      // tEquipment_pskel
      //

      void tEquipment_pskel::
      virtual_ (bool)
      {
      }

      void tEquipment_pskel::
      post_tEquipment ()
      {
        post_tPowerSystemResource ();
      }

      // tAbstractConductingEquipment_pskel
      //

      void tAbstractConductingEquipment_pskel::
      Terminal ()
      {
      }

      void tAbstractConductingEquipment_pskel::
      SubEquipment ()
      {
      }

      void tAbstractConductingEquipment_pskel::
      post_tAbstractConductingEquipment ()
      {
        post_tEquipment ();
      }

      // tConductingEquipment_pskel
      //

      void tConductingEquipment_pskel::
      type ()
      {
      }

      void tConductingEquipment_pskel::
      post_tConductingEquipment ()
      {
        post_tAbstractConductingEquipment ();
      }

      // tSubEquipment_pskel
      //

      void tSubEquipment_pskel::
      phase ()
      {
      }

      void tSubEquipment_pskel::
      virtual_ (bool)
      {
      }

      void tSubEquipment_pskel::
      post_tSubEquipment ()
      {
        post_tPowerSystemResource ();
      }

      // tPowerTransformer_pskel
      //

      void tPowerTransformer_pskel::
      TransformerWinding ()
      {
      }

      void tPowerTransformer_pskel::
      type ()
      {
      }

      void tPowerTransformer_pskel::
      post_tPowerTransformer ()
      {
        post_tEquipment ();
      }

      // tTransformerWinding_pskel
      //

      void tTransformerWinding_pskel::
      TapChanger ()
      {
      }

      void tTransformerWinding_pskel::
      type ()
      {
      }

      void tTransformerWinding_pskel::
      post_tTransformerWinding ()
      {
        post_tAbstractConductingEquipment ();
      }

      // tTapChanger_pskel
      //

      void tTapChanger_pskel::
      type (const ::std::string&)
      {
      }

      void tTapChanger_pskel::
      virtual_ (bool)
      {
      }

      void tTapChanger_pskel::
      post_tTapChanger ()
      {
        post_tPowerSystemResource ();
      }

      // tGeneralEquipment_pskel
      //

      void tGeneralEquipment_pskel::
      type ()
      {
      }

      void tGeneralEquipment_pskel::
      post_tGeneralEquipment ()
      {
        post_tEquipment ();
      }

      // tSubstation_pskel
      //

      void tSubstation_pskel::
      VoltageLevel ()
      {
      }

      void tSubstation_pskel::
      Function ()
      {
      }

      void tSubstation_pskel::
      post_tSubstation ()
      {
        post_tEquipmentContainer ();
      }

      // tVoltageLevel_pskel
      //

      void tVoltageLevel_pskel::
      Voltage ()
      {
      }

      void tVoltageLevel_pskel::
      Bay ()
      {
      }

      void tVoltageLevel_pskel::
      Function ()
      {
      }

      void tVoltageLevel_pskel::
      post_tVoltageLevel ()
      {
        post_tEquipmentContainer ();
      }

      // tBay_pskel
      //

      void tBay_pskel::
      ConductingEquipment ()
      {
      }

      void tBay_pskel::
      ConnectivityNode ()
      {
      }

      void tBay_pskel::
      Function ()
      {
      }

      void tBay_pskel::
      post_tBay ()
      {
        post_tEquipmentContainer ();
      }

      // tLNode_pskel
      //

      void tLNode_pskel::
      lnInst ()
      {
      }

      void tLNode_pskel::
      lnClass ()
      {
      }

      void tLNode_pskel::
      iedName ()
      {
      }

      void tLNode_pskel::
      ldInst ()
      {
      }

      void tLNode_pskel::
      prefix ()
      {
      }

      void tLNode_pskel::
      lnType ()
      {
      }

      void tLNode_pskel::
      post_tLNode ()
      {
        post_tUnNaming ();
      }

      // tFunction_pskel
      //

      void tFunction_pskel::
      SubFunction ()
      {
      }

      void tFunction_pskel::
      GeneralEquipment ()
      {
      }

      void tFunction_pskel::
      post_tFunction ()
      {
        post_tPowerSystemResource ();
      }

      // tSubFunction_pskel
      //

      void tSubFunction_pskel::
      GeneralEquipment ()
      {
      }

      void tSubFunction_pskel::
      post_tSubFunction ()
      {
        post_tPowerSystemResource ();
      }

      // tConnectivityNode_pskel
      //

      void tConnectivityNode_pskel::
      pathName ()
      {
      }

      void tConnectivityNode_pskel::
      post_tConnectivityNode ()
      {
        post_tLNodeContainer ();
      }

      // tTerminal_pskel
      //

      void tTerminal_pskel::
      name ()
      {
      }

      void tTerminal_pskel::
      connectivityNode ()
      {
      }

      void tTerminal_pskel::
      substationName ()
      {
      }

      void tTerminal_pskel::
      voltageLevelName ()
      {
      }

      void tTerminal_pskel::
      bayName ()
      {
      }

      void tTerminal_pskel::
      cNodeName ()
      {
      }

      void tTerminal_pskel::
      post_tTerminal ()
      {
        post_tUnNaming ();
      }
    }
  }
}

#include <cassert>

namespace IEC61850
{
  namespace SCL
  {
    namespace Validation
    {
      // Element validation and dispatch functions for tLNodeContainer_pskel.
      //
      bool tLNodeContainer_pskel::
      _start_element_impl (const ::xml_schema::ro_string& ns,
                           const ::xml_schema::ro_string& n,
                           const ::xml_schema::ro_string* t)
      {
        XSD_UNUSED (t);

        v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
        v_state_descr_* vd = vs.data + (vs.size - 1);

        if (vd->func == 0 && vd->state == 0)
        {
          if (this->::IEC61850::SCL::Validation::tNaming_pskel::_start_element_impl (ns, n, t))
            return true;
          else
            vd->state = 1;
        }

        while (vd->func != 0)
        {
          (this->*vd->func) (vd->state, vd->count, ns, n, t, true);

          vd = vs.data + (vs.size - 1);

          if (vd->state == ~0UL)
            vd = vs.data + (--vs.size - 1);
          else
            break;
        }

        if (vd->func == 0)
        {
          if (vd->state != ~0UL)
          {
            unsigned long s = ~0UL;

            if (n == "LNode" &&
                ns == "http://www.iec.ch/61850/2003/SCL")
              s = 0UL;

            if (s != ~0UL)
            {
              vd->count++;
              vd->state = ~0UL;

              vd = vs.data + vs.size++;
              vd->func = &tLNodeContainer_pskel::sequence_0;
              vd->state = s;
              vd->count = 0;

              this->sequence_0 (vd->state, vd->count, ns, n, t, true);
            }
            else
            {
              return false;
            }
          }
          else
            return false;
        }

        return true;
      }

      bool tLNodeContainer_pskel::
      _end_element_impl (const ::xml_schema::ro_string& ns,
                         const ::xml_schema::ro_string& n)
      {
        v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
        v_state_descr_& vd = vs.data[vs.size - 1];

        if (vd.func == 0 && vd.state == 0)
        {
          if (!::IEC61850::SCL::Validation::tNaming_pskel::_end_element_impl (ns, n))
            assert (false);
          return true;
        }

        assert (vd.func != 0);
        (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

        if (vd.state == ~0UL)
          vs.size--;

        return true;
      }

      void tLNodeContainer_pskel::
      _pre_e_validate ()
      {
        this->v_state_stack_.push ();
        static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

        v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
        v_state_descr_& vd = vs.data[vs.size++];

        vd.func = 0;
        vd.state = 0;
        vd.count = 0;

        ::IEC61850::SCL::Validation::tNaming_pskel::_pre_e_validate ();
      }

      void tLNodeContainer_pskel::
      _post_e_validate ()
      {
        ::IEC61850::SCL::Validation::tNaming_pskel::_post_e_validate ();

        v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
        v_state_descr_* vd = vs.data + (vs.size - 1);

        ::xml_schema::ro_string empty;
        while (vd->func != 0)
        {
          (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
          assert (vd->state == ~0UL);
          vd = vs.data + (--vs.size - 1);
        }


        this->v_state_stack_.pop ();
      }

      void tLNodeContainer_pskel::
      sequence_0 (unsigned long& state,
                  unsigned long& count,
                  const ::xml_schema::ro_string& ns,
                  const ::xml_schema::ro_string& n,
                  const ::xml_schema::ro_string* t,
                  bool start)
      {
        XSD_UNUSED (t);

        switch (state)
        {
          case 0UL:
          {
            if (n == "LNode" &&
                ns == "http://www.iec.ch/61850/2003/SCL")
            {
              if (start)
              {
                this->::xml_schema::complex_content::context_.top ().parser_ = this->LNode_parser_;

                if (this->LNode_parser_)
                  this->LNode_parser_->pre ();
              }
              else
              {
                if (this->LNode_parser_)
                {
                  this->LNode_parser_->post_tLNode ();
                  this->LNode ();
                }

                count++;
              }

              break;
            }
            else
            {
              assert (start);
              count = 0;
              state = ~0UL;
              // Fall through.
            }
          }
          case ~0UL:
            break;
        }
      }

      // Element validation and dispatch functions for tEquipmentContainer_pskel.
      //
      bool tEquipmentContainer_pskel::
      _start_element_impl (const ::xml_schema::ro_string& ns,
                           const ::xml_schema::ro_string& n,
                           const ::xml_schema::ro_string* t)
      {
        XSD_UNUSED (t);

        v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
        v_state_descr_* vd = vs.data + (vs.size - 1);

        if (vd->func == 0 && vd->state == 0)
        {
          if (this->::IEC61850::SCL::Validation::tPowerSystemResource_pskel::_start_element_impl (ns, n, t))
            return true;
          else
            vd->state = 1;
        }

        while (vd->func != 0)
        {
          (this->*vd->func) (vd->state, vd->count, ns, n, t, true);

          vd = vs.data + (vs.size - 1);

          if (vd->state == ~0UL)
            vd = vs.data + (--vs.size - 1);
          else
            break;
        }

        if (vd->func == 0)
        {
          if (vd->state != ~0UL)
          {
            unsigned long s = ~0UL;

            if (n == "PowerTransformer" &&
                ns == "http://www.iec.ch/61850/2003/SCL")
              s = 0UL;
            else if (n == "GeneralEquipment" &&
                     ns == "http://www.iec.ch/61850/2003/SCL")
              s = 1UL;

            if (s != ~0UL)
            {
              vd->count++;
              vd->state = ~0UL;

              vd = vs.data + vs.size++;
              vd->func = &tEquipmentContainer_pskel::sequence_0;
              vd->state = s;
              vd->count = 0;

              this->sequence_0 (vd->state, vd->count, ns, n, t, true);
            }
            else
            {
              return false;
            }
          }
          else
            return false;
        }

        return true;
      }

      bool tEquipmentContainer_pskel::
      _end_element_impl (const ::xml_schema::ro_string& ns,
                         const ::xml_schema::ro_string& n)
      {
        v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
        v_state_descr_& vd = vs.data[vs.size - 1];

        if (vd.func == 0 && vd.state == 0)
        {
          if (!::IEC61850::SCL::Validation::tPowerSystemResource_pskel::_end_element_impl (ns, n))
            assert (false);
          return true;
        }

        assert (vd.func != 0);
        (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

        if (vd.state == ~0UL)
          vs.size--;

        return true;
      }

      void tEquipmentContainer_pskel::
      _pre_e_validate ()
      {
        this->v_state_stack_.push ();
        static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

        v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
        v_state_descr_& vd = vs.data[vs.size++];

        vd.func = 0;
        vd.state = 0;
        vd.count = 0;

        ::IEC61850::SCL::Validation::tPowerSystemResource_pskel::_pre_e_validate ();
      }

      void tEquipmentContainer_pskel::
      _post_e_validate ()
      {
        ::IEC61850::SCL::Validation::tPowerSystemResource_pskel::_post_e_validate ();

        v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
        v_state_descr_* vd = vs.data + (vs.size - 1);

        ::xml_schema::ro_string empty;
        while (vd->func != 0)
        {
          (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
          assert (vd->state == ~0UL);
          vd = vs.data + (--vs.size - 1);
        }


        this->v_state_stack_.pop ();
      }

      void tEquipmentContainer_pskel::
      sequence_0 (unsigned long& state,
                  unsigned long& count,
                  const ::xml_schema::ro_string& ns,
                  const ::xml_schema::ro_string& n,
                  const ::xml_schema::ro_string* t,
                  bool start)
      {
        XSD_UNUSED (t);

        switch (state)
        {
          case 0UL:
          {
            if (n == "PowerTransformer" &&
                ns == "http://www.iec.ch/61850/2003/SCL")
            {
              if (start)
              {
                this->::xml_schema::complex_content::context_.top ().parser_ = this->PowerTransformer_parser_;

                if (this->PowerTransformer_parser_)
                  this->PowerTransformer_parser_->pre ();
              }
              else
              {
                if (this->PowerTransformer_parser_)
                {
                  this->PowerTransformer_parser_->post_tPowerTransformer ();
                  this->PowerTransformer ();
                }

                count++;
              }

              break;
            }
            else
            {
              assert (start);
              count = 0;
              state = 1UL;
              // Fall through.
            }
          }
          case 1UL:
          {
            if (n == "GeneralEquipment" &&
                ns == "http://www.iec.ch/61850/2003/SCL")
            {
              if (start)
              {
                this->::xml_schema::complex_content::context_.top ().parser_ = this->GeneralEquipment_parser_;

                if (this->GeneralEquipment_parser_)
                  this->GeneralEquipment_parser_->pre ();
              }
              else
              {
                if (this->GeneralEquipment_parser_)
                {
                  this->GeneralEquipment_parser_->post_tGeneralEquipment ();
                  this->GeneralEquipment ();
                }

                count++;
              }

              break;
            }
            else
            {
              assert (start);
              count = 0;
              state = ~0UL;
              // Fall through.
            }
          }
          case ~0UL:
            break;
        }
      }

      // Element validation and dispatch functions for tAbstractConductingEquipment_pskel.
      //
      bool tAbstractConductingEquipment_pskel::
      _start_element_impl (const ::xml_schema::ro_string& ns,
                           const ::xml_schema::ro_string& n,
                           const ::xml_schema::ro_string* t)
      {
        XSD_UNUSED (t);

        v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
        v_state_descr_* vd = vs.data + (vs.size - 1);

        if (vd->func == 0 && vd->state == 0)
        {
          if (this->::IEC61850::SCL::Validation::tEquipment_pskel::_start_element_impl (ns, n, t))
            return true;
          else
            vd->state = 1;
        }

        while (vd->func != 0)
        {
          (this->*vd->func) (vd->state, vd->count, ns, n, t, true);

          vd = vs.data + (vs.size - 1);

          if (vd->state == ~0UL)
            vd = vs.data + (--vs.size - 1);
          else
            break;
        }

        if (vd->func == 0)
        {
          if (vd->state != ~0UL)
          {
            unsigned long s = ~0UL;

            if (n == "Terminal" &&
                ns == "http://www.iec.ch/61850/2003/SCL")
              s = 0UL;
            else if (n == "SubEquipment" &&
                     ns == "http://www.iec.ch/61850/2003/SCL")
              s = 1UL;

            if (s != ~0UL)
            {
              vd->count++;
              vd->state = ~0UL;

              vd = vs.data + vs.size++;
              vd->func = &tAbstractConductingEquipment_pskel::sequence_0;
              vd->state = s;
              vd->count = 0;

              this->sequence_0 (vd->state, vd->count, ns, n, t, true);
            }
            else
            {
              return false;
            }
          }
          else
            return false;
        }

        return true;
      }

      bool tAbstractConductingEquipment_pskel::
      _end_element_impl (const ::xml_schema::ro_string& ns,
                         const ::xml_schema::ro_string& n)
      {
        v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
        v_state_descr_& vd = vs.data[vs.size - 1];

        if (vd.func == 0 && vd.state == 0)
        {
          if (!::IEC61850::SCL::Validation::tEquipment_pskel::_end_element_impl (ns, n))
            assert (false);
          return true;
        }

        assert (vd.func != 0);
        (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

        if (vd.state == ~0UL)
          vs.size--;

        return true;
      }

      void tAbstractConductingEquipment_pskel::
      _pre_e_validate ()
      {
        this->v_state_stack_.push ();
        static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

        v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
        v_state_descr_& vd = vs.data[vs.size++];

        vd.func = 0;
        vd.state = 0;
        vd.count = 0;

        ::IEC61850::SCL::Validation::tEquipment_pskel::_pre_e_validate ();
      }

      void tAbstractConductingEquipment_pskel::
      _post_e_validate ()
      {
        ::IEC61850::SCL::Validation::tEquipment_pskel::_post_e_validate ();

        v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
        v_state_descr_* vd = vs.data + (vs.size - 1);

        ::xml_schema::ro_string empty;
        while (vd->func != 0)
        {
          (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
          assert (vd->state == ~0UL);
          vd = vs.data + (--vs.size - 1);
        }


        this->v_state_stack_.pop ();
      }

      void tAbstractConductingEquipment_pskel::
      sequence_0 (unsigned long& state,
                  unsigned long& count,
                  const ::xml_schema::ro_string& ns,
                  const ::xml_schema::ro_string& n,
                  const ::xml_schema::ro_string* t,
                  bool start)
      {
        XSD_UNUSED (t);

        switch (state)
        {
          case 0UL:
          {
            if (n == "Terminal" &&
                ns == "http://www.iec.ch/61850/2003/SCL")
            {
              if (start)
              {
                this->::xml_schema::complex_content::context_.top ().parser_ = this->Terminal_parser_;

                if (this->Terminal_parser_)
                  this->Terminal_parser_->pre ();
              }
              else
              {
                if (this->Terminal_parser_)
                {
                  this->Terminal_parser_->post_tTerminal ();
                  this->Terminal ();
                }

                if (++count == 2UL)
                {
                  count = 0;
                  state = 1UL;
                }
              }

              break;
            }
            else
            {
              assert (start);
              count = 0;
              state = 1UL;
              // Fall through.
            }
          }
          case 1UL:
          {
            if (n == "SubEquipment" &&
                ns == "http://www.iec.ch/61850/2003/SCL")
            {
              if (start)
              {
                this->::xml_schema::complex_content::context_.top ().parser_ = this->SubEquipment_parser_;

                if (this->SubEquipment_parser_)
                  this->SubEquipment_parser_->pre ();
              }
              else
              {
                if (this->SubEquipment_parser_)
                {
                  this->SubEquipment_parser_->post_tSubEquipment ();
                  this->SubEquipment ();
                }

                count++;
              }

              break;
            }
            else
            {
              assert (start);
              count = 0;
              state = ~0UL;
              // Fall through.
            }
          }
          case ~0UL:
            break;
        }
      }

      // Element validation and dispatch functions for tPowerTransformer_pskel.
      //
      bool tPowerTransformer_pskel::
      _start_element_impl (const ::xml_schema::ro_string& ns,
                           const ::xml_schema::ro_string& n,
                           const ::xml_schema::ro_string* t)
      {
        XSD_UNUSED (t);

        v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
        v_state_descr_* vd = vs.data + (vs.size - 1);

        if (vd->func == 0 && vd->state == 0)
        {
          if (this->::IEC61850::SCL::Validation::tEquipment_pskel::_start_element_impl (ns, n, t))
            return true;
          else
            vd->state = 1;
        }

        while (vd->func != 0)
        {
          (this->*vd->func) (vd->state, vd->count, ns, n, t, true);

          vd = vs.data + (vs.size - 1);

          if (vd->state == ~0UL)
            vd = vs.data + (--vs.size - 1);
          else
            break;
        }

        if (vd->func == 0)
        {
          if (vd->state != ~0UL)
          {
            unsigned long s = ~0UL;

            if (n == "TransformerWinding" &&
                ns == "http://www.iec.ch/61850/2003/SCL")
              s = 0UL;

            if (s != ~0UL)
            {
              vd->count++;
              vd->state = ~0UL;

              vd = vs.data + vs.size++;
              vd->func = &tPowerTransformer_pskel::sequence_0;
              vd->state = s;
              vd->count = 0;

              this->sequence_0 (vd->state, vd->count, ns, n, t, true);
            }
            else
            {
              if (vd->count < 1UL)
                this->_expected_element (
                  "http://www.iec.ch/61850/2003/SCL", "TransformerWinding",
                  ns, n);
              return false;
            }
          }
          else
            return false;
        }

        return true;
      }

      bool tPowerTransformer_pskel::
      _end_element_impl (const ::xml_schema::ro_string& ns,
                         const ::xml_schema::ro_string& n)
      {
        v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
        v_state_descr_& vd = vs.data[vs.size - 1];

        if (vd.func == 0 && vd.state == 0)
        {
          if (!::IEC61850::SCL::Validation::tEquipment_pskel::_end_element_impl (ns, n))
            assert (false);
          return true;
        }

        assert (vd.func != 0);
        (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

        if (vd.state == ~0UL)
          vs.size--;

        return true;
      }

      void tPowerTransformer_pskel::
      _pre_e_validate ()
      {
        this->v_state_stack_.push ();
        static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

        v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
        v_state_descr_& vd = vs.data[vs.size++];

        vd.func = 0;
        vd.state = 0;
        vd.count = 0;

        ::IEC61850::SCL::Validation::tEquipment_pskel::_pre_e_validate ();
      }

      void tPowerTransformer_pskel::
      _post_e_validate ()
      {
        ::IEC61850::SCL::Validation::tEquipment_pskel::_post_e_validate ();

        v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
        v_state_descr_* vd = vs.data + (vs.size - 1);

        ::xml_schema::ro_string empty;
        while (vd->func != 0)
        {
          (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
          assert (vd->state == ~0UL);
          vd = vs.data + (--vs.size - 1);
        }

        if (vd->count < 1UL)
          this->_expected_element (
            "http://www.iec.ch/61850/2003/SCL", "TransformerWinding");

        this->v_state_stack_.pop ();
      }

      void tPowerTransformer_pskel::
      sequence_0 (unsigned long& state,
                  unsigned long& count,
                  const ::xml_schema::ro_string& ns,
                  const ::xml_schema::ro_string& n,
                  const ::xml_schema::ro_string* t,
                  bool start)
      {
        XSD_UNUSED (t);

        switch (state)
        {
          case 0UL:
          {
            if (n == "TransformerWinding" &&
                ns == "http://www.iec.ch/61850/2003/SCL")
            {
              if (start)
              {
                this->::xml_schema::complex_content::context_.top ().parser_ = this->TransformerWinding_parser_;

                if (this->TransformerWinding_parser_)
                  this->TransformerWinding_parser_->pre ();
              }
              else
              {
                if (this->TransformerWinding_parser_)
                {
                  this->TransformerWinding_parser_->post_tTransformerWinding ();
                  this->TransformerWinding ();
                }

                count++;
              }

              break;
            }
            else
            {
              assert (start);
              if (count < 1UL)
                this->_expected_element (
                  "http://www.iec.ch/61850/2003/SCL", "TransformerWinding",
                  ns, n);
              count = 0;
              state = ~0UL;
              // Fall through.
            }
          }
          case ~0UL:
            break;
        }
      }

      // Element validation and dispatch functions for tTransformerWinding_pskel.
      //
      bool tTransformerWinding_pskel::
      _start_element_impl (const ::xml_schema::ro_string& ns,
                           const ::xml_schema::ro_string& n,
                           const ::xml_schema::ro_string* t)
      {
        XSD_UNUSED (t);

        v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
        v_state_descr_* vd = vs.data + (vs.size - 1);

        if (vd->func == 0 && vd->state == 0)
        {
          if (this->::IEC61850::SCL::Validation::tAbstractConductingEquipment_pskel::_start_element_impl (ns, n, t))
            return true;
          else
            vd->state = 1;
        }

        while (vd->func != 0)
        {
          (this->*vd->func) (vd->state, vd->count, ns, n, t, true);

          vd = vs.data + (vs.size - 1);

          if (vd->state == ~0UL)
            vd = vs.data + (--vs.size - 1);
          else
            break;
        }

        if (vd->func == 0)
        {
          if (vd->state != ~0UL)
          {
            unsigned long s = ~0UL;

            if (n == "TapChanger" &&
                ns == "http://www.iec.ch/61850/2003/SCL")
              s = 0UL;

            if (s != ~0UL)
            {
              vd->count++;
              vd->state = ~0UL;

              vd = vs.data + vs.size++;
              vd->func = &tTransformerWinding_pskel::sequence_0;
              vd->state = s;
              vd->count = 0;

              this->sequence_0 (vd->state, vd->count, ns, n, t, true);
            }
            else
            {
              return false;
            }
          }
          else
            return false;
        }

        return true;
      }

      bool tTransformerWinding_pskel::
      _end_element_impl (const ::xml_schema::ro_string& ns,
                         const ::xml_schema::ro_string& n)
      {
        v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
        v_state_descr_& vd = vs.data[vs.size - 1];

        if (vd.func == 0 && vd.state == 0)
        {
          if (!::IEC61850::SCL::Validation::tAbstractConductingEquipment_pskel::_end_element_impl (ns, n))
            assert (false);
          return true;
        }

        assert (vd.func != 0);
        (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

        if (vd.state == ~0UL)
          vs.size--;

        return true;
      }

      void tTransformerWinding_pskel::
      _pre_e_validate ()
      {
        this->v_state_stack_.push ();
        static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

        v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
        v_state_descr_& vd = vs.data[vs.size++];

        vd.func = 0;
        vd.state = 0;
        vd.count = 0;

        ::IEC61850::SCL::Validation::tAbstractConductingEquipment_pskel::_pre_e_validate ();
      }

      void tTransformerWinding_pskel::
      _post_e_validate ()
      {
        ::IEC61850::SCL::Validation::tAbstractConductingEquipment_pskel::_post_e_validate ();

        v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
        v_state_descr_* vd = vs.data + (vs.size - 1);

        ::xml_schema::ro_string empty;
        while (vd->func != 0)
        {
          (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
          assert (vd->state == ~0UL);
          vd = vs.data + (--vs.size - 1);
        }


        this->v_state_stack_.pop ();
      }

      void tTransformerWinding_pskel::
      sequence_0 (unsigned long& state,
                  unsigned long& count,
                  const ::xml_schema::ro_string& ns,
                  const ::xml_schema::ro_string& n,
                  const ::xml_schema::ro_string* t,
                  bool start)
      {
        XSD_UNUSED (t);

        switch (state)
        {
          case 0UL:
          {
            if (n == "TapChanger" &&
                ns == "http://www.iec.ch/61850/2003/SCL")
            {
              if (start)
              {
                this->::xml_schema::complex_content::context_.top ().parser_ = this->TapChanger_parser_;

                if (this->TapChanger_parser_)
                  this->TapChanger_parser_->pre ();
              }
              else
              {
                if (this->TapChanger_parser_)
                {
                  this->TapChanger_parser_->post_tTapChanger ();
                  this->TapChanger ();
                }

                count = 0;
                state = ~0UL;
              }

              break;
            }
            else
            {
              assert (start);
              count = 0;
              state = ~0UL;
              // Fall through.
            }
          }
          case ~0UL:
            break;
        }
      }

      // Element validation and dispatch functions for tSubstation_pskel.
      //
      bool tSubstation_pskel::
      _start_element_impl (const ::xml_schema::ro_string& ns,
                           const ::xml_schema::ro_string& n,
                           const ::xml_schema::ro_string* t)
      {
        XSD_UNUSED (t);

        v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
        v_state_descr_* vd = vs.data + (vs.size - 1);

        if (vd->func == 0 && vd->state == 0)
        {
          if (this->::IEC61850::SCL::Validation::tEquipmentContainer_pskel::_start_element_impl (ns, n, t))
            return true;
          else
            vd->state = 1;
        }

        while (vd->func != 0)
        {
          (this->*vd->func) (vd->state, vd->count, ns, n, t, true);

          vd = vs.data + (vs.size - 1);

          if (vd->state == ~0UL)
            vd = vs.data + (--vs.size - 1);
          else
            break;
        }

        if (vd->func == 0)
        {
          if (vd->state != ~0UL)
          {
            unsigned long s = ~0UL;

            if (n == "VoltageLevel" &&
                ns == "http://www.iec.ch/61850/2003/SCL")
              s = 0UL;

            if (s != ~0UL)
            {
              vd->count++;
              vd->state = ~0UL;

              vd = vs.data + vs.size++;
              vd->func = &tSubstation_pskel::sequence_0;
              vd->state = s;
              vd->count = 0;

              this->sequence_0 (vd->state, vd->count, ns, n, t, true);
            }
            else
            {
              if (vd->count < 1UL)
                this->_expected_element (
                  "http://www.iec.ch/61850/2003/SCL", "VoltageLevel",
                  ns, n);
              return false;
            }
          }
          else
            return false;
        }

        return true;
      }

      bool tSubstation_pskel::
      _end_element_impl (const ::xml_schema::ro_string& ns,
                         const ::xml_schema::ro_string& n)
      {
        v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
        v_state_descr_& vd = vs.data[vs.size - 1];

        if (vd.func == 0 && vd.state == 0)
        {
          if (!::IEC61850::SCL::Validation::tEquipmentContainer_pskel::_end_element_impl (ns, n))
            assert (false);
          return true;
        }

        assert (vd.func != 0);
        (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

        if (vd.state == ~0UL)
          vs.size--;

        return true;
      }

      void tSubstation_pskel::
      _pre_e_validate ()
      {
        this->v_state_stack_.push ();
        static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

        v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
        v_state_descr_& vd = vs.data[vs.size++];

        vd.func = 0;
        vd.state = 0;
        vd.count = 0;

        ::IEC61850::SCL::Validation::tEquipmentContainer_pskel::_pre_e_validate ();
      }

      void tSubstation_pskel::
      _post_e_validate ()
      {
        ::IEC61850::SCL::Validation::tEquipmentContainer_pskel::_post_e_validate ();

        v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
        v_state_descr_* vd = vs.data + (vs.size - 1);

        ::xml_schema::ro_string empty;
        while (vd->func != 0)
        {
          (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
          assert (vd->state == ~0UL);
          vd = vs.data + (--vs.size - 1);
        }

        if (vd->count < 1UL)
          this->_expected_element (
            "http://www.iec.ch/61850/2003/SCL", "VoltageLevel");

        this->v_state_stack_.pop ();
      }

      void tSubstation_pskel::
      sequence_0 (unsigned long& state,
                  unsigned long& count,
                  const ::xml_schema::ro_string& ns,
                  const ::xml_schema::ro_string& n,
                  const ::xml_schema::ro_string* t,
                  bool start)
      {
        XSD_UNUSED (t);

        switch (state)
        {
          case 0UL:
          {
            if (n == "VoltageLevel" &&
                ns == "http://www.iec.ch/61850/2003/SCL")
            {
              if (start)
              {
                this->::xml_schema::complex_content::context_.top ().parser_ = this->VoltageLevel_parser_;

                if (this->VoltageLevel_parser_)
                  this->VoltageLevel_parser_->pre ();
              }
              else
              {
                if (this->VoltageLevel_parser_)
                {
                  this->VoltageLevel_parser_->post_tVoltageLevel ();
                  this->VoltageLevel ();
                }

                count++;
              }

              break;
            }
            else
            {
              assert (start);
              if (count < 1UL)
                this->_expected_element (
                  "http://www.iec.ch/61850/2003/SCL", "VoltageLevel",
                  ns, n);
              count = 0;
              state = 1UL;
              // Fall through.
            }
          }
          case 1UL:
          {
            if (n == "Function" &&
                ns == "http://www.iec.ch/61850/2003/SCL")
            {
              if (start)
              {
                this->::xml_schema::complex_content::context_.top ().parser_ = this->Function_parser_;

                if (this->Function_parser_)
                  this->Function_parser_->pre ();
              }
              else
              {
                if (this->Function_parser_)
                {
                  this->Function_parser_->post_tFunction ();
                  this->Function ();
                }

                count++;
              }

              break;
            }
            else
            {
              assert (start);
              count = 0;
              state = ~0UL;
              // Fall through.
            }
          }
          case ~0UL:
            break;
        }
      }

      // Element validation and dispatch functions for tVoltageLevel_pskel.
      //
      bool tVoltageLevel_pskel::
      _start_element_impl (const ::xml_schema::ro_string& ns,
                           const ::xml_schema::ro_string& n,
                           const ::xml_schema::ro_string* t)
      {
        XSD_UNUSED (t);

        v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
        v_state_descr_* vd = vs.data + (vs.size - 1);

        if (vd->func == 0 && vd->state == 0)
        {
          if (this->::IEC61850::SCL::Validation::tEquipmentContainer_pskel::_start_element_impl (ns, n, t))
            return true;
          else
            vd->state = 1;
        }

        while (vd->func != 0)
        {
          (this->*vd->func) (vd->state, vd->count, ns, n, t, true);

          vd = vs.data + (vs.size - 1);

          if (vd->state == ~0UL)
            vd = vs.data + (--vs.size - 1);
          else
            break;
        }

        if (vd->func == 0)
        {
          if (vd->state != ~0UL)
          {
            unsigned long s = ~0UL;

            if (n == "Voltage" &&
                ns == "http://www.iec.ch/61850/2003/SCL")
              s = 0UL;
            else if (n == "Bay" &&
                     ns == "http://www.iec.ch/61850/2003/SCL")
              s = 1UL;

            if (s != ~0UL)
            {
              vd->count++;
              vd->state = ~0UL;

              vd = vs.data + vs.size++;
              vd->func = &tVoltageLevel_pskel::sequence_0;
              vd->state = s;
              vd->count = 0;

              this->sequence_0 (vd->state, vd->count, ns, n, t, true);
            }
            else
            {
              if (vd->count < 1UL)
                this->_expected_element (
                  "http://www.iec.ch/61850/2003/SCL", "Voltage",
                  ns, n);
              return false;
            }
          }
          else
            return false;
        }

        return true;
      }

      bool tVoltageLevel_pskel::
      _end_element_impl (const ::xml_schema::ro_string& ns,
                         const ::xml_schema::ro_string& n)
      {
        v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
        v_state_descr_& vd = vs.data[vs.size - 1];

        if (vd.func == 0 && vd.state == 0)
        {
          if (!::IEC61850::SCL::Validation::tEquipmentContainer_pskel::_end_element_impl (ns, n))
            assert (false);
          return true;
        }

        assert (vd.func != 0);
        (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

        if (vd.state == ~0UL)
          vs.size--;

        return true;
      }

      void tVoltageLevel_pskel::
      _pre_e_validate ()
      {
        this->v_state_stack_.push ();
        static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

        v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
        v_state_descr_& vd = vs.data[vs.size++];

        vd.func = 0;
        vd.state = 0;
        vd.count = 0;

        ::IEC61850::SCL::Validation::tEquipmentContainer_pskel::_pre_e_validate ();
      }

      void tVoltageLevel_pskel::
      _post_e_validate ()
      {
        ::IEC61850::SCL::Validation::tEquipmentContainer_pskel::_post_e_validate ();

        v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
        v_state_descr_* vd = vs.data + (vs.size - 1);

        ::xml_schema::ro_string empty;
        while (vd->func != 0)
        {
          (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
          assert (vd->state == ~0UL);
          vd = vs.data + (--vs.size - 1);
        }

        if (vd->count < 1UL)
          this->_expected_element (
            "http://www.iec.ch/61850/2003/SCL", "Voltage");

        this->v_state_stack_.pop ();
      }

      void tVoltageLevel_pskel::
      sequence_0 (unsigned long& state,
                  unsigned long& count,
                  const ::xml_schema::ro_string& ns,
                  const ::xml_schema::ro_string& n,
                  const ::xml_schema::ro_string* t,
                  bool start)
      {
        XSD_UNUSED (t);

        switch (state)
        {
          case 0UL:
          {
            if (n == "Voltage" &&
                ns == "http://www.iec.ch/61850/2003/SCL")
            {
              if (start)
              {
                this->::xml_schema::complex_content::context_.top ().parser_ = this->Voltage_parser_;

                if (this->Voltage_parser_)
                  this->Voltage_parser_->pre ();
              }
              else
              {
                if (this->Voltage_parser_)
                {
                  this->Voltage_parser_->post_tVoltage ();
                  this->Voltage ();
                }

                count = 0;
                state = 1UL;
              }

              break;
            }
            else
            {
              assert (start);
              count = 0;
              state = 1UL;
              // Fall through.
            }
          }
          case 1UL:
          {
            if (n == "Bay" &&
                ns == "http://www.iec.ch/61850/2003/SCL")
            {
              if (start)
              {
                this->::xml_schema::complex_content::context_.top ().parser_ = this->Bay_parser_;

                if (this->Bay_parser_)
                  this->Bay_parser_->pre ();
              }
              else
              {
                if (this->Bay_parser_)
                {
                  this->Bay_parser_->post_tBay ();
                  this->Bay ();
                }

                count++;
              }

              break;
            }
            else
            {
              assert (start);
              if (count < 1UL)
                this->_expected_element (
                  "http://www.iec.ch/61850/2003/SCL", "Bay",
                  ns, n);
              count = 0;
              state = 2UL;
              // Fall through.
            }
          }
          case 2UL:
          {
            if (n == "Function" &&
                ns == "http://www.iec.ch/61850/2003/SCL")
            {
              if (start)
              {
                this->::xml_schema::complex_content::context_.top ().parser_ = this->Function_parser_;

                if (this->Function_parser_)
                  this->Function_parser_->pre ();
              }
              else
              {
                if (this->Function_parser_)
                {
                  this->Function_parser_->post_tFunction ();
                  this->Function ();
                }

                count++;
              }

              break;
            }
            else
            {
              assert (start);
              count = 0;
              state = ~0UL;
              // Fall through.
            }
          }
          case ~0UL:
            break;
        }
      }

      // Element validation and dispatch functions for tBay_pskel.
      //
      bool tBay_pskel::
      _start_element_impl (const ::xml_schema::ro_string& ns,
                           const ::xml_schema::ro_string& n,
                           const ::xml_schema::ro_string* t)
      {
        XSD_UNUSED (t);

        v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
        v_state_descr_* vd = vs.data + (vs.size - 1);

        if (vd->func == 0 && vd->state == 0)
        {
          if (this->::IEC61850::SCL::Validation::tEquipmentContainer_pskel::_start_element_impl (ns, n, t))
            return true;
          else
            vd->state = 1;
        }

        while (vd->func != 0)
        {
          (this->*vd->func) (vd->state, vd->count, ns, n, t, true);

          vd = vs.data + (vs.size - 1);

          if (vd->state == ~0UL)
            vd = vs.data + (--vs.size - 1);
          else
            break;
        }

        if (vd->func == 0)
        {
          if (vd->state != ~0UL)
          {
            unsigned long s = ~0UL;

            if (n == "ConductingEquipment" &&
                ns == "http://www.iec.ch/61850/2003/SCL")
              s = 0UL;
            else if (n == "ConnectivityNode" &&
                     ns == "http://www.iec.ch/61850/2003/SCL")
              s = 1UL;
            else if (n == "Function" &&
                     ns == "http://www.iec.ch/61850/2003/SCL")
              s = 2UL;

            if (s != ~0UL)
            {
              vd->count++;
              vd->state = ~0UL;

              vd = vs.data + vs.size++;
              vd->func = &tBay_pskel::sequence_0;
              vd->state = s;
              vd->count = 0;

              this->sequence_0 (vd->state, vd->count, ns, n, t, true);
            }
            else
            {
              return false;
            }
          }
          else
            return false;
        }

        return true;
      }

      bool tBay_pskel::
      _end_element_impl (const ::xml_schema::ro_string& ns,
                         const ::xml_schema::ro_string& n)
      {
        v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
        v_state_descr_& vd = vs.data[vs.size - 1];

        if (vd.func == 0 && vd.state == 0)
        {
          if (!::IEC61850::SCL::Validation::tEquipmentContainer_pskel::_end_element_impl (ns, n))
            assert (false);
          return true;
        }

        assert (vd.func != 0);
        (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

        if (vd.state == ~0UL)
          vs.size--;

        return true;
      }

      void tBay_pskel::
      _pre_e_validate ()
      {
        this->v_state_stack_.push ();
        static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

        v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
        v_state_descr_& vd = vs.data[vs.size++];

        vd.func = 0;
        vd.state = 0;
        vd.count = 0;

        ::IEC61850::SCL::Validation::tEquipmentContainer_pskel::_pre_e_validate ();
      }

      void tBay_pskel::
      _post_e_validate ()
      {
        ::IEC61850::SCL::Validation::tEquipmentContainer_pskel::_post_e_validate ();

        v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
        v_state_descr_* vd = vs.data + (vs.size - 1);

        ::xml_schema::ro_string empty;
        while (vd->func != 0)
        {
          (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
          assert (vd->state == ~0UL);
          vd = vs.data + (--vs.size - 1);
        }


        this->v_state_stack_.pop ();
      }

      void tBay_pskel::
      sequence_0 (unsigned long& state,
                  unsigned long& count,
                  const ::xml_schema::ro_string& ns,
                  const ::xml_schema::ro_string& n,
                  const ::xml_schema::ro_string* t,
                  bool start)
      {
        XSD_UNUSED (t);

        switch (state)
        {
          case 0UL:
          {
            if (n == "ConductingEquipment" &&
                ns == "http://www.iec.ch/61850/2003/SCL")
            {
              if (start)
              {
                this->::xml_schema::complex_content::context_.top ().parser_ = this->ConductingEquipment_parser_;

                if (this->ConductingEquipment_parser_)
                  this->ConductingEquipment_parser_->pre ();
              }
              else
              {
                if (this->ConductingEquipment_parser_)
                {
                  this->ConductingEquipment_parser_->post_tConductingEquipment ();
                  this->ConductingEquipment ();
                }

                count++;
              }

              break;
            }
            else
            {
              assert (start);
              count = 0;
              state = 1UL;
              // Fall through.
            }
          }
          case 1UL:
          {
            if (n == "ConnectivityNode" &&
                ns == "http://www.iec.ch/61850/2003/SCL")
            {
              if (start)
              {
                this->::xml_schema::complex_content::context_.top ().parser_ = this->ConnectivityNode_parser_;

                if (this->ConnectivityNode_parser_)
                  this->ConnectivityNode_parser_->pre ();
              }
              else
              {
                if (this->ConnectivityNode_parser_)
                {
                  this->ConnectivityNode_parser_->post_tConnectivityNode ();
                  this->ConnectivityNode ();
                }

                count++;
              }

              break;
            }
            else
            {
              assert (start);
              count = 0;
              state = 2UL;
              // Fall through.
            }
          }
          case 2UL:
          {
            if (n == "Function" &&
                ns == "http://www.iec.ch/61850/2003/SCL")
            {
              if (start)
              {
                this->::xml_schema::complex_content::context_.top ().parser_ = this->Function_parser_;

                if (this->Function_parser_)
                  this->Function_parser_->pre ();
              }
              else
              {
                if (this->Function_parser_)
                {
                  this->Function_parser_->post_tFunction ();
                  this->Function ();
                }

                count++;
              }

              break;
            }
            else
            {
              assert (start);
              count = 0;
              state = ~0UL;
              // Fall through.
            }
          }
          case ~0UL:
            break;
        }
      }

      // Element validation and dispatch functions for tFunction_pskel.
      //
      bool tFunction_pskel::
      _start_element_impl (const ::xml_schema::ro_string& ns,
                           const ::xml_schema::ro_string& n,
                           const ::xml_schema::ro_string* t)
      {
        XSD_UNUSED (t);

        v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
        v_state_descr_* vd = vs.data + (vs.size - 1);

        if (vd->func == 0 && vd->state == 0)
        {
          if (this->::IEC61850::SCL::Validation::tPowerSystemResource_pskel::_start_element_impl (ns, n, t))
            return true;
          else
            vd->state = 1;
        }

        while (vd->func != 0)
        {
          (this->*vd->func) (vd->state, vd->count, ns, n, t, true);

          vd = vs.data + (vs.size - 1);

          if (vd->state == ~0UL)
            vd = vs.data + (--vs.size - 1);
          else
            break;
        }

        if (vd->func == 0)
        {
          if (vd->state != ~0UL)
          {
            unsigned long s = ~0UL;

            if (n == "SubFunction" &&
                ns == "http://www.iec.ch/61850/2003/SCL")
              s = 0UL;
            else if (n == "GeneralEquipment" &&
                     ns == "http://www.iec.ch/61850/2003/SCL")
              s = 1UL;

            if (s != ~0UL)
            {
              vd->count++;
              vd->state = ~0UL;

              vd = vs.data + vs.size++;
              vd->func = &tFunction_pskel::sequence_0;
              vd->state = s;
              vd->count = 0;

              this->sequence_0 (vd->state, vd->count, ns, n, t, true);
            }
            else
            {
              return false;
            }
          }
          else
            return false;
        }

        return true;
      }

      bool tFunction_pskel::
      _end_element_impl (const ::xml_schema::ro_string& ns,
                         const ::xml_schema::ro_string& n)
      {
        v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
        v_state_descr_& vd = vs.data[vs.size - 1];

        if (vd.func == 0 && vd.state == 0)
        {
          if (!::IEC61850::SCL::Validation::tPowerSystemResource_pskel::_end_element_impl (ns, n))
            assert (false);
          return true;
        }

        assert (vd.func != 0);
        (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

        if (vd.state == ~0UL)
          vs.size--;

        return true;
      }

      void tFunction_pskel::
      _pre_e_validate ()
      {
        this->v_state_stack_.push ();
        static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

        v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
        v_state_descr_& vd = vs.data[vs.size++];

        vd.func = 0;
        vd.state = 0;
        vd.count = 0;

        ::IEC61850::SCL::Validation::tPowerSystemResource_pskel::_pre_e_validate ();
      }

      void tFunction_pskel::
      _post_e_validate ()
      {
        ::IEC61850::SCL::Validation::tPowerSystemResource_pskel::_post_e_validate ();

        v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
        v_state_descr_* vd = vs.data + (vs.size - 1);

        ::xml_schema::ro_string empty;
        while (vd->func != 0)
        {
          (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
          assert (vd->state == ~0UL);
          vd = vs.data + (--vs.size - 1);
        }


        this->v_state_stack_.pop ();
      }

      void tFunction_pskel::
      sequence_0 (unsigned long& state,
                  unsigned long& count,
                  const ::xml_schema::ro_string& ns,
                  const ::xml_schema::ro_string& n,
                  const ::xml_schema::ro_string* t,
                  bool start)
      {
        XSD_UNUSED (t);

        switch (state)
        {
          case 0UL:
          {
            if (n == "SubFunction" &&
                ns == "http://www.iec.ch/61850/2003/SCL")
            {
              if (start)
              {
                this->::xml_schema::complex_content::context_.top ().parser_ = this->SubFunction_parser_;

                if (this->SubFunction_parser_)
                  this->SubFunction_parser_->pre ();
              }
              else
              {
                if (this->SubFunction_parser_)
                {
                  this->SubFunction_parser_->post_tSubFunction ();
                  this->SubFunction ();
                }

                count++;
              }

              break;
            }
            else
            {
              assert (start);
              count = 0;
              state = 1UL;
              // Fall through.
            }
          }
          case 1UL:
          {
            if (n == "GeneralEquipment" &&
                ns == "http://www.iec.ch/61850/2003/SCL")
            {
              if (start)
              {
                this->::xml_schema::complex_content::context_.top ().parser_ = this->GeneralEquipment_parser_;

                if (this->GeneralEquipment_parser_)
                  this->GeneralEquipment_parser_->pre ();
              }
              else
              {
                if (this->GeneralEquipment_parser_)
                {
                  this->GeneralEquipment_parser_->post_tGeneralEquipment ();
                  this->GeneralEquipment ();
                }

                count++;
              }

              break;
            }
            else
            {
              assert (start);
              count = 0;
              state = ~0UL;
              // Fall through.
            }
          }
          case ~0UL:
            break;
        }
      }

      // Element validation and dispatch functions for tSubFunction_pskel.
      //
      bool tSubFunction_pskel::
      _start_element_impl (const ::xml_schema::ro_string& ns,
                           const ::xml_schema::ro_string& n,
                           const ::xml_schema::ro_string* t)
      {
        XSD_UNUSED (t);

        v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
        v_state_descr_* vd = vs.data + (vs.size - 1);

        if (vd->func == 0 && vd->state == 0)
        {
          if (this->::IEC61850::SCL::Validation::tPowerSystemResource_pskel::_start_element_impl (ns, n, t))
            return true;
          else
            vd->state = 1;
        }

        while (vd->func != 0)
        {
          (this->*vd->func) (vd->state, vd->count, ns, n, t, true);

          vd = vs.data + (vs.size - 1);

          if (vd->state == ~0UL)
            vd = vs.data + (--vs.size - 1);
          else
            break;
        }

        if (vd->func == 0)
        {
          if (vd->state != ~0UL)
          {
            unsigned long s = ~0UL;

            if (n == "GeneralEquipment" &&
                ns == "http://www.iec.ch/61850/2003/SCL")
              s = 0UL;

            if (s != ~0UL)
            {
              vd->count++;
              vd->state = ~0UL;

              vd = vs.data + vs.size++;
              vd->func = &tSubFunction_pskel::sequence_0;
              vd->state = s;
              vd->count = 0;

              this->sequence_0 (vd->state, vd->count, ns, n, t, true);
            }
            else
            {
              return false;
            }
          }
          else
            return false;
        }

        return true;
      }

      bool tSubFunction_pskel::
      _end_element_impl (const ::xml_schema::ro_string& ns,
                         const ::xml_schema::ro_string& n)
      {
        v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
        v_state_descr_& vd = vs.data[vs.size - 1];

        if (vd.func == 0 && vd.state == 0)
        {
          if (!::IEC61850::SCL::Validation::tPowerSystemResource_pskel::_end_element_impl (ns, n))
            assert (false);
          return true;
        }

        assert (vd.func != 0);
        (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

        if (vd.state == ~0UL)
          vs.size--;

        return true;
      }

      void tSubFunction_pskel::
      _pre_e_validate ()
      {
        this->v_state_stack_.push ();
        static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

        v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
        v_state_descr_& vd = vs.data[vs.size++];

        vd.func = 0;
        vd.state = 0;
        vd.count = 0;

        ::IEC61850::SCL::Validation::tPowerSystemResource_pskel::_pre_e_validate ();
      }

      void tSubFunction_pskel::
      _post_e_validate ()
      {
        ::IEC61850::SCL::Validation::tPowerSystemResource_pskel::_post_e_validate ();

        v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
        v_state_descr_* vd = vs.data + (vs.size - 1);

        ::xml_schema::ro_string empty;
        while (vd->func != 0)
        {
          (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
          assert (vd->state == ~0UL);
          vd = vs.data + (--vs.size - 1);
        }


        this->v_state_stack_.pop ();
      }

      void tSubFunction_pskel::
      sequence_0 (unsigned long& state,
                  unsigned long& count,
                  const ::xml_schema::ro_string& ns,
                  const ::xml_schema::ro_string& n,
                  const ::xml_schema::ro_string* t,
                  bool start)
      {
        XSD_UNUSED (t);

        switch (state)
        {
          case 0UL:
          {
            if (n == "GeneralEquipment" &&
                ns == "http://www.iec.ch/61850/2003/SCL")
            {
              if (start)
              {
                this->::xml_schema::complex_content::context_.top ().parser_ = this->GeneralEquipment_parser_;

                if (this->GeneralEquipment_parser_)
                  this->GeneralEquipment_parser_->pre ();
              }
              else
              {
                if (this->GeneralEquipment_parser_)
                {
                  this->GeneralEquipment_parser_->post_tGeneralEquipment ();
                  this->GeneralEquipment ();
                }

                count++;
              }

              break;
            }
            else
            {
              assert (start);
              count = 0;
              state = ~0UL;
              // Fall through.
            }
          }
          case ~0UL:
            break;
        }
      }
    }
  }
}

namespace IEC61850
{
  namespace SCL
  {
    namespace Validation
    {
      // Attribute validation and dispatch functions for tEquipment_pskel.
      //
      bool tEquipment_pskel::
      _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
                                 const ::xml_schema::ro_string& n,
                                 const ::xml_schema::ro_string& s)
      {
        if (n == "virtual" && ns.empty ())
        {
          if (this->virtual__parser_)
          {
            this->virtual__parser_->pre ();
            this->virtual__parser_->_pre_impl ();
            this->virtual__parser_->_characters (s);
            this->virtual__parser_->_post_impl ();
            bool tmp (this->virtual__parser_->post_boolean ());
            this->virtual_ (tmp);
          }

          return true;
        }

        return this->::IEC61850::SCL::Validation::tPowerSystemResource_pskel::_attribute_impl_phase_one (ns, n, s);
      }

      // Attribute validation and dispatch functions for tConductingEquipment_pskel.
      //
      bool tConductingEquipment_pskel::
      _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
                                 const ::xml_schema::ro_string& n,
                                 const ::xml_schema::ro_string& s)
      {
        if (n == "type" && ns.empty ())
        {
          if (this->type_parser_)
          {
            this->type_parser_->pre ();
            this->type_parser_->_pre_impl ();
            this->type_parser_->_characters (s);
            this->type_parser_->_post_impl ();
            this->type_parser_->post_tCommonConductingEquipmentEnum ();
            this->type ();
          }

          static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->type = true;
          return true;
        }

        return this->::IEC61850::SCL::Validation::tAbstractConductingEquipment_pskel::_attribute_impl_phase_one (ns, n, s);
      }

      void tConductingEquipment_pskel::
      _pre_a_validate ()
      {
        this->v_state_attr_stack_.push ();
        v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());

        as.type = false;
        this->::IEC61850::SCL::Validation::tAbstractConductingEquipment_pskel::_pre_a_validate ();
      }

      void tConductingEquipment_pskel::
      _post_a_validate ()
      {
        this->::IEC61850::SCL::Validation::tAbstractConductingEquipment_pskel::_post_a_validate ();

        v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());

        if (!as.type)
          this->_expected_attribute (
            "", "type");

        this->v_state_attr_stack_.pop ();
      }

      // Attribute validation and dispatch functions for tSubEquipment_pskel.
      //
      bool tSubEquipment_pskel::
      _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
                                 const ::xml_schema::ro_string& n,
                                 const ::xml_schema::ro_string& s)
      {
        if (n == "phase" && ns.empty ())
        {
          if (this->phase_parser_)
          {
            this->phase_parser_->pre ();
            this->phase_parser_->_pre_impl ();
            this->phase_parser_->_characters (s);
            this->phase_parser_->_post_impl ();
            this->phase_parser_->post_tPhaseEnum ();
            this->phase ();
          }

          return true;
        }

        if (n == "virtual" && ns.empty ())
        {
          if (this->virtual__parser_)
          {
            this->virtual__parser_->pre ();
            this->virtual__parser_->_pre_impl ();
            this->virtual__parser_->_characters (s);
            this->virtual__parser_->_post_impl ();
            bool tmp (this->virtual__parser_->post_boolean ());
            this->virtual_ (tmp);
          }

          return true;
        }

        return this->::IEC61850::SCL::Validation::tPowerSystemResource_pskel::_attribute_impl_phase_one (ns, n, s);
      }

      // Attribute validation and dispatch functions for tPowerTransformer_pskel.
      //
      bool tPowerTransformer_pskel::
      _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
                                 const ::xml_schema::ro_string& n,
                                 const ::xml_schema::ro_string& s)
      {
        if (n == "type" && ns.empty ())
        {
          if (this->type_parser_)
          {
            this->type_parser_->pre ();
            this->type_parser_->_pre_impl ();
            this->type_parser_->_characters (s);
            this->type_parser_->_post_impl ();
            this->type_parser_->post_tPowerTransformerEnum ();
            this->type ();
          }

          static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->type = true;
          return true;
        }

        return this->::IEC61850::SCL::Validation::tEquipment_pskel::_attribute_impl_phase_one (ns, n, s);
      }

      void tPowerTransformer_pskel::
      _pre_a_validate ()
      {
        this->v_state_attr_stack_.push ();
        v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());

        as.type = false;
        this->::IEC61850::SCL::Validation::tEquipment_pskel::_pre_a_validate ();
      }

      void tPowerTransformer_pskel::
      _post_a_validate ()
      {
        this->::IEC61850::SCL::Validation::tEquipment_pskel::_post_a_validate ();

        v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());

        if (!as.type)
          this->_expected_attribute (
            "", "type");

        this->v_state_attr_stack_.pop ();
      }

      // Attribute validation and dispatch functions for tTransformerWinding_pskel.
      //
      bool tTransformerWinding_pskel::
      _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
                                 const ::xml_schema::ro_string& n,
                                 const ::xml_schema::ro_string& s)
      {
        if (n == "type" && ns.empty ())
        {
          if (this->type_parser_)
          {
            this->type_parser_->pre ();
            this->type_parser_->_pre_impl ();
            this->type_parser_->_characters (s);
            this->type_parser_->_post_impl ();
            this->type_parser_->post_tTransformerWindingEnum ();
            this->type ();
          }

          static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->type = true;
          return true;
        }

        return this->::IEC61850::SCL::Validation::tAbstractConductingEquipment_pskel::_attribute_impl_phase_one (ns, n, s);
      }

      void tTransformerWinding_pskel::
      _pre_a_validate ()
      {
        this->v_state_attr_stack_.push ();
        v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());

        as.type = false;
        this->::IEC61850::SCL::Validation::tAbstractConductingEquipment_pskel::_pre_a_validate ();
      }

      void tTransformerWinding_pskel::
      _post_a_validate ()
      {
        this->::IEC61850::SCL::Validation::tAbstractConductingEquipment_pskel::_post_a_validate ();

        v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());

        if (!as.type)
          this->_expected_attribute (
            "", "type");

        this->v_state_attr_stack_.pop ();
      }

      // Attribute validation and dispatch functions for tTapChanger_pskel.
      //
      bool tTapChanger_pskel::
      _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
                                 const ::xml_schema::ro_string& n,
                                 const ::xml_schema::ro_string& s)
      {
        if (n == "type" && ns.empty ())
        {
          if (this->type_parser_)
          {
            this->type_parser_->pre ();
            this->type_parser_->_pre_impl ();
            this->type_parser_->_characters (s);
            this->type_parser_->_post_impl ();
            const ::std::string& tmp (this->type_parser_->post_name ());
            this->type (tmp);
          }

          static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->type = true;
          return true;
        }

        if (n == "virtual" && ns.empty ())
        {
          if (this->virtual__parser_)
          {
            this->virtual__parser_->pre ();
            this->virtual__parser_->_pre_impl ();
            this->virtual__parser_->_characters (s);
            this->virtual__parser_->_post_impl ();
            bool tmp (this->virtual__parser_->post_boolean ());
            this->virtual_ (tmp);
          }

          return true;
        }

        return this->::IEC61850::SCL::Validation::tPowerSystemResource_pskel::_attribute_impl_phase_one (ns, n, s);
      }

      void tTapChanger_pskel::
      _pre_a_validate ()
      {
        this->v_state_attr_stack_.push ();
        v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());

        as.type = false;
        this->::IEC61850::SCL::Validation::tPowerSystemResource_pskel::_pre_a_validate ();
      }

      void tTapChanger_pskel::
      _post_a_validate ()
      {
        this->::IEC61850::SCL::Validation::tPowerSystemResource_pskel::_post_a_validate ();

        v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());

        if (!as.type)
          this->_expected_attribute (
            "", "type");

        this->v_state_attr_stack_.pop ();
      }

      // Attribute validation and dispatch functions for tGeneralEquipment_pskel.
      //
      bool tGeneralEquipment_pskel::
      _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
                                 const ::xml_schema::ro_string& n,
                                 const ::xml_schema::ro_string& s)
      {
        if (n == "type" && ns.empty ())
        {
          if (this->type_parser_)
          {
            this->type_parser_->pre ();
            this->type_parser_->_pre_impl ();
            this->type_parser_->_characters (s);
            this->type_parser_->_post_impl ();
            this->type_parser_->post_tGeneralEquipmentEnum ();
            this->type ();
          }

          static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->type = true;
          return true;
        }

        return this->::IEC61850::SCL::Validation::tEquipment_pskel::_attribute_impl_phase_one (ns, n, s);
      }

      void tGeneralEquipment_pskel::
      _pre_a_validate ()
      {
        this->v_state_attr_stack_.push ();
        v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());

        as.type = false;
        this->::IEC61850::SCL::Validation::tEquipment_pskel::_pre_a_validate ();
      }

      void tGeneralEquipment_pskel::
      _post_a_validate ()
      {
        this->::IEC61850::SCL::Validation::tEquipment_pskel::_post_a_validate ();

        v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());

        if (!as.type)
          this->_expected_attribute (
            "", "type");

        this->v_state_attr_stack_.pop ();
      }

      // Attribute validation and dispatch functions for tLNode_pskel.
      //
      bool tLNode_pskel::
      _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
                                 const ::xml_schema::ro_string& n,
                                 const ::xml_schema::ro_string& s)
      {
        if (n == "lnInst" && ns.empty ())
        {
          if (this->lnInst_parser_)
          {
            this->lnInst_parser_->pre ();
            this->lnInst_parser_->_pre_impl ();
            this->lnInst_parser_->_characters (s);
            this->lnInst_parser_->_post_impl ();
            this->lnInst_parser_->post_tAnyName ();
            this->lnInst ();
          }

          return true;
        }

        if (n == "lnClass" && ns.empty ())
        {
          if (this->lnClass_parser_)
          {
            this->lnClass_parser_->pre ();
            this->lnClass_parser_->_pre_impl ();
            this->lnClass_parser_->_characters (s);
            this->lnClass_parser_->_post_impl ();
            this->lnClass_parser_->post_tLNClassEnum ();
            this->lnClass ();
          }

          static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->lnClass = true;
          return true;
        }

        if (n == "iedName" && ns.empty ())
        {
          if (this->iedName_parser_)
          {
            this->iedName_parser_->pre ();
            this->iedName_parser_->_pre_impl ();
            this->iedName_parser_->_characters (s);
            this->iedName_parser_->_post_impl ();
            this->iedName_parser_->post_tName ();
            this->iedName ();
          }

          return true;
        }

        if (n == "ldInst" && ns.empty ())
        {
          if (this->ldInst_parser_)
          {
            this->ldInst_parser_->pre ();
            this->ldInst_parser_->_pre_impl ();
            this->ldInst_parser_->_characters (s);
            this->ldInst_parser_->_post_impl ();
            this->ldInst_parser_->post_tAnyName ();
            this->ldInst ();
          }

          return true;
        }

        if (n == "prefix" && ns.empty ())
        {
          if (this->prefix_parser_)
          {
            this->prefix_parser_->pre ();
            this->prefix_parser_->_pre_impl ();
            this->prefix_parser_->_characters (s);
            this->prefix_parser_->_post_impl ();
            this->prefix_parser_->post_tAnyName ();
            this->prefix ();
          }

          return true;
        }

        if (n == "lnType" && ns.empty ())
        {
          if (this->lnType_parser_)
          {
            this->lnType_parser_->pre ();
            this->lnType_parser_->_pre_impl ();
            this->lnType_parser_->_characters (s);
            this->lnType_parser_->_post_impl ();
            this->lnType_parser_->post_tName ();
            this->lnType ();
          }

          return true;
        }

        return this->::IEC61850::SCL::Validation::tUnNaming_pskel::_attribute_impl_phase_one (ns, n, s);
      }

      void tLNode_pskel::
      _pre_a_validate ()
      {
        this->v_state_attr_stack_.push ();
        v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());

        as.lnClass = false;
        this->::IEC61850::SCL::Validation::tUnNaming_pskel::_pre_a_validate ();
      }

      void tLNode_pskel::
      _post_a_validate ()
      {
        this->::IEC61850::SCL::Validation::tUnNaming_pskel::_post_a_validate ();

        v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());

        if (!as.lnClass)
          this->_expected_attribute (
            "", "lnClass");

        this->v_state_attr_stack_.pop ();
      }

      // Attribute validation and dispatch functions for tConnectivityNode_pskel.
      //
      bool tConnectivityNode_pskel::
      _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
                                 const ::xml_schema::ro_string& n,
                                 const ::xml_schema::ro_string& s)
      {
        if (n == "pathName" && ns.empty ())
        {
          if (this->pathName_parser_)
          {
            this->pathName_parser_->pre ();
            this->pathName_parser_->_pre_impl ();
            this->pathName_parser_->_characters (s);
            this->pathName_parser_->_post_impl ();
            this->pathName_parser_->post_tRef ();
            this->pathName ();
          }

          static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->pathName = true;
          return true;
        }

        return this->::IEC61850::SCL::Validation::tLNodeContainer_pskel::_attribute_impl_phase_one (ns, n, s);
      }

      void tConnectivityNode_pskel::
      _pre_a_validate ()
      {
        this->v_state_attr_stack_.push ();
        v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());

        as.pathName = false;
        this->::IEC61850::SCL::Validation::tLNodeContainer_pskel::_pre_a_validate ();
      }

      void tConnectivityNode_pskel::
      _post_a_validate ()
      {
        this->::IEC61850::SCL::Validation::tLNodeContainer_pskel::_post_a_validate ();

        v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());

        if (!as.pathName)
          this->_expected_attribute (
            "", "pathName");

        this->v_state_attr_stack_.pop ();
      }

      // Attribute validation and dispatch functions for tTerminal_pskel.
      //
      bool tTerminal_pskel::
      _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
                                 const ::xml_schema::ro_string& n,
                                 const ::xml_schema::ro_string& s)
      {
        if (n == "name" && ns.empty ())
        {
          if (this->name_parser_)
          {
            this->name_parser_->pre ();
            this->name_parser_->_pre_impl ();
            this->name_parser_->_characters (s);
            this->name_parser_->_post_impl ();
            this->name_parser_->post_tAnyName ();
            this->name ();
          }

          return true;
        }

        if (n == "connectivityNode" && ns.empty ())
        {
          if (this->connectivityNode_parser_)
          {
            this->connectivityNode_parser_->pre ();
            this->connectivityNode_parser_->_pre_impl ();
            this->connectivityNode_parser_->_characters (s);
            this->connectivityNode_parser_->_post_impl ();
            this->connectivityNode_parser_->post_tRef ();
            this->connectivityNode ();
          }

          static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->connectivityNode = true;
          return true;
        }

        if (n == "substationName" && ns.empty ())
        {
          if (this->substationName_parser_)
          {
            this->substationName_parser_->pre ();
            this->substationName_parser_->_pre_impl ();
            this->substationName_parser_->_characters (s);
            this->substationName_parser_->_post_impl ();
            this->substationName_parser_->post_tName ();
            this->substationName ();
          }

          static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->substationName = true;
          return true;
        }

        if (n == "voltageLevelName" && ns.empty ())
        {
          if (this->voltageLevelName_parser_)
          {
            this->voltageLevelName_parser_->pre ();
            this->voltageLevelName_parser_->_pre_impl ();
            this->voltageLevelName_parser_->_characters (s);
            this->voltageLevelName_parser_->_post_impl ();
            this->voltageLevelName_parser_->post_tName ();
            this->voltageLevelName ();
          }

          static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->voltageLevelName = true;
          return true;
        }

        if (n == "bayName" && ns.empty ())
        {
          if (this->bayName_parser_)
          {
            this->bayName_parser_->pre ();
            this->bayName_parser_->_pre_impl ();
            this->bayName_parser_->_characters (s);
            this->bayName_parser_->_post_impl ();
            this->bayName_parser_->post_tName ();
            this->bayName ();
          }

          static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->bayName = true;
          return true;
        }

        if (n == "cNodeName" && ns.empty ())
        {
          if (this->cNodeName_parser_)
          {
            this->cNodeName_parser_->pre ();
            this->cNodeName_parser_->_pre_impl ();
            this->cNodeName_parser_->_characters (s);
            this->cNodeName_parser_->_post_impl ();
            this->cNodeName_parser_->post_tName ();
            this->cNodeName ();
          }

          static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->cNodeName = true;
          return true;
        }

        return this->::IEC61850::SCL::Validation::tUnNaming_pskel::_attribute_impl_phase_one (ns, n, s);
      }

      void tTerminal_pskel::
      _pre_a_validate ()
      {
        this->v_state_attr_stack_.push ();
        v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());

        as.connectivityNode = false;
        as.substationName = false;
        as.voltageLevelName = false;
        as.bayName = false;
        as.cNodeName = false;
        this->::IEC61850::SCL::Validation::tUnNaming_pskel::_pre_a_validate ();
      }

      void tTerminal_pskel::
      _post_a_validate ()
      {
        this->::IEC61850::SCL::Validation::tUnNaming_pskel::_post_a_validate ();

        v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());

        if (!as.connectivityNode)
          this->_expected_attribute (
            "", "connectivityNode");
        if (!as.substationName)
          this->_expected_attribute (
            "", "substationName");
        if (!as.voltageLevelName)
          this->_expected_attribute (
            "", "voltageLevelName");
        if (!as.bayName)
          this->_expected_attribute (
            "", "bayName");
        if (!as.cNodeName)
          this->_expected_attribute (
            "", "cNodeName");

        this->v_state_attr_stack_.pop ();
      }
    }
  }
}

namespace IEC61850
{
  namespace SCL
  {
    namespace Validation
    {
    }
  }
}

// Begin epilogue.
//
//
// End epilogue.

