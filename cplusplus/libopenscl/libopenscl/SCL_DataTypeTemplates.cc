// Copyright (C) 2005-2008 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "SCL_DataTypeTemplates.h"

namespace IEC61850
{
  namespace SCL
  {
    // tAbstractDataAttribute
    // 

    const tAbstractDataAttribute::Val_sequence& tAbstractDataAttribute::
    Val () const
    {
      return this->Val_;
    }

    tAbstractDataAttribute::Val_sequence& tAbstractDataAttribute::
    Val ()
    {
      return this->Val_;
    }

    void tAbstractDataAttribute::
    Val (const Val_sequence& s)
    {
      this->Val_ = s;
    }

    const tAbstractDataAttribute::name_type& tAbstractDataAttribute::
    name () const
    {
      return this->name_.get ();
    }

    tAbstractDataAttribute::name_type& tAbstractDataAttribute::
    name ()
    {
      return this->name_.get ();
    }

    void tAbstractDataAttribute::
    name (const name_type& x)
    {
      this->name_.set (x);
    }

    void tAbstractDataAttribute::
    name (::std::auto_ptr< name_type > x)
    {
      this->name_.set (x);
    }

    const tAbstractDataAttribute::sAddr_optional& tAbstractDataAttribute::
    sAddr () const
    {
      return this->sAddr_;
    }

    tAbstractDataAttribute::sAddr_optional& tAbstractDataAttribute::
    sAddr ()
    {
      return this->sAddr_;
    }

    void tAbstractDataAttribute::
    sAddr (const sAddr_type& x)
    {
      this->sAddr_.set (x);
    }

    void tAbstractDataAttribute::
    sAddr (const sAddr_optional& x)
    {
      this->sAddr_ = x;
    }

    void tAbstractDataAttribute::
    sAddr (::std::auto_ptr< sAddr_type > x)
    {
      this->sAddr_.set (x);
    }

    const tAbstractDataAttribute::bType_type& tAbstractDataAttribute::
    bType () const
    {
      return this->bType_.get ();
    }

    tAbstractDataAttribute::bType_type& tAbstractDataAttribute::
    bType ()
    {
      return this->bType_.get ();
    }

    void tAbstractDataAttribute::
    bType (const bType_type& x)
    {
      this->bType_.set (x);
    }

    void tAbstractDataAttribute::
    bType (::std::auto_ptr< bType_type > x)
    {
      this->bType_.set (x);
    }

    const tAbstractDataAttribute::valKind_type& tAbstractDataAttribute::
    valKind () const
    {
      return this->valKind_.get ();
    }

    tAbstractDataAttribute::valKind_type& tAbstractDataAttribute::
    valKind ()
    {
      return this->valKind_.get ();
    }

    void tAbstractDataAttribute::
    valKind (const valKind_type& x)
    {
      this->valKind_.set (x);
    }

    void tAbstractDataAttribute::
    valKind (::std::auto_ptr< valKind_type > x)
    {
      this->valKind_.set (x);
    }

    const tAbstractDataAttribute::valKind_type& tAbstractDataAttribute::
    valKind_default_value ()
    {
      return valKind_default_value_;
    }

    const tAbstractDataAttribute::type_optional& tAbstractDataAttribute::
    type () const
    {
      return this->type_;
    }

    tAbstractDataAttribute::type_optional& tAbstractDataAttribute::
    type ()
    {
      return this->type_;
    }

    void tAbstractDataAttribute::
    type (const type_type& x)
    {
      this->type_.set (x);
    }

    void tAbstractDataAttribute::
    type (const type_optional& x)
    {
      this->type_ = x;
    }

    void tAbstractDataAttribute::
    type (::std::auto_ptr< type_type > x)
    {
      this->type_.set (x);
    }

    const tAbstractDataAttribute::count_type& tAbstractDataAttribute::
    count () const
    {
      return this->count_.get ();
    }

    tAbstractDataAttribute::count_type& tAbstractDataAttribute::
    count ()
    {
      return this->count_.get ();
    }

    void tAbstractDataAttribute::
    count (const count_type& x)
    {
      this->count_.set (x);
    }

    const tAbstractDataAttribute::count_type& tAbstractDataAttribute::
    count_default_value ()
    {
      return count_default_value_;
    }


    // tLNodeType
    // 

    const tLNodeType::DO_sequence& tLNodeType::
    DO () const
    {
      return this->DO_;
    }

    tLNodeType::DO_sequence& tLNodeType::
    DO ()
    {
      return this->DO_;
    }

    void tLNodeType::
    DO (const DO_sequence& s)
    {
      this->DO_ = s;
    }

    const tLNodeType::iedType_optional& tLNodeType::
    iedType () const
    {
      return this->iedType_;
    }

    tLNodeType::iedType_optional& tLNodeType::
    iedType ()
    {
      return this->iedType_;
    }

    void tLNodeType::
    iedType (const iedType_type& x)
    {
      this->iedType_.set (x);
    }

    void tLNodeType::
    iedType (const iedType_optional& x)
    {
      this->iedType_ = x;
    }

    void tLNodeType::
    iedType (::std::auto_ptr< iedType_type > x)
    {
      this->iedType_.set (x);
    }

    const tLNodeType::lnClass_type& tLNodeType::
    lnClass () const
    {
      return this->lnClass_.get ();
    }

    tLNodeType::lnClass_type& tLNodeType::
    lnClass ()
    {
      return this->lnClass_.get ();
    }

    void tLNodeType::
    lnClass (const lnClass_type& x)
    {
      this->lnClass_.set (x);
    }

    void tLNodeType::
    lnClass (::std::auto_ptr< lnClass_type > x)
    {
      this->lnClass_.set (x);
    }


    // tDO
    // 

    const tDO::name_type& tDO::
    name () const
    {
      return this->name_.get ();
    }

    tDO::name_type& tDO::
    name ()
    {
      return this->name_.get ();
    }

    void tDO::
    name (const name_type& x)
    {
      this->name_.set (x);
    }

    void tDO::
    name (::std::auto_ptr< name_type > x)
    {
      this->name_.set (x);
    }

    const tDO::type_type& tDO::
    type () const
    {
      return this->type_.get ();
    }

    tDO::type_type& tDO::
    type ()
    {
      return this->type_.get ();
    }

    void tDO::
    type (const type_type& x)
    {
      this->type_.set (x);
    }

    void tDO::
    type (::std::auto_ptr< type_type > x)
    {
      this->type_.set (x);
    }

    const tDO::accessControl_optional& tDO::
    accessControl () const
    {
      return this->accessControl_;
    }

    tDO::accessControl_optional& tDO::
    accessControl ()
    {
      return this->accessControl_;
    }

    void tDO::
    accessControl (const accessControl_type& x)
    {
      this->accessControl_.set (x);
    }

    void tDO::
    accessControl (const accessControl_optional& x)
    {
      this->accessControl_ = x;
    }

    void tDO::
    accessControl (::std::auto_ptr< accessControl_type > x)
    {
      this->accessControl_.set (x);
    }

    const tDO::transient_type& tDO::
    transient () const
    {
      return this->transient_.get ();
    }

    tDO::transient_type& tDO::
    transient ()
    {
      return this->transient_.get ();
    }

    void tDO::
    transient (const transient_type& x)
    {
      this->transient_.set (x);
    }

    const tDO::transient_type& tDO::
    transient_default_value ()
    {
      return transient_default_value_;
    }


    // tDOType
    // 

    const tDOType::SDO_sequence& tDOType::
    SDO () const
    {
      return this->SDO_;
    }

    tDOType::SDO_sequence& tDOType::
    SDO ()
    {
      return this->SDO_;
    }

    void tDOType::
    SDO (const SDO_sequence& s)
    {
      this->SDO_ = s;
    }

    const tDOType::DA_sequence& tDOType::
    DA () const
    {
      return this->DA_;
    }

    tDOType::DA_sequence& tDOType::
    DA ()
    {
      return this->DA_;
    }

    void tDOType::
    DA (const DA_sequence& s)
    {
      this->DA_ = s;
    }

    const tDOType::iedType_optional& tDOType::
    iedType () const
    {
      return this->iedType_;
    }

    tDOType::iedType_optional& tDOType::
    iedType ()
    {
      return this->iedType_;
    }

    void tDOType::
    iedType (const iedType_type& x)
    {
      this->iedType_.set (x);
    }

    void tDOType::
    iedType (const iedType_optional& x)
    {
      this->iedType_ = x;
    }

    void tDOType::
    iedType (::std::auto_ptr< iedType_type > x)
    {
      this->iedType_.set (x);
    }

    const tDOType::cdc_type& tDOType::
    cdc () const
    {
      return this->cdc_.get ();
    }

    tDOType::cdc_type& tDOType::
    cdc ()
    {
      return this->cdc_.get ();
    }

    void tDOType::
    cdc (const cdc_type& x)
    {
      this->cdc_.set (x);
    }

    void tDOType::
    cdc (::std::auto_ptr< cdc_type > x)
    {
      this->cdc_.set (x);
    }


    // tSDO
    // 

    const tSDO::type_type& tSDO::
    type () const
    {
      return this->type_.get ();
    }

    tSDO::type_type& tSDO::
    type ()
    {
      return this->type_.get ();
    }

    void tSDO::
    type (const type_type& x)
    {
      this->type_.set (x);
    }

    void tSDO::
    type (::std::auto_ptr< type_type > x)
    {
      this->type_.set (x);
    }


    // tDA
    // 

    const tDA::dchg_type& tDA::
    dchg () const
    {
      return this->dchg_.get ();
    }

    tDA::dchg_type& tDA::
    dchg ()
    {
      return this->dchg_.get ();
    }

    void tDA::
    dchg (const dchg_type& x)
    {
      this->dchg_.set (x);
    }

    const tDA::dchg_type& tDA::
    dchg_default_value ()
    {
      return dchg_default_value_;
    }

    const tDA::qchg_type& tDA::
    qchg () const
    {
      return this->qchg_.get ();
    }

    tDA::qchg_type& tDA::
    qchg ()
    {
      return this->qchg_.get ();
    }

    void tDA::
    qchg (const qchg_type& x)
    {
      this->qchg_.set (x);
    }

    const tDA::qchg_type& tDA::
    qchg_default_value ()
    {
      return qchg_default_value_;
    }

    const tDA::dupd_type& tDA::
    dupd () const
    {
      return this->dupd_.get ();
    }

    tDA::dupd_type& tDA::
    dupd ()
    {
      return this->dupd_.get ();
    }

    void tDA::
    dupd (const dupd_type& x)
    {
      this->dupd_.set (x);
    }

    const tDA::dupd_type& tDA::
    dupd_default_value ()
    {
      return dupd_default_value_;
    }

    const tDA::fc_type& tDA::
    fc () const
    {
      return this->fc_.get ();
    }

    tDA::fc_type& tDA::
    fc ()
    {
      return this->fc_.get ();
    }

    void tDA::
    fc (const fc_type& x)
    {
      this->fc_.set (x);
    }

    void tDA::
    fc (::std::auto_ptr< fc_type > x)
    {
      this->fc_.set (x);
    }


    // tDAType
    // 

    const tDAType::BDA_sequence& tDAType::
    BDA () const
    {
      return this->BDA_;
    }

    tDAType::BDA_sequence& tDAType::
    BDA ()
    {
      return this->BDA_;
    }

    void tDAType::
    BDA (const BDA_sequence& s)
    {
      this->BDA_ = s;
    }

    const tDAType::iedType_optional& tDAType::
    iedType () const
    {
      return this->iedType_;
    }

    tDAType::iedType_optional& tDAType::
    iedType ()
    {
      return this->iedType_;
    }

    void tDAType::
    iedType (const iedType_type& x)
    {
      this->iedType_.set (x);
    }

    void tDAType::
    iedType (const iedType_optional& x)
    {
      this->iedType_ = x;
    }

    void tDAType::
    iedType (::std::auto_ptr< iedType_type > x)
    {
      this->iedType_.set (x);
    }


    // tBDA
    // 


    // tEnumType
    // 

    const tEnumType::EnumVal_sequence& tEnumType::
    EnumVal () const
    {
      return this->EnumVal_;
    }

    tEnumType::EnumVal_sequence& tEnumType::
    EnumVal ()
    {
      return this->EnumVal_;
    }

    void tEnumType::
    EnumVal (const EnumVal_sequence& s)
    {
      this->EnumVal_ = s;
    }


    // tEnumVal
    // 

    const tEnumVal::ord_type& tEnumVal::
    ord () const
    {
      return this->ord_.get ();
    }

    tEnumVal::ord_type& tEnumVal::
    ord ()
    {
      return this->ord_.get ();
    }

    void tEnumVal::
    ord (const ord_type& x)
    {
      this->ord_.set (x);
    }


    // tDataTypeTemplates
    // 

    const tDataTypeTemplates::LNodeType_sequence& tDataTypeTemplates::
    LNodeType () const
    {
      return this->LNodeType_;
    }

    tDataTypeTemplates::LNodeType_sequence& tDataTypeTemplates::
    LNodeType ()
    {
      return this->LNodeType_;
    }

    void tDataTypeTemplates::
    LNodeType (const LNodeType_sequence& s)
    {
      this->LNodeType_ = s;
    }

    const tDataTypeTemplates::DOType_sequence& tDataTypeTemplates::
    DOType () const
    {
      return this->DOType_;
    }

    tDataTypeTemplates::DOType_sequence& tDataTypeTemplates::
    DOType ()
    {
      return this->DOType_;
    }

    void tDataTypeTemplates::
    DOType (const DOType_sequence& s)
    {
      this->DOType_ = s;
    }

    const tDataTypeTemplates::DAType_sequence& tDataTypeTemplates::
    DAType () const
    {
      return this->DAType_;
    }

    tDataTypeTemplates::DAType_sequence& tDataTypeTemplates::
    DAType ()
    {
      return this->DAType_;
    }

    void tDataTypeTemplates::
    DAType (const DAType_sequence& s)
    {
      this->DAType_ = s;
    }

    const tDataTypeTemplates::EnumType_sequence& tDataTypeTemplates::
    EnumType () const
    {
      return this->EnumType_;
    }

    tDataTypeTemplates::EnumType_sequence& tDataTypeTemplates::
    EnumType ()
    {
      return this->EnumType_;
    }

    void tDataTypeTemplates::
    EnumType (const EnumType_sequence& s)
    {
      this->EnumType_ = s;
    }
  }
}

#include <xsd/cxx/xml/dom/parsing-source.hxx>

namespace IEC61850
{
  namespace SCL
  {
    // tAbstractDataAttribute
    //

    const tAbstractDataAttribute::valKind_type tAbstractDataAttribute::valKind_default_value_ (
      ::std::string ("Set"), 0, 0, 0);

    const tAbstractDataAttribute::count_type tAbstractDataAttribute::count_default_value_ (
      ::xsd::cxx::tree::traits< ::xml_schema::unsigned_int, char >::create (
        ::std::string ("0"), 0, 0, 0));

    tAbstractDataAttribute::
    tAbstractDataAttribute (const name_type& name,
                            const bType_type& bType)
    : ::IEC61850::SCL::tUnNaming (),
      Val_ (::xml_schema::flags (), this),
      name_ (name, ::xml_schema::flags (), this),
      sAddr_ (::xml_schema::flags (), this),
      bType_ (bType, ::xml_schema::flags (), this),
      valKind_ (valKind_default_value (), ::xml_schema::flags (), this),
      type_ (::xml_schema::flags (), this),
      count_ (count_default_value (), ::xml_schema::flags (), this)
    {
    }

    tAbstractDataAttribute::
    tAbstractDataAttribute (const tAbstractDataAttribute& x,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::IEC61850::SCL::tUnNaming (x, f, c),
      Val_ (x.Val_, f, this),
      name_ (x.name_, f, this),
      sAddr_ (x.sAddr_, f, this),
      bType_ (x.bType_, f, this),
      valKind_ (x.valKind_, f, this),
      type_ (x.type_, f, this),
      count_ (x.count_, f, this)
    {
    }

    tAbstractDataAttribute::
    tAbstractDataAttribute (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::IEC61850::SCL::tUnNaming (e, f | ::xml_schema::flags::base, c),
      Val_ (f, this),
      name_ (f, this),
      sAddr_ (f, this),
      bType_ (f, this),
      valKind_ (f, this),
      type_ (f, this),
      count_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void tAbstractDataAttribute::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::IEC61850::SCL::tUnNaming::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Val
        //
        if (n.name () == "Val" && n.namespace_ () == "http://www.iec.ch/61850/2003/SCL")
        {
          ::std::auto_ptr< Val_type > r (
            Val_traits::create (i, f, this));

          this->Val_.push_back (r);
          continue;
        }

        break;
      }

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "name" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< name_type > r (
            name_traits::create (i, f, this));

          this->name_.set (r);
          continue;
        }

        if (n.name () == "sAddr" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< sAddr_type > r (
            sAddr_traits::create (i, f, this));

          this->sAddr_.set (r);
          continue;
        }

        if (n.name () == "bType" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< bType_type > r (
            bType_traits::create (i, f, this));

          this->bType_.set (r);
          continue;
        }

        if (n.name () == "valKind" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< valKind_type > r (
            valKind_traits::create (i, f, this));

          this->valKind_.set (r);
          continue;
        }

        if (n.name () == "type" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< type_type > r (
            type_traits::create (i, f, this));

          this->type_.set (r);
          continue;
        }

        if (n.name () == "count" && n.namespace_ ().empty ())
        {
          this->count_.set (count_traits::create (i, f, this));
          continue;
        }
      }

      if (!name_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "name",
          "");
      }

      if (!bType_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "bType",
          "");
      }

      if (!valKind_.present ())
      {
        this->valKind_.set (valKind_default_value ());
      }

      if (!count_.present ())
      {
        this->count_.set (count_default_value ());
      }
    }

    tAbstractDataAttribute* tAbstractDataAttribute::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class tAbstractDataAttribute (*this, f, c);
    }

    tAbstractDataAttribute::
    ~tAbstractDataAttribute ()
    {
    }

    // tLNodeType
    //

    tLNodeType::
    tLNodeType (const id_type& id,
                const lnClass_type& lnClass)
    : ::IEC61850::SCL::tIDNaming (id),
      DO_ (::xml_schema::flags (), this),
      iedType_ (::xml_schema::flags (), this),
      lnClass_ (lnClass, ::xml_schema::flags (), this)
    {
    }

    tLNodeType::
    tLNodeType (const tLNodeType& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
    : ::IEC61850::SCL::tIDNaming (x, f, c),
      DO_ (x.DO_, f, this),
      iedType_ (x.iedType_, f, this),
      lnClass_ (x.lnClass_, f, this)
    {
    }

    tLNodeType::
    tLNodeType (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
    : ::IEC61850::SCL::tIDNaming (e, f | ::xml_schema::flags::base, c),
      DO_ (f, this),
      iedType_ (f, this),
      lnClass_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void tLNodeType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::IEC61850::SCL::tIDNaming::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // DO
        //
        if (n.name () == "DO" && n.namespace_ () == "http://www.iec.ch/61850/2003/SCL")
        {
          ::std::auto_ptr< DO_type > r (
            DO_traits::create (i, f, this));

          this->DO_.push_back (r);
          continue;
        }

        break;
      }

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "iedType" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< iedType_type > r (
            iedType_traits::create (i, f, this));

          this->iedType_.set (r);
          continue;
        }

        if (n.name () == "lnClass" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< lnClass_type > r (
            lnClass_traits::create (i, f, this));

          this->lnClass_.set (r);
          continue;
        }
      }

      if (!lnClass_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "lnClass",
          "");
      }
    }

    tLNodeType* tLNodeType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class tLNodeType (*this, f, c);
    }

    tLNodeType::
    ~tLNodeType ()
    {
    }

    // tDO
    //

    const tDO::transient_type tDO::transient_default_value_ (
      ::xsd::cxx::tree::traits< ::xml_schema::boolean, char >::create (
        ::std::string ("false"), 0, 0, 0));

    tDO::
    tDO (const name_type& name,
         const type_type& type)
    : ::IEC61850::SCL::tUnNaming (),
      name_ (name, ::xml_schema::flags (), this),
      type_ (type, ::xml_schema::flags (), this),
      accessControl_ (::xml_schema::flags (), this),
      transient_ (transient_default_value (), ::xml_schema::flags (), this)
    {
    }

    tDO::
    tDO (const tDO& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
    : ::IEC61850::SCL::tUnNaming (x, f, c),
      name_ (x.name_, f, this),
      type_ (x.type_, f, this),
      accessControl_ (x.accessControl_, f, this),
      transient_ (x.transient_, f, this)
    {
    }

    tDO::
    tDO (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
    : ::IEC61850::SCL::tUnNaming (e, f | ::xml_schema::flags::base, c),
      name_ (f, this),
      type_ (f, this),
      accessControl_ (f, this),
      transient_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void tDO::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::IEC61850::SCL::tUnNaming::parse (p, f);

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "name" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< name_type > r (
            name_traits::create (i, f, this));

          this->name_.set (r);
          continue;
        }

        if (n.name () == "type" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< type_type > r (
            type_traits::create (i, f, this));

          this->type_.set (r);
          continue;
        }

        if (n.name () == "accessControl" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< accessControl_type > r (
            accessControl_traits::create (i, f, this));

          this->accessControl_.set (r);
          continue;
        }

        if (n.name () == "transient" && n.namespace_ ().empty ())
        {
          this->transient_.set (transient_traits::create (i, f, this));
          continue;
        }
      }

      if (!name_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "name",
          "");
      }

      if (!type_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "type",
          "");
      }

      if (!transient_.present ())
      {
        this->transient_.set (transient_default_value ());
      }
    }

    tDO* tDO::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class tDO (*this, f, c);
    }

    tDO::
    ~tDO ()
    {
    }

    // tDOType
    //

    tDOType::
    tDOType (const id_type& id,
             const cdc_type& cdc)
    : ::IEC61850::SCL::tIDNaming (id),
      SDO_ (::xml_schema::flags (), this),
      DA_ (::xml_schema::flags (), this),
      iedType_ (::xml_schema::flags (), this),
      cdc_ (cdc, ::xml_schema::flags (), this)
    {
    }

    tDOType::
    tDOType (const tDOType& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
    : ::IEC61850::SCL::tIDNaming (x, f, c),
      SDO_ (x.SDO_, f, this),
      DA_ (x.DA_, f, this),
      iedType_ (x.iedType_, f, this),
      cdc_ (x.cdc_, f, this)
    {
    }

    tDOType::
    tDOType (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
    : ::IEC61850::SCL::tIDNaming (e, f | ::xml_schema::flags::base, c),
      SDO_ (f, this),
      DA_ (f, this),
      iedType_ (f, this),
      cdc_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void tDOType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::IEC61850::SCL::tIDNaming::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // SDO
        //
        if (n.name () == "SDO" && n.namespace_ () == "http://www.iec.ch/61850/2003/SCL")
        {
          ::std::auto_ptr< SDO_type > r (
            SDO_traits::create (i, f, this));

          this->SDO_.push_back (r);
          continue;
        }

        // DA
        //
        if (n.name () == "DA" && n.namespace_ () == "http://www.iec.ch/61850/2003/SCL")
        {
          ::std::auto_ptr< DA_type > r (
            DA_traits::create (i, f, this));

          this->DA_.push_back (r);
          continue;
        }

        break;
      }

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "iedType" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< iedType_type > r (
            iedType_traits::create (i, f, this));

          this->iedType_.set (r);
          continue;
        }

        if (n.name () == "cdc" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< cdc_type > r (
            cdc_traits::create (i, f, this));

          this->cdc_.set (r);
          continue;
        }
      }

      if (!cdc_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "cdc",
          "");
      }
    }

    tDOType* tDOType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class tDOType (*this, f, c);
    }

    tDOType::
    ~tDOType ()
    {
    }

    // tSDO
    //

    tSDO::
    tSDO (const name_type& name,
          const type_type& type)
    : ::IEC61850::SCL::tNaming (name),
      type_ (type, ::xml_schema::flags (), this)
    {
    }

    tSDO::
    tSDO (const tSDO& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
    : ::IEC61850::SCL::tNaming (x, f, c),
      type_ (x.type_, f, this)
    {
    }

    tSDO::
    tSDO (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
    : ::IEC61850::SCL::tNaming (e, f | ::xml_schema::flags::base, c),
      type_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void tSDO::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::IEC61850::SCL::tNaming::parse (p, f);

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "type" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< type_type > r (
            type_traits::create (i, f, this));

          this->type_.set (r);
          continue;
        }
      }

      if (!type_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "type",
          "");
      }
    }

    tSDO* tSDO::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class tSDO (*this, f, c);
    }

    tSDO::
    ~tSDO ()
    {
    }

    // tDA
    //

    const tDA::dchg_type tDA::dchg_default_value_ (
      ::xsd::cxx::tree::traits< ::xml_schema::boolean, char >::create (
        ::std::string ("false"), 0, 0, 0));

    const tDA::qchg_type tDA::qchg_default_value_ (
      ::xsd::cxx::tree::traits< ::xml_schema::boolean, char >::create (
        ::std::string ("false"), 0, 0, 0));

    const tDA::dupd_type tDA::dupd_default_value_ (
      ::xsd::cxx::tree::traits< ::xml_schema::boolean, char >::create (
        ::std::string ("false"), 0, 0, 0));

    tDA::
    tDA (const name_type& name,
         const bType_type& bType,
         const fc_type& fc)
    : ::IEC61850::SCL::tAbstractDataAttribute (name,
                                               bType),
      dchg_ (dchg_default_value (), ::xml_schema::flags (), this),
      qchg_ (qchg_default_value (), ::xml_schema::flags (), this),
      dupd_ (dupd_default_value (), ::xml_schema::flags (), this),
      fc_ (fc, ::xml_schema::flags (), this)
    {
    }

    tDA::
    tDA (const tDA& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
    : ::IEC61850::SCL::tAbstractDataAttribute (x, f, c),
      dchg_ (x.dchg_, f, this),
      qchg_ (x.qchg_, f, this),
      dupd_ (x.dupd_, f, this),
      fc_ (x.fc_, f, this)
    {
    }

    tDA::
    tDA (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
    : ::IEC61850::SCL::tAbstractDataAttribute (e, f | ::xml_schema::flags::base, c),
      dchg_ (f, this),
      qchg_ (f, this),
      dupd_ (f, this),
      fc_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void tDA::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::IEC61850::SCL::tAbstractDataAttribute::parse (p, f);

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "dchg" && n.namespace_ ().empty ())
        {
          this->dchg_.set (dchg_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "qchg" && n.namespace_ ().empty ())
        {
          this->qchg_.set (qchg_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "dupd" && n.namespace_ ().empty ())
        {
          this->dupd_.set (dupd_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "fc" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< fc_type > r (
            fc_traits::create (i, f, this));

          this->fc_.set (r);
          continue;
        }
      }

      if (!dchg_.present ())
      {
        this->dchg_.set (dchg_default_value ());
      }

      if (!qchg_.present ())
      {
        this->qchg_.set (qchg_default_value ());
      }

      if (!dupd_.present ())
      {
        this->dupd_.set (dupd_default_value ());
      }

      if (!fc_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "fc",
          "");
      }
    }

    tDA* tDA::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class tDA (*this, f, c);
    }

    tDA::
    ~tDA ()
    {
    }

    // tDAType
    //

    tDAType::
    tDAType (const id_type& id)
    : ::IEC61850::SCL::tIDNaming (id),
      BDA_ (::xml_schema::flags (), this),
      iedType_ (::xml_schema::flags (), this)
    {
    }

    tDAType::
    tDAType (const tDAType& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
    : ::IEC61850::SCL::tIDNaming (x, f, c),
      BDA_ (x.BDA_, f, this),
      iedType_ (x.iedType_, f, this)
    {
    }

    tDAType::
    tDAType (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
    : ::IEC61850::SCL::tIDNaming (e, f | ::xml_schema::flags::base, c),
      BDA_ (f, this),
      iedType_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void tDAType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::IEC61850::SCL::tIDNaming::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BDA
        //
        if (n.name () == "BDA" && n.namespace_ () == "http://www.iec.ch/61850/2003/SCL")
        {
          ::std::auto_ptr< BDA_type > r (
            BDA_traits::create (i, f, this));

          this->BDA_.push_back (r);
          continue;
        }

        break;
      }

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "iedType" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< iedType_type > r (
            iedType_traits::create (i, f, this));

          this->iedType_.set (r);
          continue;
        }
      }
    }

    tDAType* tDAType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class tDAType (*this, f, c);
    }

    tDAType::
    ~tDAType ()
    {
    }

    // tBDA
    //

    tBDA::
    tBDA (const name_type& name,
          const bType_type& bType)
    : ::IEC61850::SCL::tAbstractDataAttribute (name,
                                               bType)
    {
    }

    tBDA::
    tBDA (const tBDA& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
    : ::IEC61850::SCL::tAbstractDataAttribute (x, f, c)
    {
    }

    tBDA::
    tBDA (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
    : ::IEC61850::SCL::tAbstractDataAttribute (e, f, c)
    {
    }

    tBDA* tBDA::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class tBDA (*this, f, c);
    }

    tBDA::
    ~tBDA ()
    {
    }

    // tEnumType
    //

    tEnumType::
    tEnumType (const id_type& id)
    : ::IEC61850::SCL::tIDNaming (id),
      EnumVal_ (::xml_schema::flags (), this)
    {
    }

    tEnumType::
    tEnumType (const tEnumType& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
    : ::IEC61850::SCL::tIDNaming (x, f, c),
      EnumVal_ (x.EnumVal_, f, this)
    {
    }

    tEnumType::
    tEnumType (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
    : ::IEC61850::SCL::tIDNaming (e, f | ::xml_schema::flags::base, c),
      EnumVal_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void tEnumType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::IEC61850::SCL::tIDNaming::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // EnumVal
        //
        if (n.name () == "EnumVal" && n.namespace_ () == "http://www.iec.ch/61850/2003/SCL")
        {
          ::std::auto_ptr< EnumVal_type > r (
            EnumVal_traits::create (i, f, this));

          this->EnumVal_.push_back (r);
          continue;
        }

        break;
      }
    }

    tEnumType* tEnumType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class tEnumType (*this, f, c);
    }

    tEnumType::
    ~tEnumType ()
    {
    }

    // tEnumVal
    //

    tEnumVal::
    tEnumVal (const ord_type& ord)
    : ::xml_schema::normalized_string (),
      ord_ (ord, ::xml_schema::flags (), this)
    {
    }

    tEnumVal::
    tEnumVal (const char* _xsd_normalized_string_base,
              const ord_type& ord)
    : ::xml_schema::normalized_string (_xsd_normalized_string_base),
      ord_ (ord, ::xml_schema::flags (), this)
    {
    }

    tEnumVal::
    tEnumVal (const ::std::string& _xsd_normalized_string_base,
              const ord_type& ord)
    : ::xml_schema::normalized_string (_xsd_normalized_string_base),
      ord_ (ord, ::xml_schema::flags (), this)
    {
    }

    tEnumVal::
    tEnumVal (const ::xml_schema::normalized_string& _xsd_normalized_string_base,
              const ord_type& ord)
    : ::xml_schema::normalized_string (_xsd_normalized_string_base),
      ord_ (ord, ::xml_schema::flags (), this)
    {
    }

    tEnumVal::
    tEnumVal (const tEnumVal& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
    : ::xml_schema::normalized_string (x, f, c),
      ord_ (x.ord_, f, this)
    {
    }

    tEnumVal::
    tEnumVal (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
    : ::xml_schema::normalized_string (e, f | ::xml_schema::flags::base, c),
      ord_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
        this->parse (p, f);
      }
    }

    void tEnumVal::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "ord" && n.namespace_ ().empty ())
        {
          this->ord_.set (ord_traits::create (i, f, this));
          continue;
        }
      }

      if (!ord_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "ord",
          "");
      }
    }

    tEnumVal* tEnumVal::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class tEnumVal (*this, f, c);
    }

    tEnumVal::
    ~tEnumVal ()
    {
    }

    // tDataTypeTemplates
    //

    tDataTypeTemplates::
    tDataTypeTemplates ()
    : ::xml_schema::type (),
      LNodeType_ (::xml_schema::flags (), this),
      DOType_ (::xml_schema::flags (), this),
      DAType_ (::xml_schema::flags (), this),
      EnumType_ (::xml_schema::flags (), this)
    {
    }

    tDataTypeTemplates::
    tDataTypeTemplates (const tDataTypeTemplates& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      LNodeType_ (x.LNodeType_, f, this),
      DOType_ (x.DOType_, f, this),
      DAType_ (x.DAType_, f, this),
      EnumType_ (x.EnumType_, f, this)
    {
    }

    tDataTypeTemplates::
    tDataTypeTemplates (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      LNodeType_ (f, this),
      DOType_ (f, this),
      DAType_ (f, this),
      EnumType_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void tDataTypeTemplates::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // LNodeType
        //
        if (n.name () == "LNodeType" && n.namespace_ () == "http://www.iec.ch/61850/2003/SCL")
        {
          ::std::auto_ptr< LNodeType_type > r (
            LNodeType_traits::create (i, f, this));

          this->LNodeType_.push_back (r);
          continue;
        }

        // DOType
        //
        if (n.name () == "DOType" && n.namespace_ () == "http://www.iec.ch/61850/2003/SCL")
        {
          ::std::auto_ptr< DOType_type > r (
            DOType_traits::create (i, f, this));

          this->DOType_.push_back (r);
          continue;
        }

        // DAType
        //
        if (n.name () == "DAType" && n.namespace_ () == "http://www.iec.ch/61850/2003/SCL")
        {
          ::std::auto_ptr< DAType_type > r (
            DAType_traits::create (i, f, this));

          this->DAType_.push_back (r);
          continue;
        }

        // EnumType
        //
        if (n.name () == "EnumType" && n.namespace_ () == "http://www.iec.ch/61850/2003/SCL")
        {
          ::std::auto_ptr< EnumType_type > r (
            EnumType_traits::create (i, f, this));

          this->EnumType_.push_back (r);
          continue;
        }

        break;
      }
    }

    tDataTypeTemplates* tDataTypeTemplates::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class tDataTypeTemplates (*this, f, c);
    }

    tDataTypeTemplates::
    ~tDataTypeTemplates ()
    {
    }
  }
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

namespace IEC61850
{
  namespace SCL
  {
  }
}

#include <ostream>
#include <xsd/cxx/xml/dom/serialization-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

namespace IEC61850
{
  namespace SCL
  {
    void
    operator<< (::xercesc::DOMElement& e, const tAbstractDataAttribute& i)
    {
      e << static_cast< const ::IEC61850::SCL::tUnNaming& > (i);

      // Val
      //
      for (tAbstractDataAttribute::Val_const_iterator
           b (i.Val ().begin ()), n (i.Val ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Val",
            "http://www.iec.ch/61850/2003/SCL",
            e));

        s << *b;
      }

      // name
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "name",
            e));

        a << i.name ();
      }

      // sAddr
      //
      if (i.sAddr ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "sAddr",
            e));

        a << *i.sAddr ();
      }

      // bType
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "bType",
            e));

        a << i.bType ();
      }

      // valKind
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "valKind",
            e));

        a << i.valKind ();
      }

      // type
      //
      if (i.type ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "type",
            e));

        a << *i.type ();
      }

      // count
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "count",
            e));

        a << i.count ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const tLNodeType& i)
    {
      e << static_cast< const ::IEC61850::SCL::tIDNaming& > (i);

      // DO
      //
      for (tLNodeType::DO_const_iterator
           b (i.DO ().begin ()), n (i.DO ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "DO",
            "http://www.iec.ch/61850/2003/SCL",
            e));

        s << *b;
      }

      // iedType
      //
      if (i.iedType ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "iedType",
            e));

        a << *i.iedType ();
      }

      // lnClass
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "lnClass",
            e));

        a << i.lnClass ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const tDO& i)
    {
      e << static_cast< const ::IEC61850::SCL::tUnNaming& > (i);

      // name
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "name",
            e));

        a << i.name ();
      }

      // type
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "type",
            e));

        a << i.type ();
      }

      // accessControl
      //
      if (i.accessControl ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "accessControl",
            e));

        a << *i.accessControl ();
      }

      // transient
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "transient",
            e));

        a << i.transient ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const tDOType& i)
    {
      e << static_cast< const ::IEC61850::SCL::tIDNaming& > (i);

      // SDO
      //
      for (tDOType::SDO_const_iterator
           b (i.SDO ().begin ()), n (i.SDO ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "SDO",
            "http://www.iec.ch/61850/2003/SCL",
            e));

        s << *b;
      }

      // DA
      //
      for (tDOType::DA_const_iterator
           b (i.DA ().begin ()), n (i.DA ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "DA",
            "http://www.iec.ch/61850/2003/SCL",
            e));

        s << *b;
      }

      // iedType
      //
      if (i.iedType ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "iedType",
            e));

        a << *i.iedType ();
      }

      // cdc
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "cdc",
            e));

        a << i.cdc ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const tSDO& i)
    {
      e << static_cast< const ::IEC61850::SCL::tNaming& > (i);

      // type
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "type",
            e));

        a << i.type ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const tDA& i)
    {
      e << static_cast< const ::IEC61850::SCL::tAbstractDataAttribute& > (i);

      // dchg
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "dchg",
            e));

        a << i.dchg ();
      }

      // qchg
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "qchg",
            e));

        a << i.qchg ();
      }

      // dupd
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "dupd",
            e));

        a << i.dupd ();
      }

      // fc
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "fc",
            e));

        a << i.fc ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const tDAType& i)
    {
      e << static_cast< const ::IEC61850::SCL::tIDNaming& > (i);

      // BDA
      //
      for (tDAType::BDA_const_iterator
           b (i.BDA ().begin ()), n (i.BDA ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "BDA",
            "http://www.iec.ch/61850/2003/SCL",
            e));

        s << *b;
      }

      // iedType
      //
      if (i.iedType ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "iedType",
            e));

        a << *i.iedType ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const tBDA& i)
    {
      e << static_cast< const ::IEC61850::SCL::tAbstractDataAttribute& > (i);
    }

    void
    operator<< (::xercesc::DOMElement& e, const tEnumType& i)
    {
      e << static_cast< const ::IEC61850::SCL::tIDNaming& > (i);

      // EnumVal
      //
      for (tEnumType::EnumVal_const_iterator
           b (i.EnumVal ().begin ()), n (i.EnumVal ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "EnumVal",
            "http://www.iec.ch/61850/2003/SCL",
            e));

        s << *b;
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const tEnumVal& i)
    {
      e << static_cast< const ::xml_schema::normalized_string& > (i);

      // ord
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "ord",
            e));

        a << i.ord ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const tDataTypeTemplates& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // LNodeType
      //
      for (tDataTypeTemplates::LNodeType_const_iterator
           b (i.LNodeType ().begin ()), n (i.LNodeType ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "LNodeType",
            "http://www.iec.ch/61850/2003/SCL",
            e));

        s << *b;
      }

      // DOType
      //
      for (tDataTypeTemplates::DOType_const_iterator
           b (i.DOType ().begin ()), n (i.DOType ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "DOType",
            "http://www.iec.ch/61850/2003/SCL",
            e));

        s << *b;
      }

      // DAType
      //
      for (tDataTypeTemplates::DAType_const_iterator
           b (i.DAType ().begin ()), n (i.DAType ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "DAType",
            "http://www.iec.ch/61850/2003/SCL",
            e));

        s << *b;
      }

      // EnumType
      //
      for (tDataTypeTemplates::EnumType_const_iterator
           b (i.EnumType ().begin ()), n (i.EnumType ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "EnumType",
            "http://www.iec.ch/61850/2003/SCL",
            e));

        s << *b;
      }
    }
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

