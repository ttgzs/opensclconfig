// Copyright (C) 2005-2008 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "SCL_IED.h"

namespace IEC61850
{
  namespace SCL
  {
    // tIED
    // 

    const tIED::Services_optional& tIED::
    Services () const
    {
      return this->Services_;
    }

    tIED::Services_optional& tIED::
    Services ()
    {
      return this->Services_;
    }

    void tIED::
    Services (const Services_type& x)
    {
      this->Services_.set (x);
    }

    void tIED::
    Services (const Services_optional& x)
    {
      this->Services_ = x;
    }

    void tIED::
    Services (::std::auto_ptr< Services_type > x)
    {
      this->Services_.set (x);
    }

    const tIED::AccessPoint_sequence& tIED::
    AccessPoint () const
    {
      return this->AccessPoint_;
    }

    tIED::AccessPoint_sequence& tIED::
    AccessPoint ()
    {
      return this->AccessPoint_;
    }

    void tIED::
    AccessPoint (const AccessPoint_sequence& s)
    {
      this->AccessPoint_ = s;
    }

    const tIED::type_optional& tIED::
    type () const
    {
      return this->type_;
    }

    tIED::type_optional& tIED::
    type ()
    {
      return this->type_;
    }

    void tIED::
    type (const type_type& x)
    {
      this->type_.set (x);
    }

    void tIED::
    type (const type_optional& x)
    {
      this->type_ = x;
    }

    void tIED::
    type (::std::auto_ptr< type_type > x)
    {
      this->type_.set (x);
    }

    const tIED::manufacturer_optional& tIED::
    manufacturer () const
    {
      return this->manufacturer_;
    }

    tIED::manufacturer_optional& tIED::
    manufacturer ()
    {
      return this->manufacturer_;
    }

    void tIED::
    manufacturer (const manufacturer_type& x)
    {
      this->manufacturer_.set (x);
    }

    void tIED::
    manufacturer (const manufacturer_optional& x)
    {
      this->manufacturer_ = x;
    }

    void tIED::
    manufacturer (::std::auto_ptr< manufacturer_type > x)
    {
      this->manufacturer_.set (x);
    }

    const tIED::configVersion_optional& tIED::
    configVersion () const
    {
      return this->configVersion_;
    }

    tIED::configVersion_optional& tIED::
    configVersion ()
    {
      return this->configVersion_;
    }

    void tIED::
    configVersion (const configVersion_type& x)
    {
      this->configVersion_.set (x);
    }

    void tIED::
    configVersion (const configVersion_optional& x)
    {
      this->configVersion_ = x;
    }

    void tIED::
    configVersion (::std::auto_ptr< configVersion_type > x)
    {
      this->configVersion_.set (x);
    }


    // tServices
    // 

    const tServices::DynAssociation_optional& tServices::
    DynAssociation () const
    {
      return this->DynAssociation_;
    }

    tServices::DynAssociation_optional& tServices::
    DynAssociation ()
    {
      return this->DynAssociation_;
    }

    void tServices::
    DynAssociation (const DynAssociation_type& x)
    {
      this->DynAssociation_.set (x);
    }

    void tServices::
    DynAssociation (const DynAssociation_optional& x)
    {
      this->DynAssociation_ = x;
    }

    void tServices::
    DynAssociation (::std::auto_ptr< DynAssociation_type > x)
    {
      this->DynAssociation_.set (x);
    }

    const tServices::SettingGroups_optional& tServices::
    SettingGroups () const
    {
      return this->SettingGroups_;
    }

    tServices::SettingGroups_optional& tServices::
    SettingGroups ()
    {
      return this->SettingGroups_;
    }

    void tServices::
    SettingGroups (const SettingGroups_type& x)
    {
      this->SettingGroups_.set (x);
    }

    void tServices::
    SettingGroups (const SettingGroups_optional& x)
    {
      this->SettingGroups_ = x;
    }

    void tServices::
    SettingGroups (::std::auto_ptr< SettingGroups_type > x)
    {
      this->SettingGroups_.set (x);
    }

    const tServices::GetDirectory_optional& tServices::
    GetDirectory () const
    {
      return this->GetDirectory_;
    }

    tServices::GetDirectory_optional& tServices::
    GetDirectory ()
    {
      return this->GetDirectory_;
    }

    void tServices::
    GetDirectory (const GetDirectory_type& x)
    {
      this->GetDirectory_.set (x);
    }

    void tServices::
    GetDirectory (const GetDirectory_optional& x)
    {
      this->GetDirectory_ = x;
    }

    void tServices::
    GetDirectory (::std::auto_ptr< GetDirectory_type > x)
    {
      this->GetDirectory_.set (x);
    }

    const tServices::GetDataObjectDefinition_optional& tServices::
    GetDataObjectDefinition () const
    {
      return this->GetDataObjectDefinition_;
    }

    tServices::GetDataObjectDefinition_optional& tServices::
    GetDataObjectDefinition ()
    {
      return this->GetDataObjectDefinition_;
    }

    void tServices::
    GetDataObjectDefinition (const GetDataObjectDefinition_type& x)
    {
      this->GetDataObjectDefinition_.set (x);
    }

    void tServices::
    GetDataObjectDefinition (const GetDataObjectDefinition_optional& x)
    {
      this->GetDataObjectDefinition_ = x;
    }

    void tServices::
    GetDataObjectDefinition (::std::auto_ptr< GetDataObjectDefinition_type > x)
    {
      this->GetDataObjectDefinition_.set (x);
    }

    const tServices::DataObjectDirectory_optional& tServices::
    DataObjectDirectory () const
    {
      return this->DataObjectDirectory_;
    }

    tServices::DataObjectDirectory_optional& tServices::
    DataObjectDirectory ()
    {
      return this->DataObjectDirectory_;
    }

    void tServices::
    DataObjectDirectory (const DataObjectDirectory_type& x)
    {
      this->DataObjectDirectory_.set (x);
    }

    void tServices::
    DataObjectDirectory (const DataObjectDirectory_optional& x)
    {
      this->DataObjectDirectory_ = x;
    }

    void tServices::
    DataObjectDirectory (::std::auto_ptr< DataObjectDirectory_type > x)
    {
      this->DataObjectDirectory_.set (x);
    }

    const tServices::GetDataSetValue_optional& tServices::
    GetDataSetValue () const
    {
      return this->GetDataSetValue_;
    }

    tServices::GetDataSetValue_optional& tServices::
    GetDataSetValue ()
    {
      return this->GetDataSetValue_;
    }

    void tServices::
    GetDataSetValue (const GetDataSetValue_type& x)
    {
      this->GetDataSetValue_.set (x);
    }

    void tServices::
    GetDataSetValue (const GetDataSetValue_optional& x)
    {
      this->GetDataSetValue_ = x;
    }

    void tServices::
    GetDataSetValue (::std::auto_ptr< GetDataSetValue_type > x)
    {
      this->GetDataSetValue_.set (x);
    }

    const tServices::SetDataSetValue_optional& tServices::
    SetDataSetValue () const
    {
      return this->SetDataSetValue_;
    }

    tServices::SetDataSetValue_optional& tServices::
    SetDataSetValue ()
    {
      return this->SetDataSetValue_;
    }

    void tServices::
    SetDataSetValue (const SetDataSetValue_type& x)
    {
      this->SetDataSetValue_.set (x);
    }

    void tServices::
    SetDataSetValue (const SetDataSetValue_optional& x)
    {
      this->SetDataSetValue_ = x;
    }

    void tServices::
    SetDataSetValue (::std::auto_ptr< SetDataSetValue_type > x)
    {
      this->SetDataSetValue_.set (x);
    }

    const tServices::DataSetDirectory_optional& tServices::
    DataSetDirectory () const
    {
      return this->DataSetDirectory_;
    }

    tServices::DataSetDirectory_optional& tServices::
    DataSetDirectory ()
    {
      return this->DataSetDirectory_;
    }

    void tServices::
    DataSetDirectory (const DataSetDirectory_type& x)
    {
      this->DataSetDirectory_.set (x);
    }

    void tServices::
    DataSetDirectory (const DataSetDirectory_optional& x)
    {
      this->DataSetDirectory_ = x;
    }

    void tServices::
    DataSetDirectory (::std::auto_ptr< DataSetDirectory_type > x)
    {
      this->DataSetDirectory_.set (x);
    }

    const tServices::ConfDataSet_optional& tServices::
    ConfDataSet () const
    {
      return this->ConfDataSet_;
    }

    tServices::ConfDataSet_optional& tServices::
    ConfDataSet ()
    {
      return this->ConfDataSet_;
    }

    void tServices::
    ConfDataSet (const ConfDataSet_type& x)
    {
      this->ConfDataSet_.set (x);
    }

    void tServices::
    ConfDataSet (const ConfDataSet_optional& x)
    {
      this->ConfDataSet_ = x;
    }

    void tServices::
    ConfDataSet (::std::auto_ptr< ConfDataSet_type > x)
    {
      this->ConfDataSet_.set (x);
    }

    const tServices::DynDataSet_optional& tServices::
    DynDataSet () const
    {
      return this->DynDataSet_;
    }

    tServices::DynDataSet_optional& tServices::
    DynDataSet ()
    {
      return this->DynDataSet_;
    }

    void tServices::
    DynDataSet (const DynDataSet_type& x)
    {
      this->DynDataSet_.set (x);
    }

    void tServices::
    DynDataSet (const DynDataSet_optional& x)
    {
      this->DynDataSet_ = x;
    }

    void tServices::
    DynDataSet (::std::auto_ptr< DynDataSet_type > x)
    {
      this->DynDataSet_.set (x);
    }

    const tServices::ReadWrite_optional& tServices::
    ReadWrite () const
    {
      return this->ReadWrite_;
    }

    tServices::ReadWrite_optional& tServices::
    ReadWrite ()
    {
      return this->ReadWrite_;
    }

    void tServices::
    ReadWrite (const ReadWrite_type& x)
    {
      this->ReadWrite_.set (x);
    }

    void tServices::
    ReadWrite (const ReadWrite_optional& x)
    {
      this->ReadWrite_ = x;
    }

    void tServices::
    ReadWrite (::std::auto_ptr< ReadWrite_type > x)
    {
      this->ReadWrite_.set (x);
    }

    const tServices::TimerActivatedControl_optional& tServices::
    TimerActivatedControl () const
    {
      return this->TimerActivatedControl_;
    }

    tServices::TimerActivatedControl_optional& tServices::
    TimerActivatedControl ()
    {
      return this->TimerActivatedControl_;
    }

    void tServices::
    TimerActivatedControl (const TimerActivatedControl_type& x)
    {
      this->TimerActivatedControl_.set (x);
    }

    void tServices::
    TimerActivatedControl (const TimerActivatedControl_optional& x)
    {
      this->TimerActivatedControl_ = x;
    }

    void tServices::
    TimerActivatedControl (::std::auto_ptr< TimerActivatedControl_type > x)
    {
      this->TimerActivatedControl_.set (x);
    }

    const tServices::ConfReportControl_optional& tServices::
    ConfReportControl () const
    {
      return this->ConfReportControl_;
    }

    tServices::ConfReportControl_optional& tServices::
    ConfReportControl ()
    {
      return this->ConfReportControl_;
    }

    void tServices::
    ConfReportControl (const ConfReportControl_type& x)
    {
      this->ConfReportControl_.set (x);
    }

    void tServices::
    ConfReportControl (const ConfReportControl_optional& x)
    {
      this->ConfReportControl_ = x;
    }

    void tServices::
    ConfReportControl (::std::auto_ptr< ConfReportControl_type > x)
    {
      this->ConfReportControl_.set (x);
    }

    const tServices::GetCBValues_optional& tServices::
    GetCBValues () const
    {
      return this->GetCBValues_;
    }

    tServices::GetCBValues_optional& tServices::
    GetCBValues ()
    {
      return this->GetCBValues_;
    }

    void tServices::
    GetCBValues (const GetCBValues_type& x)
    {
      this->GetCBValues_.set (x);
    }

    void tServices::
    GetCBValues (const GetCBValues_optional& x)
    {
      this->GetCBValues_ = x;
    }

    void tServices::
    GetCBValues (::std::auto_ptr< GetCBValues_type > x)
    {
      this->GetCBValues_.set (x);
    }

    const tServices::ConfLogControl_optional& tServices::
    ConfLogControl () const
    {
      return this->ConfLogControl_;
    }

    tServices::ConfLogControl_optional& tServices::
    ConfLogControl ()
    {
      return this->ConfLogControl_;
    }

    void tServices::
    ConfLogControl (const ConfLogControl_type& x)
    {
      this->ConfLogControl_.set (x);
    }

    void tServices::
    ConfLogControl (const ConfLogControl_optional& x)
    {
      this->ConfLogControl_ = x;
    }

    void tServices::
    ConfLogControl (::std::auto_ptr< ConfLogControl_type > x)
    {
      this->ConfLogControl_.set (x);
    }

    const tServices::ReportSettings_optional& tServices::
    ReportSettings () const
    {
      return this->ReportSettings_;
    }

    tServices::ReportSettings_optional& tServices::
    ReportSettings ()
    {
      return this->ReportSettings_;
    }

    void tServices::
    ReportSettings (const ReportSettings_type& x)
    {
      this->ReportSettings_.set (x);
    }

    void tServices::
    ReportSettings (const ReportSettings_optional& x)
    {
      this->ReportSettings_ = x;
    }

    void tServices::
    ReportSettings (::std::auto_ptr< ReportSettings_type > x)
    {
      this->ReportSettings_.set (x);
    }

    const tServices::LogSettings_optional& tServices::
    LogSettings () const
    {
      return this->LogSettings_;
    }

    tServices::LogSettings_optional& tServices::
    LogSettings ()
    {
      return this->LogSettings_;
    }

    void tServices::
    LogSettings (const LogSettings_type& x)
    {
      this->LogSettings_.set (x);
    }

    void tServices::
    LogSettings (const LogSettings_optional& x)
    {
      this->LogSettings_ = x;
    }

    void tServices::
    LogSettings (::std::auto_ptr< LogSettings_type > x)
    {
      this->LogSettings_.set (x);
    }

    const tServices::GSESettings_optional& tServices::
    GSESettings () const
    {
      return this->GSESettings_;
    }

    tServices::GSESettings_optional& tServices::
    GSESettings ()
    {
      return this->GSESettings_;
    }

    void tServices::
    GSESettings (const GSESettings_type& x)
    {
      this->GSESettings_.set (x);
    }

    void tServices::
    GSESettings (const GSESettings_optional& x)
    {
      this->GSESettings_ = x;
    }

    void tServices::
    GSESettings (::std::auto_ptr< GSESettings_type > x)
    {
      this->GSESettings_.set (x);
    }

    const tServices::SMVSettings_optional& tServices::
    SMVSettings () const
    {
      return this->SMVSettings_;
    }

    tServices::SMVSettings_optional& tServices::
    SMVSettings ()
    {
      return this->SMVSettings_;
    }

    void tServices::
    SMVSettings (const SMVSettings_type& x)
    {
      this->SMVSettings_.set (x);
    }

    void tServices::
    SMVSettings (const SMVSettings_optional& x)
    {
      this->SMVSettings_ = x;
    }

    void tServices::
    SMVSettings (::std::auto_ptr< SMVSettings_type > x)
    {
      this->SMVSettings_.set (x);
    }

    const tServices::GSEDir_optional& tServices::
    GSEDir () const
    {
      return this->GSEDir_;
    }

    tServices::GSEDir_optional& tServices::
    GSEDir ()
    {
      return this->GSEDir_;
    }

    void tServices::
    GSEDir (const GSEDir_type& x)
    {
      this->GSEDir_.set (x);
    }

    void tServices::
    GSEDir (const GSEDir_optional& x)
    {
      this->GSEDir_ = x;
    }

    void tServices::
    GSEDir (::std::auto_ptr< GSEDir_type > x)
    {
      this->GSEDir_.set (x);
    }

    const tServices::GOOSE_optional& tServices::
    GOOSE () const
    {
      return this->GOOSE_;
    }

    tServices::GOOSE_optional& tServices::
    GOOSE ()
    {
      return this->GOOSE_;
    }

    void tServices::
    GOOSE (const GOOSE_type& x)
    {
      this->GOOSE_.set (x);
    }

    void tServices::
    GOOSE (const GOOSE_optional& x)
    {
      this->GOOSE_ = x;
    }

    void tServices::
    GOOSE (::std::auto_ptr< GOOSE_type > x)
    {
      this->GOOSE_.set (x);
    }

    const tServices::GSSE_optional& tServices::
    GSSE () const
    {
      return this->GSSE_;
    }

    tServices::GSSE_optional& tServices::
    GSSE ()
    {
      return this->GSSE_;
    }

    void tServices::
    GSSE (const GSSE_type& x)
    {
      this->GSSE_.set (x);
    }

    void tServices::
    GSSE (const GSSE_optional& x)
    {
      this->GSSE_ = x;
    }

    void tServices::
    GSSE (::std::auto_ptr< GSSE_type > x)
    {
      this->GSSE_.set (x);
    }

    const tServices::FileHandling_optional& tServices::
    FileHandling () const
    {
      return this->FileHandling_;
    }

    tServices::FileHandling_optional& tServices::
    FileHandling ()
    {
      return this->FileHandling_;
    }

    void tServices::
    FileHandling (const FileHandling_type& x)
    {
      this->FileHandling_.set (x);
    }

    void tServices::
    FileHandling (const FileHandling_optional& x)
    {
      this->FileHandling_ = x;
    }

    void tServices::
    FileHandling (::std::auto_ptr< FileHandling_type > x)
    {
      this->FileHandling_.set (x);
    }

    const tServices::ConfLNs_optional& tServices::
    ConfLNs () const
    {
      return this->ConfLNs_;
    }

    tServices::ConfLNs_optional& tServices::
    ConfLNs ()
    {
      return this->ConfLNs_;
    }

    void tServices::
    ConfLNs (const ConfLNs_type& x)
    {
      this->ConfLNs_.set (x);
    }

    void tServices::
    ConfLNs (const ConfLNs_optional& x)
    {
      this->ConfLNs_ = x;
    }

    void tServices::
    ConfLNs (::std::auto_ptr< ConfLNs_type > x)
    {
      this->ConfLNs_.set (x);
    }

    const tServices::ClientServices_optional& tServices::
    ClientServices () const
    {
      return this->ClientServices_;
    }

    tServices::ClientServices_optional& tServices::
    ClientServices ()
    {
      return this->ClientServices_;
    }

    void tServices::
    ClientServices (const ClientServices_type& x)
    {
      this->ClientServices_.set (x);
    }

    void tServices::
    ClientServices (const ClientServices_optional& x)
    {
      this->ClientServices_ = x;
    }

    void tServices::
    ClientServices (::std::auto_ptr< ClientServices_type > x)
    {
      this->ClientServices_.set (x);
    }


    // tAccessPoint
    // 

    const tAccessPoint::Server_optional& tAccessPoint::
    Server () const
    {
      return this->Server_;
    }

    tAccessPoint::Server_optional& tAccessPoint::
    Server ()
    {
      return this->Server_;
    }

    void tAccessPoint::
    Server (const Server_type& x)
    {
      this->Server_.set (x);
    }

    void tAccessPoint::
    Server (const Server_optional& x)
    {
      this->Server_ = x;
    }

    void tAccessPoint::
    Server (::std::auto_ptr< Server_type > x)
    {
      this->Server_.set (x);
    }

    const tAccessPoint::LN_sequence& tAccessPoint::
    LN () const
    {
      return this->LN_;
    }

    tAccessPoint::LN_sequence& tAccessPoint::
    LN ()
    {
      return this->LN_;
    }

    void tAccessPoint::
    LN (const LN_sequence& s)
    {
      this->LN_ = s;
    }

    const tAccessPoint::router_type& tAccessPoint::
    router () const
    {
      return this->router_.get ();
    }

    tAccessPoint::router_type& tAccessPoint::
    router ()
    {
      return this->router_.get ();
    }

    void tAccessPoint::
    router (const router_type& x)
    {
      this->router_.set (x);
    }

    const tAccessPoint::router_type& tAccessPoint::
    router_default_value ()
    {
      return router_default_value_;
    }

    const tAccessPoint::clock_type& tAccessPoint::
    clock () const
    {
      return this->clock_.get ();
    }

    tAccessPoint::clock_type& tAccessPoint::
    clock ()
    {
      return this->clock_.get ();
    }

    void tAccessPoint::
    clock (const clock_type& x)
    {
      this->clock_.set (x);
    }

    const tAccessPoint::clock_type& tAccessPoint::
    clock_default_value ()
    {
      return clock_default_value_;
    }


    // tServer
    // 

    const tServer::Authentication_type& tServer::
    Authentication () const
    {
      return this->Authentication_.get ();
    }

    tServer::Authentication_type& tServer::
    Authentication ()
    {
      return this->Authentication_.get ();
    }

    void tServer::
    Authentication (const Authentication_type& x)
    {
      this->Authentication_.set (x);
    }

    void tServer::
    Authentication (::std::auto_ptr< Authentication_type > x)
    {
      this->Authentication_.set (x);
    }

    const tServer::LDevice_sequence& tServer::
    LDevice () const
    {
      return this->LDevice_;
    }

    tServer::LDevice_sequence& tServer::
    LDevice ()
    {
      return this->LDevice_;
    }

    void tServer::
    LDevice (const LDevice_sequence& s)
    {
      this->LDevice_ = s;
    }

    const tServer::Association_sequence& tServer::
    Association () const
    {
      return this->Association_;
    }

    tServer::Association_sequence& tServer::
    Association ()
    {
      return this->Association_;
    }

    void tServer::
    Association (const Association_sequence& s)
    {
      this->Association_ = s;
    }

    const tServer::timeout_type& tServer::
    timeout () const
    {
      return this->timeout_.get ();
    }

    tServer::timeout_type& tServer::
    timeout ()
    {
      return this->timeout_.get ();
    }

    void tServer::
    timeout (const timeout_type& x)
    {
      this->timeout_.set (x);
    }

    const tServer::timeout_type& tServer::
    timeout_default_value ()
    {
      return timeout_default_value_;
    }


    // tLDevice
    // 

    const tLDevice::LN0_type& tLDevice::
    LN0 () const
    {
      return this->LN0_.get ();
    }

    tLDevice::LN0_type& tLDevice::
    LN0 ()
    {
      return this->LN0_.get ();
    }

    void tLDevice::
    LN0 (const LN0_type& x)
    {
      this->LN0_.set (x);
    }

    void tLDevice::
    LN0 (::std::auto_ptr< LN0_type > x)
    {
      this->LN0_.set (x);
    }

    const tLDevice::LN_sequence& tLDevice::
    LN () const
    {
      return this->LN_;
    }

    tLDevice::LN_sequence& tLDevice::
    LN ()
    {
      return this->LN_;
    }

    void tLDevice::
    LN (const LN_sequence& s)
    {
      this->LN_ = s;
    }

    const tLDevice::AccessControl_optional& tLDevice::
    AccessControl () const
    {
      return this->AccessControl_;
    }

    tLDevice::AccessControl_optional& tLDevice::
    AccessControl ()
    {
      return this->AccessControl_;
    }

    void tLDevice::
    AccessControl (const AccessControl_type& x)
    {
      this->AccessControl_.set (x);
    }

    void tLDevice::
    AccessControl (const AccessControl_optional& x)
    {
      this->AccessControl_ = x;
    }

    void tLDevice::
    AccessControl (::std::auto_ptr< AccessControl_type > x)
    {
      this->AccessControl_.set (x);
    }

    const tLDevice::inst_type& tLDevice::
    inst () const
    {
      return this->inst_.get ();
    }

    tLDevice::inst_type& tLDevice::
    inst ()
    {
      return this->inst_.get ();
    }

    void tLDevice::
    inst (const inst_type& x)
    {
      this->inst_.set (x);
    }

    void tLDevice::
    inst (::std::auto_ptr< inst_type > x)
    {
      this->inst_.set (x);
    }

    const tLDevice::ldName_optional& tLDevice::
    ldName () const
    {
      return this->ldName_;
    }

    tLDevice::ldName_optional& tLDevice::
    ldName ()
    {
      return this->ldName_;
    }

    void tLDevice::
    ldName (const ldName_type& x)
    {
      this->ldName_.set (x);
    }

    void tLDevice::
    ldName (const ldName_optional& x)
    {
      this->ldName_ = x;
    }

    void tLDevice::
    ldName (::std::auto_ptr< ldName_type > x)
    {
      this->ldName_.set (x);
    }


    // tAccessControl
    // 


    // tAssociation
    // 

    const tAssociation::kind_type& tAssociation::
    kind () const
    {
      return this->kind_.get ();
    }

    tAssociation::kind_type& tAssociation::
    kind ()
    {
      return this->kind_.get ();
    }

    void tAssociation::
    kind (const kind_type& x)
    {
      this->kind_.set (x);
    }

    void tAssociation::
    kind (::std::auto_ptr< kind_type > x)
    {
      this->kind_.set (x);
    }

    const tAssociation::associationID_optional& tAssociation::
    associationID () const
    {
      return this->associationID_;
    }

    tAssociation::associationID_optional& tAssociation::
    associationID ()
    {
      return this->associationID_;
    }

    void tAssociation::
    associationID (const associationID_type& x)
    {
      this->associationID_.set (x);
    }

    void tAssociation::
    associationID (const associationID_optional& x)
    {
      this->associationID_ = x;
    }

    void tAssociation::
    associationID (::std::auto_ptr< associationID_type > x)
    {
      this->associationID_.set (x);
    }

    const tAssociation::iedName_type& tAssociation::
    iedName () const
    {
      return this->iedName_.get ();
    }

    tAssociation::iedName_type& tAssociation::
    iedName ()
    {
      return this->iedName_.get ();
    }

    void tAssociation::
    iedName (const iedName_type& x)
    {
      this->iedName_.set (x);
    }

    void tAssociation::
    iedName (::std::auto_ptr< iedName_type > x)
    {
      this->iedName_.set (x);
    }

    const tAssociation::ldInst_type& tAssociation::
    ldInst () const
    {
      return this->ldInst_.get ();
    }

    tAssociation::ldInst_type& tAssociation::
    ldInst ()
    {
      return this->ldInst_.get ();
    }

    void tAssociation::
    ldInst (const ldInst_type& x)
    {
      this->ldInst_.set (x);
    }

    void tAssociation::
    ldInst (::std::auto_ptr< ldInst_type > x)
    {
      this->ldInst_.set (x);
    }

    const tAssociation::prefix_optional& tAssociation::
    prefix () const
    {
      return this->prefix_;
    }

    tAssociation::prefix_optional& tAssociation::
    prefix ()
    {
      return this->prefix_;
    }

    void tAssociation::
    prefix (const prefix_type& x)
    {
      this->prefix_.set (x);
    }

    void tAssociation::
    prefix (const prefix_optional& x)
    {
      this->prefix_ = x;
    }

    void tAssociation::
    prefix (::std::auto_ptr< prefix_type > x)
    {
      this->prefix_.set (x);
    }

    const tAssociation::lnClass_type& tAssociation::
    lnClass () const
    {
      return this->lnClass_.get ();
    }

    tAssociation::lnClass_type& tAssociation::
    lnClass ()
    {
      return this->lnClass_.get ();
    }

    void tAssociation::
    lnClass (const lnClass_type& x)
    {
      this->lnClass_.set (x);
    }

    void tAssociation::
    lnClass (::std::auto_ptr< lnClass_type > x)
    {
      this->lnClass_.set (x);
    }

    const tAssociation::lnInst_type& tAssociation::
    lnInst () const
    {
      return this->lnInst_.get ();
    }

    tAssociation::lnInst_type& tAssociation::
    lnInst ()
    {
      return this->lnInst_.get ();
    }

    void tAssociation::
    lnInst (const lnInst_type& x)
    {
      this->lnInst_.set (x);
    }

    void tAssociation::
    lnInst (::std::auto_ptr< lnInst_type > x)
    {
      this->lnInst_.set (x);
    }


    // tAnyLN
    // 

    const tAnyLN::DataSet_sequence& tAnyLN::
    DataSet () const
    {
      return this->DataSet_;
    }

    tAnyLN::DataSet_sequence& tAnyLN::
    DataSet ()
    {
      return this->DataSet_;
    }

    void tAnyLN::
    DataSet (const DataSet_sequence& s)
    {
      this->DataSet_ = s;
    }

    const tAnyLN::ReportControl_sequence& tAnyLN::
    ReportControl () const
    {
      return this->ReportControl_;
    }

    tAnyLN::ReportControl_sequence& tAnyLN::
    ReportControl ()
    {
      return this->ReportControl_;
    }

    void tAnyLN::
    ReportControl (const ReportControl_sequence& s)
    {
      this->ReportControl_ = s;
    }

    const tAnyLN::LogControl_sequence& tAnyLN::
    LogControl () const
    {
      return this->LogControl_;
    }

    tAnyLN::LogControl_sequence& tAnyLN::
    LogControl ()
    {
      return this->LogControl_;
    }

    void tAnyLN::
    LogControl (const LogControl_sequence& s)
    {
      this->LogControl_ = s;
    }

    const tAnyLN::DOI_sequence& tAnyLN::
    DOI () const
    {
      return this->DOI_;
    }

    tAnyLN::DOI_sequence& tAnyLN::
    DOI ()
    {
      return this->DOI_;
    }

    void tAnyLN::
    DOI (const DOI_sequence& s)
    {
      this->DOI_ = s;
    }

    const tAnyLN::Inputs_optional& tAnyLN::
    Inputs () const
    {
      return this->Inputs_;
    }

    tAnyLN::Inputs_optional& tAnyLN::
    Inputs ()
    {
      return this->Inputs_;
    }

    void tAnyLN::
    Inputs (const Inputs_type& x)
    {
      this->Inputs_.set (x);
    }

    void tAnyLN::
    Inputs (const Inputs_optional& x)
    {
      this->Inputs_ = x;
    }

    void tAnyLN::
    Inputs (::std::auto_ptr< Inputs_type > x)
    {
      this->Inputs_.set (x);
    }

    const tAnyLN::lnType_type& tAnyLN::
    lnType () const
    {
      return this->lnType_.get ();
    }

    tAnyLN::lnType_type& tAnyLN::
    lnType ()
    {
      return this->lnType_.get ();
    }

    void tAnyLN::
    lnType (const lnType_type& x)
    {
      this->lnType_.set (x);
    }

    void tAnyLN::
    lnType (::std::auto_ptr< lnType_type > x)
    {
      this->lnType_.set (x);
    }


    // tLN
    // 

    const tLN::lnClass_type& tLN::
    lnClass () const
    {
      return this->lnClass_.get ();
    }

    tLN::lnClass_type& tLN::
    lnClass ()
    {
      return this->lnClass_.get ();
    }

    void tLN::
    lnClass (const lnClass_type& x)
    {
      this->lnClass_.set (x);
    }

    void tLN::
    lnClass (::std::auto_ptr< lnClass_type > x)
    {
      this->lnClass_.set (x);
    }

    const tLN::inst_type& tLN::
    inst () const
    {
      return this->inst_.get ();
    }

    tLN::inst_type& tLN::
    inst ()
    {
      return this->inst_.get ();
    }

    void tLN::
    inst (const inst_type& x)
    {
      this->inst_.set (x);
    }

    const tLN::prefix_optional& tLN::
    prefix () const
    {
      return this->prefix_;
    }

    tLN::prefix_optional& tLN::
    prefix ()
    {
      return this->prefix_;
    }

    void tLN::
    prefix (const prefix_type& x)
    {
      this->prefix_.set (x);
    }

    void tLN::
    prefix (const prefix_optional& x)
    {
      this->prefix_ = x;
    }

    void tLN::
    prefix (::std::auto_ptr< prefix_type > x)
    {
      this->prefix_.set (x);
    }


    // tLN0
    // 

    const tLN0::GSEControl_sequence& tLN0::
    GSEControl () const
    {
      return this->GSEControl_;
    }

    tLN0::GSEControl_sequence& tLN0::
    GSEControl ()
    {
      return this->GSEControl_;
    }

    void tLN0::
    GSEControl (const GSEControl_sequence& s)
    {
      this->GSEControl_ = s;
    }

    const tLN0::SampledValueControl_sequence& tLN0::
    SampledValueControl () const
    {
      return this->SampledValueControl_;
    }

    tLN0::SampledValueControl_sequence& tLN0::
    SampledValueControl ()
    {
      return this->SampledValueControl_;
    }

    void tLN0::
    SampledValueControl (const SampledValueControl_sequence& s)
    {
      this->SampledValueControl_ = s;
    }

    const tLN0::SettingControl_optional& tLN0::
    SettingControl () const
    {
      return this->SettingControl_;
    }

    tLN0::SettingControl_optional& tLN0::
    SettingControl ()
    {
      return this->SettingControl_;
    }

    void tLN0::
    SettingControl (const SettingControl_type& x)
    {
      this->SettingControl_.set (x);
    }

    void tLN0::
    SettingControl (const SettingControl_optional& x)
    {
      this->SettingControl_ = x;
    }

    void tLN0::
    SettingControl (::std::auto_ptr< SettingControl_type > x)
    {
      this->SettingControl_.set (x);
    }

    const tLN0::SCLControl_optional& tLN0::
    SCLControl () const
    {
      return this->SCLControl_;
    }

    tLN0::SCLControl_optional& tLN0::
    SCLControl ()
    {
      return this->SCLControl_;
    }

    void tLN0::
    SCLControl (const SCLControl_type& x)
    {
      this->SCLControl_.set (x);
    }

    void tLN0::
    SCLControl (const SCLControl_optional& x)
    {
      this->SCLControl_ = x;
    }

    void tLN0::
    SCLControl (::std::auto_ptr< SCLControl_type > x)
    {
      this->SCLControl_.set (x);
    }

    const tLN0::Log_optional& tLN0::
    Log () const
    {
      return this->Log_;
    }

    tLN0::Log_optional& tLN0::
    Log ()
    {
      return this->Log_;
    }

    void tLN0::
    Log (const Log_type& x)
    {
      this->Log_.set (x);
    }

    void tLN0::
    Log (const Log_optional& x)
    {
      this->Log_ = x;
    }

    void tLN0::
    Log (::std::auto_ptr< Log_type > x)
    {
      this->Log_.set (x);
    }

    const tLN0::lnClass_type& tLN0::
    lnClass () const
    {
      return this->lnClass_.get ();
    }

    const tLN0::lnClass_type& tLN0::
    lnClass_default_value ()
    {
      return lnClass_default_value_;
    }

    const tLN0::inst_type& tLN0::
    inst () const
    {
      return this->inst_.get ();
    }

    tLN0::inst_type& tLN0::
    inst ()
    {
      return this->inst_.get ();
    }

    void tLN0::
    inst (const inst_type& x)
    {
      this->inst_.set (x);
    }

    void tLN0::
    inst (::std::auto_ptr< inst_type > x)
    {
      this->inst_.set (x);
    }


    // tDataSet
    // 

    const tDataSet::FCDA_sequence& tDataSet::
    FCDA () const
    {
      return this->FCDA_;
    }

    tDataSet::FCDA_sequence& tDataSet::
    FCDA ()
    {
      return this->FCDA_;
    }

    void tDataSet::
    FCDA (const FCDA_sequence& s)
    {
      this->FCDA_ = s;
    }

    const tDataSet::FCCB_sequence& tDataSet::
    FCCB () const
    {
      return this->FCCB_;
    }

    tDataSet::FCCB_sequence& tDataSet::
    FCCB ()
    {
      return this->FCCB_;
    }

    void tDataSet::
    FCCB (const FCCB_sequence& s)
    {
      this->FCCB_ = s;
    }


    // tFCDA
    // 

    const tFCDA::ldInst_optional& tFCDA::
    ldInst () const
    {
      return this->ldInst_;
    }

    tFCDA::ldInst_optional& tFCDA::
    ldInst ()
    {
      return this->ldInst_;
    }

    void tFCDA::
    ldInst (const ldInst_type& x)
    {
      this->ldInst_.set (x);
    }

    void tFCDA::
    ldInst (const ldInst_optional& x)
    {
      this->ldInst_ = x;
    }

    void tFCDA::
    ldInst (::std::auto_ptr< ldInst_type > x)
    {
      this->ldInst_.set (x);
    }

    const tFCDA::prefix_optional& tFCDA::
    prefix () const
    {
      return this->prefix_;
    }

    tFCDA::prefix_optional& tFCDA::
    prefix ()
    {
      return this->prefix_;
    }

    void tFCDA::
    prefix (const prefix_type& x)
    {
      this->prefix_.set (x);
    }

    void tFCDA::
    prefix (const prefix_optional& x)
    {
      this->prefix_ = x;
    }

    void tFCDA::
    prefix (::std::auto_ptr< prefix_type > x)
    {
      this->prefix_.set (x);
    }

    const tFCDA::lnClass_optional& tFCDA::
    lnClass () const
    {
      return this->lnClass_;
    }

    tFCDA::lnClass_optional& tFCDA::
    lnClass ()
    {
      return this->lnClass_;
    }

    void tFCDA::
    lnClass (const lnClass_type& x)
    {
      this->lnClass_.set (x);
    }

    void tFCDA::
    lnClass (const lnClass_optional& x)
    {
      this->lnClass_ = x;
    }

    void tFCDA::
    lnClass (::std::auto_ptr< lnClass_type > x)
    {
      this->lnClass_.set (x);
    }

    const tFCDA::lnInst_optional& tFCDA::
    lnInst () const
    {
      return this->lnInst_;
    }

    tFCDA::lnInst_optional& tFCDA::
    lnInst ()
    {
      return this->lnInst_;
    }

    void tFCDA::
    lnInst (const lnInst_type& x)
    {
      this->lnInst_.set (x);
    }

    void tFCDA::
    lnInst (const lnInst_optional& x)
    {
      this->lnInst_ = x;
    }

    void tFCDA::
    lnInst (::std::auto_ptr< lnInst_type > x)
    {
      this->lnInst_.set (x);
    }

    const tFCDA::doName_optional& tFCDA::
    doName () const
    {
      return this->doName_;
    }

    tFCDA::doName_optional& tFCDA::
    doName ()
    {
      return this->doName_;
    }

    void tFCDA::
    doName (const doName_type& x)
    {
      this->doName_.set (x);
    }

    void tFCDA::
    doName (const doName_optional& x)
    {
      this->doName_ = x;
    }

    void tFCDA::
    doName (::std::auto_ptr< doName_type > x)
    {
      this->doName_.set (x);
    }

    const tFCDA::daName_optional& tFCDA::
    daName () const
    {
      return this->daName_;
    }

    tFCDA::daName_optional& tFCDA::
    daName ()
    {
      return this->daName_;
    }

    void tFCDA::
    daName (const daName_type& x)
    {
      this->daName_.set (x);
    }

    void tFCDA::
    daName (const daName_optional& x)
    {
      this->daName_ = x;
    }

    void tFCDA::
    daName (::std::auto_ptr< daName_type > x)
    {
      this->daName_.set (x);
    }

    const tFCDA::fc_type& tFCDA::
    fc () const
    {
      return this->fc_.get ();
    }

    tFCDA::fc_type& tFCDA::
    fc ()
    {
      return this->fc_.get ();
    }

    void tFCDA::
    fc (const fc_type& x)
    {
      this->fc_.set (x);
    }

    void tFCDA::
    fc (::std::auto_ptr< fc_type > x)
    {
      this->fc_.set (x);
    }


    // tFCCB
    // 

    const tFCCB::ldInst_type& tFCCB::
    ldInst () const
    {
      return this->ldInst_.get ();
    }

    tFCCB::ldInst_type& tFCCB::
    ldInst ()
    {
      return this->ldInst_.get ();
    }

    void tFCCB::
    ldInst (const ldInst_type& x)
    {
      this->ldInst_.set (x);
    }

    void tFCCB::
    ldInst (::std::auto_ptr< ldInst_type > x)
    {
      this->ldInst_.set (x);
    }

    const tFCCB::prefix_optional& tFCCB::
    prefix () const
    {
      return this->prefix_;
    }

    tFCCB::prefix_optional& tFCCB::
    prefix ()
    {
      return this->prefix_;
    }

    void tFCCB::
    prefix (const prefix_type& x)
    {
      this->prefix_.set (x);
    }

    void tFCCB::
    prefix (const prefix_optional& x)
    {
      this->prefix_ = x;
    }

    void tFCCB::
    prefix (::std::auto_ptr< prefix_type > x)
    {
      this->prefix_.set (x);
    }

    const tFCCB::lnClass_type& tFCCB::
    lnClass () const
    {
      return this->lnClass_.get ();
    }

    tFCCB::lnClass_type& tFCCB::
    lnClass ()
    {
      return this->lnClass_.get ();
    }

    void tFCCB::
    lnClass (const lnClass_type& x)
    {
      this->lnClass_.set (x);
    }

    void tFCCB::
    lnClass (::std::auto_ptr< lnClass_type > x)
    {
      this->lnClass_.set (x);
    }

    const tFCCB::lnInst_optional& tFCCB::
    lnInst () const
    {
      return this->lnInst_;
    }

    tFCCB::lnInst_optional& tFCCB::
    lnInst ()
    {
      return this->lnInst_;
    }

    void tFCCB::
    lnInst (const lnInst_type& x)
    {
      this->lnInst_.set (x);
    }

    void tFCCB::
    lnInst (const lnInst_optional& x)
    {
      this->lnInst_ = x;
    }

    void tFCCB::
    lnInst (::std::auto_ptr< lnInst_type > x)
    {
      this->lnInst_.set (x);
    }

    const tFCCB::cbName_type& tFCCB::
    cbName () const
    {
      return this->cbName_.get ();
    }

    tFCCB::cbName_type& tFCCB::
    cbName ()
    {
      return this->cbName_.get ();
    }

    void tFCCB::
    cbName (const cbName_type& x)
    {
      this->cbName_.set (x);
    }

    void tFCCB::
    cbName (::std::auto_ptr< cbName_type > x)
    {
      this->cbName_.set (x);
    }

    const tFCCB::daName_optional& tFCCB::
    daName () const
    {
      return this->daName_;
    }

    tFCCB::daName_optional& tFCCB::
    daName ()
    {
      return this->daName_;
    }

    void tFCCB::
    daName (const daName_type& x)
    {
      this->daName_.set (x);
    }

    void tFCCB::
    daName (const daName_optional& x)
    {
      this->daName_ = x;
    }

    void tFCCB::
    daName (::std::auto_ptr< daName_type > x)
    {
      this->daName_.set (x);
    }

    const tFCCB::fc_type& tFCCB::
    fc () const
    {
      return this->fc_.get ();
    }

    tFCCB::fc_type& tFCCB::
    fc ()
    {
      return this->fc_.get ();
    }

    void tFCCB::
    fc (const fc_type& x)
    {
      this->fc_.set (x);
    }

    void tFCCB::
    fc (::std::auto_ptr< fc_type > x)
    {
      this->fc_.set (x);
    }


    // tControl
    // 

    const tControl::datSet_optional& tControl::
    datSet () const
    {
      return this->datSet_;
    }

    tControl::datSet_optional& tControl::
    datSet ()
    {
      return this->datSet_;
    }

    void tControl::
    datSet (const datSet_type& x)
    {
      this->datSet_.set (x);
    }

    void tControl::
    datSet (const datSet_optional& x)
    {
      this->datSet_ = x;
    }

    void tControl::
    datSet (::std::auto_ptr< datSet_type > x)
    {
      this->datSet_.set (x);
    }


    // tControlWithTriggerOpt
    // 

    const tControlWithTriggerOpt::TrgOps_optional& tControlWithTriggerOpt::
    TrgOps () const
    {
      return this->TrgOps_;
    }

    tControlWithTriggerOpt::TrgOps_optional& tControlWithTriggerOpt::
    TrgOps ()
    {
      return this->TrgOps_;
    }

    void tControlWithTriggerOpt::
    TrgOps (const TrgOps_type& x)
    {
      this->TrgOps_.set (x);
    }

    void tControlWithTriggerOpt::
    TrgOps (const TrgOps_optional& x)
    {
      this->TrgOps_ = x;
    }

    void tControlWithTriggerOpt::
    TrgOps (::std::auto_ptr< TrgOps_type > x)
    {
      this->TrgOps_.set (x);
    }

    const tControlWithTriggerOpt::intgPd_type& tControlWithTriggerOpt::
    intgPd () const
    {
      return this->intgPd_.get ();
    }

    tControlWithTriggerOpt::intgPd_type& tControlWithTriggerOpt::
    intgPd ()
    {
      return this->intgPd_.get ();
    }

    void tControlWithTriggerOpt::
    intgPd (const intgPd_type& x)
    {
      this->intgPd_.set (x);
    }

    const tControlWithTriggerOpt::intgPd_type& tControlWithTriggerOpt::
    intgPd_default_value ()
    {
      return intgPd_default_value_;
    }


    // tTrgOps
    // 

    const tTrgOps::dchg_type& tTrgOps::
    dchg () const
    {
      return this->dchg_.get ();
    }

    tTrgOps::dchg_type& tTrgOps::
    dchg ()
    {
      return this->dchg_.get ();
    }

    void tTrgOps::
    dchg (const dchg_type& x)
    {
      this->dchg_.set (x);
    }

    const tTrgOps::dchg_type& tTrgOps::
    dchg_default_value ()
    {
      return dchg_default_value_;
    }

    const tTrgOps::qchg_type& tTrgOps::
    qchg () const
    {
      return this->qchg_.get ();
    }

    tTrgOps::qchg_type& tTrgOps::
    qchg ()
    {
      return this->qchg_.get ();
    }

    void tTrgOps::
    qchg (const qchg_type& x)
    {
      this->qchg_.set (x);
    }

    const tTrgOps::qchg_type& tTrgOps::
    qchg_default_value ()
    {
      return qchg_default_value_;
    }

    const tTrgOps::dupd_type& tTrgOps::
    dupd () const
    {
      return this->dupd_.get ();
    }

    tTrgOps::dupd_type& tTrgOps::
    dupd ()
    {
      return this->dupd_.get ();
    }

    void tTrgOps::
    dupd (const dupd_type& x)
    {
      this->dupd_.set (x);
    }

    const tTrgOps::dupd_type& tTrgOps::
    dupd_default_value ()
    {
      return dupd_default_value_;
    }

    const tTrgOps::period_type& tTrgOps::
    period () const
    {
      return this->period_.get ();
    }

    tTrgOps::period_type& tTrgOps::
    period ()
    {
      return this->period_.get ();
    }

    void tTrgOps::
    period (const period_type& x)
    {
      this->period_.set (x);
    }

    const tTrgOps::period_type& tTrgOps::
    period_default_value ()
    {
      return period_default_value_;
    }


    // tReportControl
    // 

    const tReportControl::OptFields_type& tReportControl::
    OptFields () const
    {
      return this->OptFields_.get ();
    }

    tReportControl::OptFields_type& tReportControl::
    OptFields ()
    {
      return this->OptFields_.get ();
    }

    void tReportControl::
    OptFields (const OptFields_type& x)
    {
      this->OptFields_.set (x);
    }

    void tReportControl::
    OptFields (::std::auto_ptr< OptFields_type > x)
    {
      this->OptFields_.set (x);
    }

    const tReportControl::RptEnabled_optional& tReportControl::
    RptEnabled () const
    {
      return this->RptEnabled_;
    }

    tReportControl::RptEnabled_optional& tReportControl::
    RptEnabled ()
    {
      return this->RptEnabled_;
    }

    void tReportControl::
    RptEnabled (const RptEnabled_type& x)
    {
      this->RptEnabled_.set (x);
    }

    void tReportControl::
    RptEnabled (const RptEnabled_optional& x)
    {
      this->RptEnabled_ = x;
    }

    void tReportControl::
    RptEnabled (::std::auto_ptr< RptEnabled_type > x)
    {
      this->RptEnabled_.set (x);
    }

    const tReportControl::rptID_optional& tReportControl::
    rptID () const
    {
      return this->rptID_;
    }

    tReportControl::rptID_optional& tReportControl::
    rptID ()
    {
      return this->rptID_;
    }

    void tReportControl::
    rptID (const rptID_type& x)
    {
      this->rptID_.set (x);
    }

    void tReportControl::
    rptID (const rptID_optional& x)
    {
      this->rptID_ = x;
    }

    void tReportControl::
    rptID (::std::auto_ptr< rptID_type > x)
    {
      this->rptID_.set (x);
    }

    const tReportControl::confRev_type& tReportControl::
    confRev () const
    {
      return this->confRev_.get ();
    }

    tReportControl::confRev_type& tReportControl::
    confRev ()
    {
      return this->confRev_.get ();
    }

    void tReportControl::
    confRev (const confRev_type& x)
    {
      this->confRev_.set (x);
    }

    const tReportControl::buffered_type& tReportControl::
    buffered () const
    {
      return this->buffered_.get ();
    }

    tReportControl::buffered_type& tReportControl::
    buffered ()
    {
      return this->buffered_.get ();
    }

    void tReportControl::
    buffered (const buffered_type& x)
    {
      this->buffered_.set (x);
    }

    const tReportControl::buffered_type& tReportControl::
    buffered_default_value ()
    {
      return buffered_default_value_;
    }

    const tReportControl::bufTime_type& tReportControl::
    bufTime () const
    {
      return this->bufTime_.get ();
    }

    tReportControl::bufTime_type& tReportControl::
    bufTime ()
    {
      return this->bufTime_.get ();
    }

    void tReportControl::
    bufTime (const bufTime_type& x)
    {
      this->bufTime_.set (x);
    }

    const tReportControl::bufTime_type& tReportControl::
    bufTime_default_value ()
    {
      return bufTime_default_value_;
    }


    // tRptEnabled
    // 

    const tRptEnabled::ClientLN_sequence& tRptEnabled::
    ClientLN () const
    {
      return this->ClientLN_;
    }

    tRptEnabled::ClientLN_sequence& tRptEnabled::
    ClientLN ()
    {
      return this->ClientLN_;
    }

    void tRptEnabled::
    ClientLN (const ClientLN_sequence& s)
    {
      this->ClientLN_ = s;
    }

    const tRptEnabled::max_type& tRptEnabled::
    max () const
    {
      return this->max_.get ();
    }

    tRptEnabled::max_type& tRptEnabled::
    max ()
    {
      return this->max_.get ();
    }

    void tRptEnabled::
    max (const max_type& x)
    {
      this->max_.set (x);
    }

    const tRptEnabled::max_type& tRptEnabled::
    max_default_value ()
    {
      return max_default_value_;
    }


    // tClientLN
    // 

    const tClientLN::iedName_type& tClientLN::
    iedName () const
    {
      return this->iedName_.get ();
    }

    tClientLN::iedName_type& tClientLN::
    iedName ()
    {
      return this->iedName_.get ();
    }

    void tClientLN::
    iedName (const iedName_type& x)
    {
      this->iedName_.set (x);
    }

    void tClientLN::
    iedName (::std::auto_ptr< iedName_type > x)
    {
      this->iedName_.set (x);
    }

    const tClientLN::ldInst_type& tClientLN::
    ldInst () const
    {
      return this->ldInst_.get ();
    }

    tClientLN::ldInst_type& tClientLN::
    ldInst ()
    {
      return this->ldInst_.get ();
    }

    void tClientLN::
    ldInst (const ldInst_type& x)
    {
      this->ldInst_.set (x);
    }

    void tClientLN::
    ldInst (::std::auto_ptr< ldInst_type > x)
    {
      this->ldInst_.set (x);
    }

    const tClientLN::prefix_optional& tClientLN::
    prefix () const
    {
      return this->prefix_;
    }

    tClientLN::prefix_optional& tClientLN::
    prefix ()
    {
      return this->prefix_;
    }

    void tClientLN::
    prefix (const prefix_type& x)
    {
      this->prefix_.set (x);
    }

    void tClientLN::
    prefix (const prefix_optional& x)
    {
      this->prefix_ = x;
    }

    void tClientLN::
    prefix (::std::auto_ptr< prefix_type > x)
    {
      this->prefix_.set (x);
    }

    const tClientLN::lnClass_type& tClientLN::
    lnClass () const
    {
      return this->lnClass_.get ();
    }

    tClientLN::lnClass_type& tClientLN::
    lnClass ()
    {
      return this->lnClass_.get ();
    }

    void tClientLN::
    lnClass (const lnClass_type& x)
    {
      this->lnClass_.set (x);
    }

    void tClientLN::
    lnClass (::std::auto_ptr< lnClass_type > x)
    {
      this->lnClass_.set (x);
    }

    const tClientLN::lnInst_type& tClientLN::
    lnInst () const
    {
      return this->lnInst_.get ();
    }

    tClientLN::lnInst_type& tClientLN::
    lnInst ()
    {
      return this->lnInst_.get ();
    }

    void tClientLN::
    lnInst (const lnInst_type& x)
    {
      this->lnInst_.set (x);
    }

    void tClientLN::
    lnInst (::std::auto_ptr< lnInst_type > x)
    {
      this->lnInst_.set (x);
    }


    // tLogControl
    // 

    const tLogControl::logName_type& tLogControl::
    logName () const
    {
      return this->logName_.get ();
    }

    tLogControl::logName_type& tLogControl::
    logName ()
    {
      return this->logName_.get ();
    }

    void tLogControl::
    logName (const logName_type& x)
    {
      this->logName_.set (x);
    }

    void tLogControl::
    logName (::std::auto_ptr< logName_type > x)
    {
      this->logName_.set (x);
    }

    const tLogControl::logEna_type& tLogControl::
    logEna () const
    {
      return this->logEna_.get ();
    }

    tLogControl::logEna_type& tLogControl::
    logEna ()
    {
      return this->logEna_.get ();
    }

    void tLogControl::
    logEna (const logEna_type& x)
    {
      this->logEna_.set (x);
    }

    const tLogControl::logEna_type& tLogControl::
    logEna_default_value ()
    {
      return logEna_default_value_;
    }

    const tLogControl::reasonCode_type& tLogControl::
    reasonCode () const
    {
      return this->reasonCode_.get ();
    }

    tLogControl::reasonCode_type& tLogControl::
    reasonCode ()
    {
      return this->reasonCode_.get ();
    }

    void tLogControl::
    reasonCode (const reasonCode_type& x)
    {
      this->reasonCode_.set (x);
    }

    const tLogControl::reasonCode_type& tLogControl::
    reasonCode_default_value ()
    {
      return reasonCode_default_value_;
    }


    // tInputs
    // 

    const tInputs::ExtRef_sequence& tInputs::
    ExtRef () const
    {
      return this->ExtRef_;
    }

    tInputs::ExtRef_sequence& tInputs::
    ExtRef ()
    {
      return this->ExtRef_;
    }

    void tInputs::
    ExtRef (const ExtRef_sequence& s)
    {
      this->ExtRef_ = s;
    }


    // tExtRef
    // 

    const tExtRef::iedName_type& tExtRef::
    iedName () const
    {
      return this->iedName_.get ();
    }

    tExtRef::iedName_type& tExtRef::
    iedName ()
    {
      return this->iedName_.get ();
    }

    void tExtRef::
    iedName (const iedName_type& x)
    {
      this->iedName_.set (x);
    }

    void tExtRef::
    iedName (::std::auto_ptr< iedName_type > x)
    {
      this->iedName_.set (x);
    }

    const tExtRef::ldInst_type& tExtRef::
    ldInst () const
    {
      return this->ldInst_.get ();
    }

    tExtRef::ldInst_type& tExtRef::
    ldInst ()
    {
      return this->ldInst_.get ();
    }

    void tExtRef::
    ldInst (const ldInst_type& x)
    {
      this->ldInst_.set (x);
    }

    void tExtRef::
    ldInst (::std::auto_ptr< ldInst_type > x)
    {
      this->ldInst_.set (x);
    }

    const tExtRef::prefix_optional& tExtRef::
    prefix () const
    {
      return this->prefix_;
    }

    tExtRef::prefix_optional& tExtRef::
    prefix ()
    {
      return this->prefix_;
    }

    void tExtRef::
    prefix (const prefix_type& x)
    {
      this->prefix_.set (x);
    }

    void tExtRef::
    prefix (const prefix_optional& x)
    {
      this->prefix_ = x;
    }

    void tExtRef::
    prefix (::std::auto_ptr< prefix_type > x)
    {
      this->prefix_.set (x);
    }

    const tExtRef::lnClass_type& tExtRef::
    lnClass () const
    {
      return this->lnClass_.get ();
    }

    tExtRef::lnClass_type& tExtRef::
    lnClass ()
    {
      return this->lnClass_.get ();
    }

    void tExtRef::
    lnClass (const lnClass_type& x)
    {
      this->lnClass_.set (x);
    }

    void tExtRef::
    lnClass (::std::auto_ptr< lnClass_type > x)
    {
      this->lnClass_.set (x);
    }

    const tExtRef::lnInst_type& tExtRef::
    lnInst () const
    {
      return this->lnInst_.get ();
    }

    tExtRef::lnInst_type& tExtRef::
    lnInst ()
    {
      return this->lnInst_.get ();
    }

    void tExtRef::
    lnInst (const lnInst_type& x)
    {
      this->lnInst_.set (x);
    }

    void tExtRef::
    lnInst (::std::auto_ptr< lnInst_type > x)
    {
      this->lnInst_.set (x);
    }

    const tExtRef::doName_type& tExtRef::
    doName () const
    {
      return this->doName_.get ();
    }

    tExtRef::doName_type& tExtRef::
    doName ()
    {
      return this->doName_.get ();
    }

    void tExtRef::
    doName (const doName_type& x)
    {
      this->doName_.set (x);
    }

    void tExtRef::
    doName (::std::auto_ptr< doName_type > x)
    {
      this->doName_.set (x);
    }

    const tExtRef::daName_optional& tExtRef::
    daName () const
    {
      return this->daName_;
    }

    tExtRef::daName_optional& tExtRef::
    daName ()
    {
      return this->daName_;
    }

    void tExtRef::
    daName (const daName_type& x)
    {
      this->daName_.set (x);
    }

    void tExtRef::
    daName (const daName_optional& x)
    {
      this->daName_ = x;
    }

    void tExtRef::
    daName (::std::auto_ptr< daName_type > x)
    {
      this->daName_.set (x);
    }

    const tExtRef::intAddr_optional& tExtRef::
    intAddr () const
    {
      return this->intAddr_;
    }

    tExtRef::intAddr_optional& tExtRef::
    intAddr ()
    {
      return this->intAddr_;
    }

    void tExtRef::
    intAddr (const intAddr_type& x)
    {
      this->intAddr_.set (x);
    }

    void tExtRef::
    intAddr (const intAddr_optional& x)
    {
      this->intAddr_ = x;
    }

    void tExtRef::
    intAddr (::std::auto_ptr< intAddr_type > x)
    {
      this->intAddr_.set (x);
    }


    // tLog
    // 


    // tControlWithIEDName
    // 

    const tControlWithIEDName::IEDName_sequence& tControlWithIEDName::
    IEDName () const
    {
      return this->IEDName_;
    }

    tControlWithIEDName::IEDName_sequence& tControlWithIEDName::
    IEDName ()
    {
      return this->IEDName_;
    }

    void tControlWithIEDName::
    IEDName (const IEDName_sequence& s)
    {
      this->IEDName_ = s;
    }

    const tControlWithIEDName::confRev_optional& tControlWithIEDName::
    confRev () const
    {
      return this->confRev_;
    }

    tControlWithIEDName::confRev_optional& tControlWithIEDName::
    confRev ()
    {
      return this->confRev_;
    }

    void tControlWithIEDName::
    confRev (const confRev_type& x)
    {
      this->confRev_.set (x);
    }

    void tControlWithIEDName::
    confRev (const confRev_optional& x)
    {
      this->confRev_ = x;
    }


    // tGSEControl
    // 

    const tGSEControl::type_type& tGSEControl::
    type () const
    {
      return this->type_.get ();
    }

    tGSEControl::type_type& tGSEControl::
    type ()
    {
      return this->type_.get ();
    }

    void tGSEControl::
    type (const type_type& x)
    {
      this->type_.set (x);
    }

    void tGSEControl::
    type (::std::auto_ptr< type_type > x)
    {
      this->type_.set (x);
    }

    const tGSEControl::type_type& tGSEControl::
    type_default_value ()
    {
      return type_default_value_;
    }

    const tGSEControl::appID_type& tGSEControl::
    appID () const
    {
      return this->appID_.get ();
    }

    tGSEControl::appID_type& tGSEControl::
    appID ()
    {
      return this->appID_.get ();
    }

    void tGSEControl::
    appID (const appID_type& x)
    {
      this->appID_.set (x);
    }

    void tGSEControl::
    appID (::std::auto_ptr< appID_type > x)
    {
      this->appID_.set (x);
    }


    // tSampledValueControl
    // 

    const tSampledValueControl::SmvOpts_type& tSampledValueControl::
    SmvOpts () const
    {
      return this->SmvOpts_.get ();
    }

    tSampledValueControl::SmvOpts_type& tSampledValueControl::
    SmvOpts ()
    {
      return this->SmvOpts_.get ();
    }

    void tSampledValueControl::
    SmvOpts (const SmvOpts_type& x)
    {
      this->SmvOpts_.set (x);
    }

    void tSampledValueControl::
    SmvOpts (::std::auto_ptr< SmvOpts_type > x)
    {
      this->SmvOpts_.set (x);
    }

    const tSampledValueControl::smvID_type& tSampledValueControl::
    smvID () const
    {
      return this->smvID_.get ();
    }

    tSampledValueControl::smvID_type& tSampledValueControl::
    smvID ()
    {
      return this->smvID_.get ();
    }

    void tSampledValueControl::
    smvID (const smvID_type& x)
    {
      this->smvID_.set (x);
    }

    void tSampledValueControl::
    smvID (::std::auto_ptr< smvID_type > x)
    {
      this->smvID_.set (x);
    }

    const tSampledValueControl::multicast_type& tSampledValueControl::
    multicast () const
    {
      return this->multicast_.get ();
    }

    tSampledValueControl::multicast_type& tSampledValueControl::
    multicast ()
    {
      return this->multicast_.get ();
    }

    void tSampledValueControl::
    multicast (const multicast_type& x)
    {
      this->multicast_.set (x);
    }

    const tSampledValueControl::multicast_type& tSampledValueControl::
    multicast_default_value ()
    {
      return multicast_default_value_;
    }

    const tSampledValueControl::smpRate_type& tSampledValueControl::
    smpRate () const
    {
      return this->smpRate_.get ();
    }

    tSampledValueControl::smpRate_type& tSampledValueControl::
    smpRate ()
    {
      return this->smpRate_.get ();
    }

    void tSampledValueControl::
    smpRate (const smpRate_type& x)
    {
      this->smpRate_.set (x);
    }

    const tSampledValueControl::nofASDU_type& tSampledValueControl::
    nofASDU () const
    {
      return this->nofASDU_.get ();
    }

    tSampledValueControl::nofASDU_type& tSampledValueControl::
    nofASDU ()
    {
      return this->nofASDU_.get ();
    }

    void tSampledValueControl::
    nofASDU (const nofASDU_type& x)
    {
      this->nofASDU_.set (x);
    }


    // tSettingControl
    // 

    const tSettingControl::numOfSGs_type& tSettingControl::
    numOfSGs () const
    {
      return this->numOfSGs_.get ();
    }

    tSettingControl::numOfSGs_type& tSettingControl::
    numOfSGs ()
    {
      return this->numOfSGs_.get ();
    }

    void tSettingControl::
    numOfSGs (const numOfSGs_type& x)
    {
      this->numOfSGs_.set (x);
    }

    const tSettingControl::actSG_type& tSettingControl::
    actSG () const
    {
      return this->actSG_.get ();
    }

    tSettingControl::actSG_type& tSettingControl::
    actSG ()
    {
      return this->actSG_.get ();
    }

    void tSettingControl::
    actSG (const actSG_type& x)
    {
      this->actSG_.set (x);
    }

    const tSettingControl::actSG_type& tSettingControl::
    actSG_default_value ()
    {
      return actSG_default_value_;
    }


    // tSCLControl
    // 


    // tDOI
    // 

    const tDOI::SDI_sequence& tDOI::
    SDI () const
    {
      return this->SDI_;
    }

    tDOI::SDI_sequence& tDOI::
    SDI ()
    {
      return this->SDI_;
    }

    void tDOI::
    SDI (const SDI_sequence& s)
    {
      this->SDI_ = s;
    }

    const tDOI::DAI_sequence& tDOI::
    DAI () const
    {
      return this->DAI_;
    }

    tDOI::DAI_sequence& tDOI::
    DAI ()
    {
      return this->DAI_;
    }

    void tDOI::
    DAI (const DAI_sequence& s)
    {
      this->DAI_ = s;
    }

    const tDOI::name_type& tDOI::
    name () const
    {
      return this->name_.get ();
    }

    tDOI::name_type& tDOI::
    name ()
    {
      return this->name_.get ();
    }

    void tDOI::
    name (const name_type& x)
    {
      this->name_.set (x);
    }

    void tDOI::
    name (::std::auto_ptr< name_type > x)
    {
      this->name_.set (x);
    }

    const tDOI::ix_optional& tDOI::
    ix () const
    {
      return this->ix_;
    }

    tDOI::ix_optional& tDOI::
    ix ()
    {
      return this->ix_;
    }

    void tDOI::
    ix (const ix_type& x)
    {
      this->ix_.set (x);
    }

    void tDOI::
    ix (const ix_optional& x)
    {
      this->ix_ = x;
    }

    const tDOI::accessControl_optional& tDOI::
    accessControl () const
    {
      return this->accessControl_;
    }

    tDOI::accessControl_optional& tDOI::
    accessControl ()
    {
      return this->accessControl_;
    }

    void tDOI::
    accessControl (const accessControl_type& x)
    {
      this->accessControl_.set (x);
    }

    void tDOI::
    accessControl (const accessControl_optional& x)
    {
      this->accessControl_ = x;
    }

    void tDOI::
    accessControl (::std::auto_ptr< accessControl_type > x)
    {
      this->accessControl_.set (x);
    }


    // tSDI
    // 

    const tSDI::SDI_sequence& tSDI::
    SDI () const
    {
      return this->SDI_;
    }

    tSDI::SDI_sequence& tSDI::
    SDI ()
    {
      return this->SDI_;
    }

    void tSDI::
    SDI (const SDI_sequence& s)
    {
      this->SDI_ = s;
    }

    const tSDI::DAI_sequence& tSDI::
    DAI () const
    {
      return this->DAI_;
    }

    tSDI::DAI_sequence& tSDI::
    DAI ()
    {
      return this->DAI_;
    }

    void tSDI::
    DAI (const DAI_sequence& s)
    {
      this->DAI_ = s;
    }

    const tSDI::name_type& tSDI::
    name () const
    {
      return this->name_.get ();
    }

    tSDI::name_type& tSDI::
    name ()
    {
      return this->name_.get ();
    }

    void tSDI::
    name (const name_type& x)
    {
      this->name_.set (x);
    }

    void tSDI::
    name (::std::auto_ptr< name_type > x)
    {
      this->name_.set (x);
    }

    const tSDI::ix_optional& tSDI::
    ix () const
    {
      return this->ix_;
    }

    tSDI::ix_optional& tSDI::
    ix ()
    {
      return this->ix_;
    }

    void tSDI::
    ix (const ix_type& x)
    {
      this->ix_.set (x);
    }

    void tSDI::
    ix (const ix_optional& x)
    {
      this->ix_ = x;
    }


    // tDAI
    // 

    const tDAI::Val_sequence& tDAI::
    Val () const
    {
      return this->Val_;
    }

    tDAI::Val_sequence& tDAI::
    Val ()
    {
      return this->Val_;
    }

    void tDAI::
    Val (const Val_sequence& s)
    {
      this->Val_ = s;
    }

    const tDAI::name_type& tDAI::
    name () const
    {
      return this->name_.get ();
    }

    tDAI::name_type& tDAI::
    name ()
    {
      return this->name_.get ();
    }

    void tDAI::
    name (const name_type& x)
    {
      this->name_.set (x);
    }

    void tDAI::
    name (::std::auto_ptr< name_type > x)
    {
      this->name_.set (x);
    }

    const tDAI::sAddr_optional& tDAI::
    sAddr () const
    {
      return this->sAddr_;
    }

    tDAI::sAddr_optional& tDAI::
    sAddr ()
    {
      return this->sAddr_;
    }

    void tDAI::
    sAddr (const sAddr_type& x)
    {
      this->sAddr_.set (x);
    }

    void tDAI::
    sAddr (const sAddr_optional& x)
    {
      this->sAddr_ = x;
    }

    void tDAI::
    sAddr (::std::auto_ptr< sAddr_type > x)
    {
      this->sAddr_.set (x);
    }

    const tDAI::valKind_type& tDAI::
    valKind () const
    {
      return this->valKind_.get ();
    }

    tDAI::valKind_type& tDAI::
    valKind ()
    {
      return this->valKind_.get ();
    }

    void tDAI::
    valKind (const valKind_type& x)
    {
      this->valKind_.set (x);
    }

    void tDAI::
    valKind (::std::auto_ptr< valKind_type > x)
    {
      this->valKind_.set (x);
    }

    const tDAI::valKind_type& tDAI::
    valKind_default_value ()
    {
      return valKind_default_value_;
    }

    const tDAI::ix_optional& tDAI::
    ix () const
    {
      return this->ix_;
    }

    tDAI::ix_optional& tDAI::
    ix ()
    {
      return this->ix_;
    }

    void tDAI::
    ix (const ix_type& x)
    {
      this->ix_.set (x);
    }

    void tDAI::
    ix (const ix_optional& x)
    {
      this->ix_ = x;
    }


    // tServiceYesNo
    // 


    // tServiceWithMax
    // 

    const tServiceWithMax::max_type& tServiceWithMax::
    max () const
    {
      return this->max_.get ();
    }

    tServiceWithMax::max_type& tServiceWithMax::
    max ()
    {
      return this->max_.get ();
    }

    void tServiceWithMax::
    max (const max_type& x)
    {
      this->max_.set (x);
    }


    // tServiceWithMaxAndMaxAttributes
    // 

    const tServiceWithMaxAndMaxAttributes::maxAttributes_optional& tServiceWithMaxAndMaxAttributes::
    maxAttributes () const
    {
      return this->maxAttributes_;
    }

    tServiceWithMaxAndMaxAttributes::maxAttributes_optional& tServiceWithMaxAndMaxAttributes::
    maxAttributes ()
    {
      return this->maxAttributes_;
    }

    void tServiceWithMaxAndMaxAttributes::
    maxAttributes (const maxAttributes_type& x)
    {
      this->maxAttributes_.set (x);
    }

    void tServiceWithMaxAndMaxAttributes::
    maxAttributes (const maxAttributes_optional& x)
    {
      this->maxAttributes_ = x;
    }


    // tServiceWithMaxAndModify
    // 

    const tServiceWithMaxAndModify::modify_type& tServiceWithMaxAndModify::
    modify () const
    {
      return this->modify_.get ();
    }

    tServiceWithMaxAndModify::modify_type& tServiceWithMaxAndModify::
    modify ()
    {
      return this->modify_.get ();
    }

    void tServiceWithMaxAndModify::
    modify (const modify_type& x)
    {
      this->modify_.set (x);
    }

    const tServiceWithMaxAndModify::modify_type& tServiceWithMaxAndModify::
    modify_default_value ()
    {
      return modify_default_value_;
    }


    // tServiceWithMaxAndMaxAttributesAndModify
    // 

    const tServiceWithMaxAndMaxAttributesAndModify::modify_type& tServiceWithMaxAndMaxAttributesAndModify::
    modify () const
    {
      return this->modify_.get ();
    }

    tServiceWithMaxAndMaxAttributesAndModify::modify_type& tServiceWithMaxAndMaxAttributesAndModify::
    modify ()
    {
      return this->modify_.get ();
    }

    void tServiceWithMaxAndMaxAttributesAndModify::
    modify (const modify_type& x)
    {
      this->modify_.set (x);
    }

    const tServiceWithMaxAndMaxAttributesAndModify::modify_type& tServiceWithMaxAndMaxAttributesAndModify::
    modify_default_value ()
    {
      return modify_default_value_;
    }


    // tClientServices
    // 

    const tClientServices::goose_type& tClientServices::
    goose () const
    {
      return this->goose_.get ();
    }

    tClientServices::goose_type& tClientServices::
    goose ()
    {
      return this->goose_.get ();
    }

    void tClientServices::
    goose (const goose_type& x)
    {
      this->goose_.set (x);
    }

    const tClientServices::goose_type& tClientServices::
    goose_default_value ()
    {
      return goose_default_value_;
    }

    const tClientServices::gsse_type& tClientServices::
    gsse () const
    {
      return this->gsse_.get ();
    }

    tClientServices::gsse_type& tClientServices::
    gsse ()
    {
      return this->gsse_.get ();
    }

    void tClientServices::
    gsse (const gsse_type& x)
    {
      this->gsse_.set (x);
    }

    const tClientServices::gsse_type& tClientServices::
    gsse_default_value ()
    {
      return gsse_default_value_;
    }

    const tClientServices::bufReport_type& tClientServices::
    bufReport () const
    {
      return this->bufReport_.get ();
    }

    tClientServices::bufReport_type& tClientServices::
    bufReport ()
    {
      return this->bufReport_.get ();
    }

    void tClientServices::
    bufReport (const bufReport_type& x)
    {
      this->bufReport_.set (x);
    }

    const tClientServices::bufReport_type& tClientServices::
    bufReport_default_value ()
    {
      return bufReport_default_value_;
    }

    const tClientServices::unbufReport_type& tClientServices::
    unbufReport () const
    {
      return this->unbufReport_.get ();
    }

    tClientServices::unbufReport_type& tClientServices::
    unbufReport ()
    {
      return this->unbufReport_.get ();
    }

    void tClientServices::
    unbufReport (const unbufReport_type& x)
    {
      this->unbufReport_.set (x);
    }

    const tClientServices::unbufReport_type& tClientServices::
    unbufReport_default_value ()
    {
      return unbufReport_default_value_;
    }

    const tClientServices::readLog_type& tClientServices::
    readLog () const
    {
      return this->readLog_.get ();
    }

    tClientServices::readLog_type& tClientServices::
    readLog ()
    {
      return this->readLog_.get ();
    }

    void tClientServices::
    readLog (const readLog_type& x)
    {
      this->readLog_.set (x);
    }

    const tClientServices::readLog_type& tClientServices::
    readLog_default_value ()
    {
      return readLog_default_value_;
    }


    // tServiceSettings
    // 

    const tServiceSettings::cbName_type& tServiceSettings::
    cbName () const
    {
      return this->cbName_.get ();
    }

    tServiceSettings::cbName_type& tServiceSettings::
    cbName ()
    {
      return this->cbName_.get ();
    }

    void tServiceSettings::
    cbName (const cbName_type& x)
    {
      this->cbName_.set (x);
    }

    void tServiceSettings::
    cbName (::std::auto_ptr< cbName_type > x)
    {
      this->cbName_.set (x);
    }

    const tServiceSettings::cbName_type& tServiceSettings::
    cbName_default_value ()
    {
      return cbName_default_value_;
    }

    const tServiceSettings::datSet_type& tServiceSettings::
    datSet () const
    {
      return this->datSet_.get ();
    }

    tServiceSettings::datSet_type& tServiceSettings::
    datSet ()
    {
      return this->datSet_.get ();
    }

    void tServiceSettings::
    datSet (const datSet_type& x)
    {
      this->datSet_.set (x);
    }

    void tServiceSettings::
    datSet (::std::auto_ptr< datSet_type > x)
    {
      this->datSet_.set (x);
    }

    const tServiceSettings::datSet_type& tServiceSettings::
    datSet_default_value ()
    {
      return datSet_default_value_;
    }


    // tReportSettings
    // 

    const tReportSettings::rptID_type& tReportSettings::
    rptID () const
    {
      return this->rptID_.get ();
    }

    tReportSettings::rptID_type& tReportSettings::
    rptID ()
    {
      return this->rptID_.get ();
    }

    void tReportSettings::
    rptID (const rptID_type& x)
    {
      this->rptID_.set (x);
    }

    void tReportSettings::
    rptID (::std::auto_ptr< rptID_type > x)
    {
      this->rptID_.set (x);
    }

    const tReportSettings::rptID_type& tReportSettings::
    rptID_default_value ()
    {
      return rptID_default_value_;
    }

    const tReportSettings::optFields_type& tReportSettings::
    optFields () const
    {
      return this->optFields_.get ();
    }

    tReportSettings::optFields_type& tReportSettings::
    optFields ()
    {
      return this->optFields_.get ();
    }

    void tReportSettings::
    optFields (const optFields_type& x)
    {
      this->optFields_.set (x);
    }

    void tReportSettings::
    optFields (::std::auto_ptr< optFields_type > x)
    {
      this->optFields_.set (x);
    }

    const tReportSettings::optFields_type& tReportSettings::
    optFields_default_value ()
    {
      return optFields_default_value_;
    }

    const tReportSettings::bufTime_type& tReportSettings::
    bufTime () const
    {
      return this->bufTime_.get ();
    }

    tReportSettings::bufTime_type& tReportSettings::
    bufTime ()
    {
      return this->bufTime_.get ();
    }

    void tReportSettings::
    bufTime (const bufTime_type& x)
    {
      this->bufTime_.set (x);
    }

    void tReportSettings::
    bufTime (::std::auto_ptr< bufTime_type > x)
    {
      this->bufTime_.set (x);
    }

    const tReportSettings::bufTime_type& tReportSettings::
    bufTime_default_value ()
    {
      return bufTime_default_value_;
    }

    const tReportSettings::trgOps_type& tReportSettings::
    trgOps () const
    {
      return this->trgOps_.get ();
    }

    tReportSettings::trgOps_type& tReportSettings::
    trgOps ()
    {
      return this->trgOps_.get ();
    }

    void tReportSettings::
    trgOps (const trgOps_type& x)
    {
      this->trgOps_.set (x);
    }

    void tReportSettings::
    trgOps (::std::auto_ptr< trgOps_type > x)
    {
      this->trgOps_.set (x);
    }

    const tReportSettings::trgOps_type& tReportSettings::
    trgOps_default_value ()
    {
      return trgOps_default_value_;
    }

    const tReportSettings::intgPd_type& tReportSettings::
    intgPd () const
    {
      return this->intgPd_.get ();
    }

    tReportSettings::intgPd_type& tReportSettings::
    intgPd ()
    {
      return this->intgPd_.get ();
    }

    void tReportSettings::
    intgPd (const intgPd_type& x)
    {
      this->intgPd_.set (x);
    }

    void tReportSettings::
    intgPd (::std::auto_ptr< intgPd_type > x)
    {
      this->intgPd_.set (x);
    }

    const tReportSettings::intgPd_type& tReportSettings::
    intgPd_default_value ()
    {
      return intgPd_default_value_;
    }


    // tLogSettings
    // 

    const tLogSettings::logEna_type& tLogSettings::
    logEna () const
    {
      return this->logEna_.get ();
    }

    tLogSettings::logEna_type& tLogSettings::
    logEna ()
    {
      return this->logEna_.get ();
    }

    void tLogSettings::
    logEna (const logEna_type& x)
    {
      this->logEna_.set (x);
    }

    void tLogSettings::
    logEna (::std::auto_ptr< logEna_type > x)
    {
      this->logEna_.set (x);
    }

    const tLogSettings::logEna_type& tLogSettings::
    logEna_default_value ()
    {
      return logEna_default_value_;
    }

    const tLogSettings::trgOps_type& tLogSettings::
    trgOps () const
    {
      return this->trgOps_.get ();
    }

    tLogSettings::trgOps_type& tLogSettings::
    trgOps ()
    {
      return this->trgOps_.get ();
    }

    void tLogSettings::
    trgOps (const trgOps_type& x)
    {
      this->trgOps_.set (x);
    }

    void tLogSettings::
    trgOps (::std::auto_ptr< trgOps_type > x)
    {
      this->trgOps_.set (x);
    }

    const tLogSettings::trgOps_type& tLogSettings::
    trgOps_default_value ()
    {
      return trgOps_default_value_;
    }

    const tLogSettings::intgPd_type& tLogSettings::
    intgPd () const
    {
      return this->intgPd_.get ();
    }

    tLogSettings::intgPd_type& tLogSettings::
    intgPd ()
    {
      return this->intgPd_.get ();
    }

    void tLogSettings::
    intgPd (const intgPd_type& x)
    {
      this->intgPd_.set (x);
    }

    void tLogSettings::
    intgPd (::std::auto_ptr< intgPd_type > x)
    {
      this->intgPd_.set (x);
    }

    const tLogSettings::intgPd_type& tLogSettings::
    intgPd_default_value ()
    {
      return intgPd_default_value_;
    }


    // tGSESettings
    // 

    const tGSESettings::appID_type& tGSESettings::
    appID () const
    {
      return this->appID_.get ();
    }

    tGSESettings::appID_type& tGSESettings::
    appID ()
    {
      return this->appID_.get ();
    }

    void tGSESettings::
    appID (const appID_type& x)
    {
      this->appID_.set (x);
    }

    void tGSESettings::
    appID (::std::auto_ptr< appID_type > x)
    {
      this->appID_.set (x);
    }

    const tGSESettings::appID_type& tGSESettings::
    appID_default_value ()
    {
      return appID_default_value_;
    }

    const tGSESettings::dataLabel_type& tGSESettings::
    dataLabel () const
    {
      return this->dataLabel_.get ();
    }

    tGSESettings::dataLabel_type& tGSESettings::
    dataLabel ()
    {
      return this->dataLabel_.get ();
    }

    void tGSESettings::
    dataLabel (const dataLabel_type& x)
    {
      this->dataLabel_.set (x);
    }

    void tGSESettings::
    dataLabel (::std::auto_ptr< dataLabel_type > x)
    {
      this->dataLabel_.set (x);
    }

    const tGSESettings::dataLabel_type& tGSESettings::
    dataLabel_default_value ()
    {
      return dataLabel_default_value_;
    }


    // tSMVSettings
    // 

    const tSMVSettings::SmpRate_sequence& tSMVSettings::
    SmpRate () const
    {
      return this->SmpRate_;
    }

    tSMVSettings::SmpRate_sequence& tSMVSettings::
    SmpRate ()
    {
      return this->SmpRate_;
    }

    void tSMVSettings::
    SmpRate (const SmpRate_sequence& s)
    {
      this->SmpRate_ = s;
    }

    const tSMVSettings::svID_type& tSMVSettings::
    svID () const
    {
      return this->svID_.get ();
    }

    tSMVSettings::svID_type& tSMVSettings::
    svID ()
    {
      return this->svID_.get ();
    }

    void tSMVSettings::
    svID (const svID_type& x)
    {
      this->svID_.set (x);
    }

    void tSMVSettings::
    svID (::std::auto_ptr< svID_type > x)
    {
      this->svID_.set (x);
    }

    const tSMVSettings::svID_type& tSMVSettings::
    svID_default_value ()
    {
      return svID_default_value_;
    }

    const tSMVSettings::optFields_type& tSMVSettings::
    optFields () const
    {
      return this->optFields_.get ();
    }

    tSMVSettings::optFields_type& tSMVSettings::
    optFields ()
    {
      return this->optFields_.get ();
    }

    void tSMVSettings::
    optFields (const optFields_type& x)
    {
      this->optFields_.set (x);
    }

    void tSMVSettings::
    optFields (::std::auto_ptr< optFields_type > x)
    {
      this->optFields_.set (x);
    }

    const tSMVSettings::optFields_type& tSMVSettings::
    optFields_default_value ()
    {
      return optFields_default_value_;
    }

    const tSMVSettings::smpRate_type& tSMVSettings::
    smpRate () const
    {
      return this->smpRate_.get ();
    }

    tSMVSettings::smpRate_type& tSMVSettings::
    smpRate ()
    {
      return this->smpRate_.get ();
    }

    void tSMVSettings::
    smpRate (const smpRate_type& x)
    {
      this->smpRate_.set (x);
    }

    void tSMVSettings::
    smpRate (::std::auto_ptr< smpRate_type > x)
    {
      this->smpRate_.set (x);
    }

    const tSMVSettings::smpRate_type& tSMVSettings::
    smpRate_default_value ()
    {
      return smpRate_default_value_;
    }


    // tConfLNs
    // 

    const tConfLNs::fixPrefix_type& tConfLNs::
    fixPrefix () const
    {
      return this->fixPrefix_.get ();
    }

    tConfLNs::fixPrefix_type& tConfLNs::
    fixPrefix ()
    {
      return this->fixPrefix_.get ();
    }

    void tConfLNs::
    fixPrefix (const fixPrefix_type& x)
    {
      this->fixPrefix_.set (x);
    }

    const tConfLNs::fixPrefix_type& tConfLNs::
    fixPrefix_default_value ()
    {
      return fixPrefix_default_value_;
    }

    const tConfLNs::fixLnInst_type& tConfLNs::
    fixLnInst () const
    {
      return this->fixLnInst_.get ();
    }

    tConfLNs::fixLnInst_type& tConfLNs::
    fixLnInst ()
    {
      return this->fixLnInst_.get ();
    }

    void tConfLNs::
    fixLnInst (const fixLnInst_type& x)
    {
      this->fixLnInst_.set (x);
    }

    const tConfLNs::fixLnInst_type& tConfLNs::
    fixLnInst_default_value ()
    {
      return fixLnInst_default_value_;
    }


    // SettingGroups
    // 

    const SettingGroups::SGEdit_optional& SettingGroups::
    SGEdit () const
    {
      return this->SGEdit_;
    }

    SettingGroups::SGEdit_optional& SettingGroups::
    SGEdit ()
    {
      return this->SGEdit_;
    }

    void SettingGroups::
    SGEdit (const SGEdit_type& x)
    {
      this->SGEdit_.set (x);
    }

    void SettingGroups::
    SGEdit (const SGEdit_optional& x)
    {
      this->SGEdit_ = x;
    }

    void SettingGroups::
    SGEdit (::std::auto_ptr< SGEdit_type > x)
    {
      this->SGEdit_.set (x);
    }

    const SettingGroups::ConfSG_optional& SettingGroups::
    ConfSG () const
    {
      return this->ConfSG_;
    }

    SettingGroups::ConfSG_optional& SettingGroups::
    ConfSG ()
    {
      return this->ConfSG_;
    }

    void SettingGroups::
    ConfSG (const ConfSG_type& x)
    {
      this->ConfSG_.set (x);
    }

    void SettingGroups::
    ConfSG (const ConfSG_optional& x)
    {
      this->ConfSG_ = x;
    }

    void SettingGroups::
    ConfSG (::std::auto_ptr< ConfSG_type > x)
    {
      this->ConfSG_.set (x);
    }


    // Authentication
    // 

    const Authentication::none_type& Authentication::
    none () const
    {
      return this->none_.get ();
    }

    Authentication::none_type& Authentication::
    none ()
    {
      return this->none_.get ();
    }

    void Authentication::
    none (const none_type& x)
    {
      this->none_.set (x);
    }

    const Authentication::none_type& Authentication::
    none_default_value ()
    {
      return none_default_value_;
    }

    const Authentication::password_type& Authentication::
    password () const
    {
      return this->password_.get ();
    }

    Authentication::password_type& Authentication::
    password ()
    {
      return this->password_.get ();
    }

    void Authentication::
    password (const password_type& x)
    {
      this->password_.set (x);
    }

    const Authentication::password_type& Authentication::
    password_default_value ()
    {
      return password_default_value_;
    }

    const Authentication::weak_type& Authentication::
    weak () const
    {
      return this->weak_.get ();
    }

    Authentication::weak_type& Authentication::
    weak ()
    {
      return this->weak_.get ();
    }

    void Authentication::
    weak (const weak_type& x)
    {
      this->weak_.set (x);
    }

    const Authentication::weak_type& Authentication::
    weak_default_value ()
    {
      return weak_default_value_;
    }

    const Authentication::strong_type& Authentication::
    strong () const
    {
      return this->strong_.get ();
    }

    Authentication::strong_type& Authentication::
    strong ()
    {
      return this->strong_.get ();
    }

    void Authentication::
    strong (const strong_type& x)
    {
      this->strong_.set (x);
    }

    const Authentication::strong_type& Authentication::
    strong_default_value ()
    {
      return strong_default_value_;
    }

    const Authentication::certificate_type& Authentication::
    certificate () const
    {
      return this->certificate_.get ();
    }

    Authentication::certificate_type& Authentication::
    certificate ()
    {
      return this->certificate_.get ();
    }

    void Authentication::
    certificate (const certificate_type& x)
    {
      this->certificate_.set (x);
    }

    const Authentication::certificate_type& Authentication::
    certificate_default_value ()
    {
      return certificate_default_value_;
    }


    // LN0
    // 


    // OptFields
    // 

    const OptFields::seqNum_type& OptFields::
    seqNum () const
    {
      return this->seqNum_.get ();
    }

    OptFields::seqNum_type& OptFields::
    seqNum ()
    {
      return this->seqNum_.get ();
    }

    void OptFields::
    seqNum (const seqNum_type& x)
    {
      this->seqNum_.set (x);
    }

    const OptFields::seqNum_type& OptFields::
    seqNum_default_value ()
    {
      return seqNum_default_value_;
    }

    const OptFields::timeStamp_type& OptFields::
    timeStamp () const
    {
      return this->timeStamp_.get ();
    }

    OptFields::timeStamp_type& OptFields::
    timeStamp ()
    {
      return this->timeStamp_.get ();
    }

    void OptFields::
    timeStamp (const timeStamp_type& x)
    {
      this->timeStamp_.set (x);
    }

    const OptFields::timeStamp_type& OptFields::
    timeStamp_default_value ()
    {
      return timeStamp_default_value_;
    }

    const OptFields::dataSet_type& OptFields::
    dataSet () const
    {
      return this->dataSet_.get ();
    }

    OptFields::dataSet_type& OptFields::
    dataSet ()
    {
      return this->dataSet_.get ();
    }

    void OptFields::
    dataSet (const dataSet_type& x)
    {
      this->dataSet_.set (x);
    }

    const OptFields::dataSet_type& OptFields::
    dataSet_default_value ()
    {
      return dataSet_default_value_;
    }

    const OptFields::reasonCode_type& OptFields::
    reasonCode () const
    {
      return this->reasonCode_.get ();
    }

    OptFields::reasonCode_type& OptFields::
    reasonCode ()
    {
      return this->reasonCode_.get ();
    }

    void OptFields::
    reasonCode (const reasonCode_type& x)
    {
      this->reasonCode_.set (x);
    }

    const OptFields::reasonCode_type& OptFields::
    reasonCode_default_value ()
    {
      return reasonCode_default_value_;
    }

    const OptFields::dataRef_type& OptFields::
    dataRef () const
    {
      return this->dataRef_.get ();
    }

    OptFields::dataRef_type& OptFields::
    dataRef ()
    {
      return this->dataRef_.get ();
    }

    void OptFields::
    dataRef (const dataRef_type& x)
    {
      this->dataRef_.set (x);
    }

    const OptFields::dataRef_type& OptFields::
    dataRef_default_value ()
    {
      return dataRef_default_value_;
    }

    const OptFields::entryID_type& OptFields::
    entryID () const
    {
      return this->entryID_.get ();
    }

    OptFields::entryID_type& OptFields::
    entryID ()
    {
      return this->entryID_.get ();
    }

    void OptFields::
    entryID (const entryID_type& x)
    {
      this->entryID_.set (x);
    }

    const OptFields::entryID_type& OptFields::
    entryID_default_value ()
    {
      return entryID_default_value_;
    }

    const OptFields::configRef_type& OptFields::
    configRef () const
    {
      return this->configRef_.get ();
    }

    OptFields::configRef_type& OptFields::
    configRef ()
    {
      return this->configRef_.get ();
    }

    void OptFields::
    configRef (const configRef_type& x)
    {
      this->configRef_.set (x);
    }

    const OptFields::configRef_type& OptFields::
    configRef_default_value ()
    {
      return configRef_default_value_;
    }


    // SmvOpts
    // 

    const SmvOpts::refreshTime_type& SmvOpts::
    refreshTime () const
    {
      return this->refreshTime_.get ();
    }

    SmvOpts::refreshTime_type& SmvOpts::
    refreshTime ()
    {
      return this->refreshTime_.get ();
    }

    void SmvOpts::
    refreshTime (const refreshTime_type& x)
    {
      this->refreshTime_.set (x);
    }

    const SmvOpts::refreshTime_type& SmvOpts::
    refreshTime_default_value ()
    {
      return refreshTime_default_value_;
    }

    const SmvOpts::sampleSynchronized_type& SmvOpts::
    sampleSynchronized () const
    {
      return this->sampleSynchronized_.get ();
    }

    const SmvOpts::sampleSynchronized_type& SmvOpts::
    sampleSynchronized_default_value ()
    {
      return sampleSynchronized_default_value_;
    }

    const SmvOpts::sampleRate_type& SmvOpts::
    sampleRate () const
    {
      return this->sampleRate_.get ();
    }

    SmvOpts::sampleRate_type& SmvOpts::
    sampleRate ()
    {
      return this->sampleRate_.get ();
    }

    void SmvOpts::
    sampleRate (const sampleRate_type& x)
    {
      this->sampleRate_.set (x);
    }

    const SmvOpts::sampleRate_type& SmvOpts::
    sampleRate_default_value ()
    {
      return sampleRate_default_value_;
    }

    const SmvOpts::dataSet_type& SmvOpts::
    dataSet () const
    {
      return this->dataSet_.get ();
    }

    SmvOpts::dataSet_type& SmvOpts::
    dataSet ()
    {
      return this->dataSet_.get ();
    }

    void SmvOpts::
    dataSet (const dataSet_type& x)
    {
      this->dataSet_.set (x);
    }

    const SmvOpts::dataSet_type& SmvOpts::
    dataSet_default_value ()
    {
      return dataSet_default_value_;
    }

    const SmvOpts::security_type& SmvOpts::
    security () const
    {
      return this->security_.get ();
    }

    SmvOpts::security_type& SmvOpts::
    security ()
    {
      return this->security_.get ();
    }

    void SmvOpts::
    security (const security_type& x)
    {
      this->security_.set (x);
    }

    const SmvOpts::security_type& SmvOpts::
    security_default_value ()
    {
      return security_default_value_;
    }


    // SmpRate
    // 
  }
}

#include <xsd/cxx/xml/dom/parsing-source.hxx>

namespace IEC61850
{
  namespace SCL
  {
    // tIED
    //

    tIED::
    tIED (const name_type& name)
    : ::IEC61850::SCL::tNaming (name),
      Services_ (::xml_schema::flags (), this),
      AccessPoint_ (::xml_schema::flags (), this),
      type_ (::xml_schema::flags (), this),
      manufacturer_ (::xml_schema::flags (), this),
      configVersion_ (::xml_schema::flags (), this)
    {
    }

    tIED::
    tIED (const tIED& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
    : ::IEC61850::SCL::tNaming (x, f, c),
      Services_ (x.Services_, f, this),
      AccessPoint_ (x.AccessPoint_, f, this),
      type_ (x.type_, f, this),
      manufacturer_ (x.manufacturer_, f, this),
      configVersion_ (x.configVersion_, f, this)
    {
    }

    tIED::
    tIED (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
    : ::IEC61850::SCL::tNaming (e, f | ::xml_schema::flags::base, c),
      Services_ (f, this),
      AccessPoint_ (f, this),
      type_ (f, this),
      manufacturer_ (f, this),
      configVersion_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void tIED::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::IEC61850::SCL::tNaming::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Services
        //
        if (n.name () == "Services" && n.namespace_ () == "http://www.iec.ch/61850/2003/SCL")
        {
          ::std::auto_ptr< Services_type > r (
            Services_traits::create (i, f, this));

          if (!this->Services_)
          {
            this->Services_.set (r);
            continue;
          }
        }

        // AccessPoint
        //
        if (n.name () == "AccessPoint" && n.namespace_ () == "http://www.iec.ch/61850/2003/SCL")
        {
          ::std::auto_ptr< AccessPoint_type > r (
            AccessPoint_traits::create (i, f, this));

          this->AccessPoint_.push_back (r);
          continue;
        }

        break;
      }

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "type" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< type_type > r (
            type_traits::create (i, f, this));

          this->type_.set (r);
          continue;
        }

        if (n.name () == "manufacturer" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< manufacturer_type > r (
            manufacturer_traits::create (i, f, this));

          this->manufacturer_.set (r);
          continue;
        }

        if (n.name () == "configVersion" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< configVersion_type > r (
            configVersion_traits::create (i, f, this));

          this->configVersion_.set (r);
          continue;
        }
      }
    }

    tIED* tIED::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class tIED (*this, f, c);
    }

    tIED::
    ~tIED ()
    {
    }

    // tServices
    //

    tServices::
    tServices ()
    : ::xml_schema::type (),
      DynAssociation_ (::xml_schema::flags (), this),
      SettingGroups_ (::xml_schema::flags (), this),
      GetDirectory_ (::xml_schema::flags (), this),
      GetDataObjectDefinition_ (::xml_schema::flags (), this),
      DataObjectDirectory_ (::xml_schema::flags (), this),
      GetDataSetValue_ (::xml_schema::flags (), this),
      SetDataSetValue_ (::xml_schema::flags (), this),
      DataSetDirectory_ (::xml_schema::flags (), this),
      ConfDataSet_ (::xml_schema::flags (), this),
      DynDataSet_ (::xml_schema::flags (), this),
      ReadWrite_ (::xml_schema::flags (), this),
      TimerActivatedControl_ (::xml_schema::flags (), this),
      ConfReportControl_ (::xml_schema::flags (), this),
      GetCBValues_ (::xml_schema::flags (), this),
      ConfLogControl_ (::xml_schema::flags (), this),
      ReportSettings_ (::xml_schema::flags (), this),
      LogSettings_ (::xml_schema::flags (), this),
      GSESettings_ (::xml_schema::flags (), this),
      SMVSettings_ (::xml_schema::flags (), this),
      GSEDir_ (::xml_schema::flags (), this),
      GOOSE_ (::xml_schema::flags (), this),
      GSSE_ (::xml_schema::flags (), this),
      FileHandling_ (::xml_schema::flags (), this),
      ConfLNs_ (::xml_schema::flags (), this),
      ClientServices_ (::xml_schema::flags (), this)
    {
    }

    tServices::
    tServices (const tServices& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      DynAssociation_ (x.DynAssociation_, f, this),
      SettingGroups_ (x.SettingGroups_, f, this),
      GetDirectory_ (x.GetDirectory_, f, this),
      GetDataObjectDefinition_ (x.GetDataObjectDefinition_, f, this),
      DataObjectDirectory_ (x.DataObjectDirectory_, f, this),
      GetDataSetValue_ (x.GetDataSetValue_, f, this),
      SetDataSetValue_ (x.SetDataSetValue_, f, this),
      DataSetDirectory_ (x.DataSetDirectory_, f, this),
      ConfDataSet_ (x.ConfDataSet_, f, this),
      DynDataSet_ (x.DynDataSet_, f, this),
      ReadWrite_ (x.ReadWrite_, f, this),
      TimerActivatedControl_ (x.TimerActivatedControl_, f, this),
      ConfReportControl_ (x.ConfReportControl_, f, this),
      GetCBValues_ (x.GetCBValues_, f, this),
      ConfLogControl_ (x.ConfLogControl_, f, this),
      ReportSettings_ (x.ReportSettings_, f, this),
      LogSettings_ (x.LogSettings_, f, this),
      GSESettings_ (x.GSESettings_, f, this),
      SMVSettings_ (x.SMVSettings_, f, this),
      GSEDir_ (x.GSEDir_, f, this),
      GOOSE_ (x.GOOSE_, f, this),
      GSSE_ (x.GSSE_, f, this),
      FileHandling_ (x.FileHandling_, f, this),
      ConfLNs_ (x.ConfLNs_, f, this),
      ClientServices_ (x.ClientServices_, f, this)
    {
    }

    tServices::
    tServices (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      DynAssociation_ (f, this),
      SettingGroups_ (f, this),
      GetDirectory_ (f, this),
      GetDataObjectDefinition_ (f, this),
      DataObjectDirectory_ (f, this),
      GetDataSetValue_ (f, this),
      SetDataSetValue_ (f, this),
      DataSetDirectory_ (f, this),
      ConfDataSet_ (f, this),
      DynDataSet_ (f, this),
      ReadWrite_ (f, this),
      TimerActivatedControl_ (f, this),
      ConfReportControl_ (f, this),
      GetCBValues_ (f, this),
      ConfLogControl_ (f, this),
      ReportSettings_ (f, this),
      LogSettings_ (f, this),
      GSESettings_ (f, this),
      SMVSettings_ (f, this),
      GSEDir_ (f, this),
      GOOSE_ (f, this),
      GSSE_ (f, this),
      FileHandling_ (f, this),
      ConfLNs_ (f, this),
      ClientServices_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void tServices::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // DynAssociation
        //
        if (n.name () == "DynAssociation" && n.namespace_ () == "http://www.iec.ch/61850/2003/SCL")
        {
          ::std::auto_ptr< DynAssociation_type > r (
            DynAssociation_traits::create (i, f, this));

          if (!this->DynAssociation_)
          {
            this->DynAssociation_.set (r);
            continue;
          }
        }

        // SettingGroups
        //
        if (n.name () == "SettingGroups" && n.namespace_ () == "http://www.iec.ch/61850/2003/SCL")
        {
          ::std::auto_ptr< SettingGroups_type > r (
            SettingGroups_traits::create (i, f, this));

          if (!this->SettingGroups_)
          {
            this->SettingGroups_.set (r);
            continue;
          }
        }

        // GetDirectory
        //
        if (n.name () == "GetDirectory" && n.namespace_ () == "http://www.iec.ch/61850/2003/SCL")
        {
          ::std::auto_ptr< GetDirectory_type > r (
            GetDirectory_traits::create (i, f, this));

          if (!this->GetDirectory_)
          {
            this->GetDirectory_.set (r);
            continue;
          }
        }

        // GetDataObjectDefinition
        //
        if (n.name () == "GetDataObjectDefinition" && n.namespace_ () == "http://www.iec.ch/61850/2003/SCL")
        {
          ::std::auto_ptr< GetDataObjectDefinition_type > r (
            GetDataObjectDefinition_traits::create (i, f, this));

          if (!this->GetDataObjectDefinition_)
          {
            this->GetDataObjectDefinition_.set (r);
            continue;
          }
        }

        // DataObjectDirectory
        //
        if (n.name () == "DataObjectDirectory" && n.namespace_ () == "http://www.iec.ch/61850/2003/SCL")
        {
          ::std::auto_ptr< DataObjectDirectory_type > r (
            DataObjectDirectory_traits::create (i, f, this));

          if (!this->DataObjectDirectory_)
          {
            this->DataObjectDirectory_.set (r);
            continue;
          }
        }

        // GetDataSetValue
        //
        if (n.name () == "GetDataSetValue" && n.namespace_ () == "http://www.iec.ch/61850/2003/SCL")
        {
          ::std::auto_ptr< GetDataSetValue_type > r (
            GetDataSetValue_traits::create (i, f, this));

          if (!this->GetDataSetValue_)
          {
            this->GetDataSetValue_.set (r);
            continue;
          }
        }

        // SetDataSetValue
        //
        if (n.name () == "SetDataSetValue" && n.namespace_ () == "http://www.iec.ch/61850/2003/SCL")
        {
          ::std::auto_ptr< SetDataSetValue_type > r (
            SetDataSetValue_traits::create (i, f, this));

          if (!this->SetDataSetValue_)
          {
            this->SetDataSetValue_.set (r);
            continue;
          }
        }

        // DataSetDirectory
        //
        if (n.name () == "DataSetDirectory" && n.namespace_ () == "http://www.iec.ch/61850/2003/SCL")
        {
          ::std::auto_ptr< DataSetDirectory_type > r (
            DataSetDirectory_traits::create (i, f, this));

          if (!this->DataSetDirectory_)
          {
            this->DataSetDirectory_.set (r);
            continue;
          }
        }

        // ConfDataSet
        //
        if (n.name () == "ConfDataSet" && n.namespace_ () == "http://www.iec.ch/61850/2003/SCL")
        {
          ::std::auto_ptr< ConfDataSet_type > r (
            ConfDataSet_traits::create (i, f, this));

          if (!this->ConfDataSet_)
          {
            this->ConfDataSet_.set (r);
            continue;
          }
        }

        // DynDataSet
        //
        if (n.name () == "DynDataSet" && n.namespace_ () == "http://www.iec.ch/61850/2003/SCL")
        {
          ::std::auto_ptr< DynDataSet_type > r (
            DynDataSet_traits::create (i, f, this));

          if (!this->DynDataSet_)
          {
            this->DynDataSet_.set (r);
            continue;
          }
        }

        // ReadWrite
        //
        if (n.name () == "ReadWrite" && n.namespace_ () == "http://www.iec.ch/61850/2003/SCL")
        {
          ::std::auto_ptr< ReadWrite_type > r (
            ReadWrite_traits::create (i, f, this));

          if (!this->ReadWrite_)
          {
            this->ReadWrite_.set (r);
            continue;
          }
        }

        // TimerActivatedControl
        //
        if (n.name () == "TimerActivatedControl" && n.namespace_ () == "http://www.iec.ch/61850/2003/SCL")
        {
          ::std::auto_ptr< TimerActivatedControl_type > r (
            TimerActivatedControl_traits::create (i, f, this));

          if (!this->TimerActivatedControl_)
          {
            this->TimerActivatedControl_.set (r);
            continue;
          }
        }

        // ConfReportControl
        //
        if (n.name () == "ConfReportControl" && n.namespace_ () == "http://www.iec.ch/61850/2003/SCL")
        {
          ::std::auto_ptr< ConfReportControl_type > r (
            ConfReportControl_traits::create (i, f, this));

          if (!this->ConfReportControl_)
          {
            this->ConfReportControl_.set (r);
            continue;
          }
        }

        // GetCBValues
        //
        if (n.name () == "GetCBValues" && n.namespace_ () == "http://www.iec.ch/61850/2003/SCL")
        {
          ::std::auto_ptr< GetCBValues_type > r (
            GetCBValues_traits::create (i, f, this));

          if (!this->GetCBValues_)
          {
            this->GetCBValues_.set (r);
            continue;
          }
        }

        // ConfLogControl
        //
        if (n.name () == "ConfLogControl" && n.namespace_ () == "http://www.iec.ch/61850/2003/SCL")
        {
          ::std::auto_ptr< ConfLogControl_type > r (
            ConfLogControl_traits::create (i, f, this));

          if (!this->ConfLogControl_)
          {
            this->ConfLogControl_.set (r);
            continue;
          }
        }

        // ReportSettings
        //
        if (n.name () == "ReportSettings" && n.namespace_ () == "http://www.iec.ch/61850/2003/SCL")
        {
          ::std::auto_ptr< ReportSettings_type > r (
            ReportSettings_traits::create (i, f, this));

          if (!this->ReportSettings_)
          {
            this->ReportSettings_.set (r);
            continue;
          }
        }

        // LogSettings
        //
        if (n.name () == "LogSettings" && n.namespace_ () == "http://www.iec.ch/61850/2003/SCL")
        {
          ::std::auto_ptr< LogSettings_type > r (
            LogSettings_traits::create (i, f, this));

          if (!this->LogSettings_)
          {
            this->LogSettings_.set (r);
            continue;
          }
        }

        // GSESettings
        //
        if (n.name () == "GSESettings" && n.namespace_ () == "http://www.iec.ch/61850/2003/SCL")
        {
          ::std::auto_ptr< GSESettings_type > r (
            GSESettings_traits::create (i, f, this));

          if (!this->GSESettings_)
          {
            this->GSESettings_.set (r);
            continue;
          }
        }

        // SMVSettings
        //
        if (n.name () == "SMVSettings" && n.namespace_ () == "http://www.iec.ch/61850/2003/SCL")
        {
          ::std::auto_ptr< SMVSettings_type > r (
            SMVSettings_traits::create (i, f, this));

          if (!this->SMVSettings_)
          {
            this->SMVSettings_.set (r);
            continue;
          }
        }

        // GSEDir
        //
        if (n.name () == "GSEDir" && n.namespace_ () == "http://www.iec.ch/61850/2003/SCL")
        {
          ::std::auto_ptr< GSEDir_type > r (
            GSEDir_traits::create (i, f, this));

          if (!this->GSEDir_)
          {
            this->GSEDir_.set (r);
            continue;
          }
        }

        // GOOSE
        //
        if (n.name () == "GOOSE" && n.namespace_ () == "http://www.iec.ch/61850/2003/SCL")
        {
          ::std::auto_ptr< GOOSE_type > r (
            GOOSE_traits::create (i, f, this));

          if (!this->GOOSE_)
          {
            this->GOOSE_.set (r);
            continue;
          }
        }

        // GSSE
        //
        if (n.name () == "GSSE" && n.namespace_ () == "http://www.iec.ch/61850/2003/SCL")
        {
          ::std::auto_ptr< GSSE_type > r (
            GSSE_traits::create (i, f, this));

          if (!this->GSSE_)
          {
            this->GSSE_.set (r);
            continue;
          }
        }

        // FileHandling
        //
        if (n.name () == "FileHandling" && n.namespace_ () == "http://www.iec.ch/61850/2003/SCL")
        {
          ::std::auto_ptr< FileHandling_type > r (
            FileHandling_traits::create (i, f, this));

          if (!this->FileHandling_)
          {
            this->FileHandling_.set (r);
            continue;
          }
        }

        // ConfLNs
        //
        if (n.name () == "ConfLNs" && n.namespace_ () == "http://www.iec.ch/61850/2003/SCL")
        {
          ::std::auto_ptr< ConfLNs_type > r (
            ConfLNs_traits::create (i, f, this));

          if (!this->ConfLNs_)
          {
            this->ConfLNs_.set (r);
            continue;
          }
        }

        // ClientServices
        //
        if (n.name () == "ClientServices" && n.namespace_ () == "http://www.iec.ch/61850/2003/SCL")
        {
          ::std::auto_ptr< ClientServices_type > r (
            ClientServices_traits::create (i, f, this));

          if (!this->ClientServices_)
          {
            this->ClientServices_.set (r);
            continue;
          }
        }

        break;
      }
    }

    tServices* tServices::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class tServices (*this, f, c);
    }

    tServices::
    ~tServices ()
    {
    }

    // tAccessPoint
    //

    const tAccessPoint::router_type tAccessPoint::router_default_value_ (
      ::xsd::cxx::tree::traits< ::xml_schema::boolean, char >::create (
        ::std::string ("false"), 0, 0, 0));

    const tAccessPoint::clock_type tAccessPoint::clock_default_value_ (
      ::xsd::cxx::tree::traits< ::xml_schema::boolean, char >::create (
        ::std::string ("false"), 0, 0, 0));

    tAccessPoint::
    tAccessPoint (const name_type& name)
    : ::IEC61850::SCL::tNaming (name),
      Server_ (::xml_schema::flags (), this),
      LN_ (::xml_schema::flags (), this),
      router_ (router_default_value (), ::xml_schema::flags (), this),
      clock_ (clock_default_value (), ::xml_schema::flags (), this)
    {
    }

    tAccessPoint::
    tAccessPoint (const tAccessPoint& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::IEC61850::SCL::tNaming (x, f, c),
      Server_ (x.Server_, f, this),
      LN_ (x.LN_, f, this),
      router_ (x.router_, f, this),
      clock_ (x.clock_, f, this)
    {
    }

    tAccessPoint::
    tAccessPoint (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::IEC61850::SCL::tNaming (e, f | ::xml_schema::flags::base, c),
      Server_ (f, this),
      LN_ (f, this),
      router_ (f, this),
      clock_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void tAccessPoint::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::IEC61850::SCL::tNaming::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Server
        //
        if (n.name () == "Server" && n.namespace_ () == "http://www.iec.ch/61850/2003/SCL")
        {
          ::std::auto_ptr< Server_type > r (
            Server_traits::create (i, f, this));

          if (!this->Server_)
          {
            this->Server_.set (r);
            continue;
          }
        }

        // LN
        //
        if (n.name () == "LN" && n.namespace_ () == "http://www.iec.ch/61850/2003/SCL")
        {
          ::std::auto_ptr< LN_type > r (
            LN_traits::create (i, f, this));

          this->LN_.push_back (r);
          continue;
        }

        break;
      }

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "router" && n.namespace_ ().empty ())
        {
          this->router_.set (router_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "clock" && n.namespace_ ().empty ())
        {
          this->clock_.set (clock_traits::create (i, f, this));
          continue;
        }
      }

      if (!router_.present ())
      {
        this->router_.set (router_default_value ());
      }

      if (!clock_.present ())
      {
        this->clock_.set (clock_default_value ());
      }
    }

    tAccessPoint* tAccessPoint::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class tAccessPoint (*this, f, c);
    }

    tAccessPoint::
    ~tAccessPoint ()
    {
    }

    // tServer
    //

    const tServer::timeout_type tServer::timeout_default_value_ (
      ::xsd::cxx::tree::traits< ::xml_schema::unsigned_int, char >::create (
        ::std::string ("30"), 0, 0, 0));

    tServer::
    tServer (const Authentication_type& Authentication)
    : ::IEC61850::SCL::tUnNaming (),
      Authentication_ (Authentication, ::xml_schema::flags (), this),
      LDevice_ (::xml_schema::flags (), this),
      Association_ (::xml_schema::flags (), this),
      timeout_ (timeout_default_value (), ::xml_schema::flags (), this)
    {
    }

    tServer::
    tServer (::std::auto_ptr< Authentication_type >& Authentication)
    : ::IEC61850::SCL::tUnNaming (),
      Authentication_ (Authentication, ::xml_schema::flags (), this),
      LDevice_ (::xml_schema::flags (), this),
      Association_ (::xml_schema::flags (), this),
      timeout_ (timeout_default_value (), ::xml_schema::flags (), this)
    {
    }

    tServer::
    tServer (const tServer& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
    : ::IEC61850::SCL::tUnNaming (x, f, c),
      Authentication_ (x.Authentication_, f, this),
      LDevice_ (x.LDevice_, f, this),
      Association_ (x.Association_, f, this),
      timeout_ (x.timeout_, f, this)
    {
    }

    tServer::
    tServer (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
    : ::IEC61850::SCL::tUnNaming (e, f | ::xml_schema::flags::base, c),
      Authentication_ (f, this),
      LDevice_ (f, this),
      Association_ (f, this),
      timeout_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void tServer::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::IEC61850::SCL::tUnNaming::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Authentication
        //
        if (n.name () == "Authentication" && n.namespace_ () == "http://www.iec.ch/61850/2003/SCL")
        {
          ::std::auto_ptr< Authentication_type > r (
            Authentication_traits::create (i, f, this));

          if (!Authentication_.present ())
          {
            this->Authentication_.set (r);
            continue;
          }
        }

        // LDevice
        //
        if (n.name () == "LDevice" && n.namespace_ () == "http://www.iec.ch/61850/2003/SCL")
        {
          ::std::auto_ptr< LDevice_type > r (
            LDevice_traits::create (i, f, this));

          this->LDevice_.push_back (r);
          continue;
        }

        // Association
        //
        if (n.name () == "Association" && n.namespace_ () == "http://www.iec.ch/61850/2003/SCL")
        {
          ::std::auto_ptr< Association_type > r (
            Association_traits::create (i, f, this));

          this->Association_.push_back (r);
          continue;
        }

        break;
      }

      if (!Authentication_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Authentication",
          "http://www.iec.ch/61850/2003/SCL");
      }

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "timeout" && n.namespace_ ().empty ())
        {
          this->timeout_.set (timeout_traits::create (i, f, this));
          continue;
        }
      }

      if (!timeout_.present ())
      {
        this->timeout_.set (timeout_default_value ());
      }
    }

    tServer* tServer::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class tServer (*this, f, c);
    }

    tServer::
    ~tServer ()
    {
    }

    // tLDevice
    //

    tLDevice::
    tLDevice (const LN0_type& LN0,
              const inst_type& inst)
    : ::IEC61850::SCL::tUnNaming (),
      LN0_ (LN0, ::xml_schema::flags (), this),
      LN_ (::xml_schema::flags (), this),
      AccessControl_ (::xml_schema::flags (), this),
      inst_ (inst, ::xml_schema::flags (), this),
      ldName_ (::xml_schema::flags (), this)
    {
    }

    tLDevice::
    tLDevice (::std::auto_ptr< LN0_type >& LN0,
              const inst_type& inst)
    : ::IEC61850::SCL::tUnNaming (),
      LN0_ (LN0, ::xml_schema::flags (), this),
      LN_ (::xml_schema::flags (), this),
      AccessControl_ (::xml_schema::flags (), this),
      inst_ (inst, ::xml_schema::flags (), this),
      ldName_ (::xml_schema::flags (), this)
    {
    }

    tLDevice::
    tLDevice (const tLDevice& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
    : ::IEC61850::SCL::tUnNaming (x, f, c),
      LN0_ (x.LN0_, f, this),
      LN_ (x.LN_, f, this),
      AccessControl_ (x.AccessControl_, f, this),
      inst_ (x.inst_, f, this),
      ldName_ (x.ldName_, f, this)
    {
    }

    tLDevice::
    tLDevice (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
    : ::IEC61850::SCL::tUnNaming (e, f | ::xml_schema::flags::base, c),
      LN0_ (f, this),
      LN_ (f, this),
      AccessControl_ (f, this),
      inst_ (f, this),
      ldName_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void tLDevice::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::IEC61850::SCL::tUnNaming::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // LN0
        //
        if (n.name () == "LN0" && n.namespace_ () == "http://www.iec.ch/61850/2003/SCL")
        {
          ::std::auto_ptr< LN0_type > r (
            LN0_traits::create (i, f, this));

          if (!LN0_.present ())
          {
            this->LN0_.set (r);
            continue;
          }
        }

        // LN
        //
        if (n.name () == "LN" && n.namespace_ () == "http://www.iec.ch/61850/2003/SCL")
        {
          ::std::auto_ptr< LN_type > r (
            LN_traits::create (i, f, this));

          this->LN_.push_back (r);
          continue;
        }

        // AccessControl
        //
        if (n.name () == "AccessControl" && n.namespace_ () == "http://www.iec.ch/61850/2003/SCL")
        {
          ::std::auto_ptr< AccessControl_type > r (
            AccessControl_traits::create (i, f, this));

          if (!this->AccessControl_)
          {
            this->AccessControl_.set (r);
            continue;
          }
        }

        break;
      }

      if (!LN0_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "LN0",
          "http://www.iec.ch/61850/2003/SCL");
      }

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "inst" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< inst_type > r (
            inst_traits::create (i, f, this));

          this->inst_.set (r);
          continue;
        }

        if (n.name () == "ldName" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< ldName_type > r (
            ldName_traits::create (i, f, this));

          this->ldName_.set (r);
          continue;
        }
      }

      if (!inst_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "inst",
          "");
      }
    }

    tLDevice* tLDevice::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class tLDevice (*this, f, c);
    }

    tLDevice::
    ~tLDevice ()
    {
    }

    // tAccessControl
    //

    tAccessControl::
    tAccessControl ()
    : ::IEC61850::SCL::tAnyContentFromOtherNamespace ()
    {
    }

    tAccessControl::
    tAccessControl (const tAccessControl& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::IEC61850::SCL::tAnyContentFromOtherNamespace (x, f, c)
    {
    }

    tAccessControl::
    tAccessControl (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::IEC61850::SCL::tAnyContentFromOtherNamespace (e, f, c)
    {
    }

    tAccessControl* tAccessControl::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class tAccessControl (*this, f, c);
    }

    tAccessControl::
    ~tAccessControl ()
    {
    }

    // tAssociation
    //

    tAssociation::
    tAssociation (const kind_type& kind,
                  const iedName_type& iedName,
                  const ldInst_type& ldInst,
                  const lnClass_type& lnClass,
                  const lnInst_type& lnInst)
    : ::xml_schema::type (),
      kind_ (kind, ::xml_schema::flags (), this),
      associationID_ (::xml_schema::flags (), this),
      iedName_ (iedName, ::xml_schema::flags (), this),
      ldInst_ (ldInst, ::xml_schema::flags (), this),
      prefix_ (::xml_schema::flags (), this),
      lnClass_ (lnClass, ::xml_schema::flags (), this),
      lnInst_ (lnInst, ::xml_schema::flags (), this)
    {
    }

    tAssociation::
    tAssociation (const tAssociation& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      kind_ (x.kind_, f, this),
      associationID_ (x.associationID_, f, this),
      iedName_ (x.iedName_, f, this),
      ldInst_ (x.ldInst_, f, this),
      prefix_ (x.prefix_, f, this),
      lnClass_ (x.lnClass_, f, this),
      lnInst_ (x.lnInst_, f, this)
    {
    }

    tAssociation::
    tAssociation (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      kind_ (f, this),
      associationID_ (f, this),
      iedName_ (f, this),
      ldInst_ (f, this),
      prefix_ (f, this),
      lnClass_ (f, this),
      lnInst_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
        this->parse (p, f);
      }
    }

    void tAssociation::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "kind" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< kind_type > r (
            kind_traits::create (i, f, this));

          this->kind_.set (r);
          continue;
        }

        if (n.name () == "associationID" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< associationID_type > r (
            associationID_traits::create (i, f, this));

          this->associationID_.set (r);
          continue;
        }

        if (n.name () == "iedName" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< iedName_type > r (
            iedName_traits::create (i, f, this));

          this->iedName_.set (r);
          continue;
        }

        if (n.name () == "ldInst" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< ldInst_type > r (
            ldInst_traits::create (i, f, this));

          this->ldInst_.set (r);
          continue;
        }

        if (n.name () == "prefix" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< prefix_type > r (
            prefix_traits::create (i, f, this));

          this->prefix_.set (r);
          continue;
        }

        if (n.name () == "lnClass" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< lnClass_type > r (
            lnClass_traits::create (i, f, this));

          this->lnClass_.set (r);
          continue;
        }

        if (n.name () == "lnInst" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< lnInst_type > r (
            lnInst_traits::create (i, f, this));

          this->lnInst_.set (r);
          continue;
        }
      }

      if (!kind_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "kind",
          "");
      }

      if (!iedName_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "iedName",
          "");
      }

      if (!ldInst_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "ldInst",
          "");
      }

      if (!lnClass_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "lnClass",
          "");
      }

      if (!lnInst_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "lnInst",
          "");
      }
    }

    tAssociation* tAssociation::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class tAssociation (*this, f, c);
    }

    tAssociation::
    ~tAssociation ()
    {
    }

    // tAnyLN
    //

    tAnyLN::
    tAnyLN (const lnType_type& lnType)
    : ::IEC61850::SCL::tUnNaming (),
      DataSet_ (::xml_schema::flags (), this),
      ReportControl_ (::xml_schema::flags (), this),
      LogControl_ (::xml_schema::flags (), this),
      DOI_ (::xml_schema::flags (), this),
      Inputs_ (::xml_schema::flags (), this),
      lnType_ (lnType, ::xml_schema::flags (), this)
    {
    }

    tAnyLN::
    tAnyLN (const tAnyLN& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
    : ::IEC61850::SCL::tUnNaming (x, f, c),
      DataSet_ (x.DataSet_, f, this),
      ReportControl_ (x.ReportControl_, f, this),
      LogControl_ (x.LogControl_, f, this),
      DOI_ (x.DOI_, f, this),
      Inputs_ (x.Inputs_, f, this),
      lnType_ (x.lnType_, f, this)
    {
    }

    tAnyLN::
    tAnyLN (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
    : ::IEC61850::SCL::tUnNaming (e, f | ::xml_schema::flags::base, c),
      DataSet_ (f, this),
      ReportControl_ (f, this),
      LogControl_ (f, this),
      DOI_ (f, this),
      Inputs_ (f, this),
      lnType_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void tAnyLN::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::IEC61850::SCL::tUnNaming::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // DataSet
        //
        if (n.name () == "DataSet" && n.namespace_ () == "http://www.iec.ch/61850/2003/SCL")
        {
          ::std::auto_ptr< DataSet_type > r (
            DataSet_traits::create (i, f, this));

          this->DataSet_.push_back (r);
          continue;
        }

        // ReportControl
        //
        if (n.name () == "ReportControl" && n.namespace_ () == "http://www.iec.ch/61850/2003/SCL")
        {
          ::std::auto_ptr< ReportControl_type > r (
            ReportControl_traits::create (i, f, this));

          this->ReportControl_.push_back (r);
          continue;
        }

        // LogControl
        //
        if (n.name () == "LogControl" && n.namespace_ () == "http://www.iec.ch/61850/2003/SCL")
        {
          ::std::auto_ptr< LogControl_type > r (
            LogControl_traits::create (i, f, this));

          this->LogControl_.push_back (r);
          continue;
        }

        // DOI
        //
        if (n.name () == "DOI" && n.namespace_ () == "http://www.iec.ch/61850/2003/SCL")
        {
          ::std::auto_ptr< DOI_type > r (
            DOI_traits::create (i, f, this));

          this->DOI_.push_back (r);
          continue;
        }

        // Inputs
        //
        if (n.name () == "Inputs" && n.namespace_ () == "http://www.iec.ch/61850/2003/SCL")
        {
          ::std::auto_ptr< Inputs_type > r (
            Inputs_traits::create (i, f, this));

          if (!this->Inputs_)
          {
            this->Inputs_.set (r);
            continue;
          }
        }

        break;
      }

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "lnType" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< lnType_type > r (
            lnType_traits::create (i, f, this));

          this->lnType_.set (r);
          continue;
        }
      }

      if (!lnType_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "lnType",
          "");
      }
    }

    tAnyLN* tAnyLN::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class tAnyLN (*this, f, c);
    }

    tAnyLN::
    ~tAnyLN ()
    {
    }

    // tLN
    //

    tLN::
    tLN (const lnType_type& lnType,
         const lnClass_type& lnClass,
         const inst_type& inst)
    : ::IEC61850::SCL::tAnyLN (lnType),
      lnClass_ (lnClass, ::xml_schema::flags (), this),
      inst_ (inst, ::xml_schema::flags (), this),
      prefix_ (::xml_schema::flags (), this)
    {
    }

    tLN::
    tLN (const tLN& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
    : ::IEC61850::SCL::tAnyLN (x, f, c),
      lnClass_ (x.lnClass_, f, this),
      inst_ (x.inst_, f, this),
      prefix_ (x.prefix_, f, this)
    {
    }

    tLN::
    tLN (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
    : ::IEC61850::SCL::tAnyLN (e, f | ::xml_schema::flags::base, c),
      lnClass_ (f, this),
      inst_ (f, this),
      prefix_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void tLN::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::IEC61850::SCL::tAnyLN::parse (p, f);

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "lnClass" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< lnClass_type > r (
            lnClass_traits::create (i, f, this));

          this->lnClass_.set (r);
          continue;
        }

        if (n.name () == "inst" && n.namespace_ ().empty ())
        {
          this->inst_.set (inst_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "prefix" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< prefix_type > r (
            prefix_traits::create (i, f, this));

          this->prefix_.set (r);
          continue;
        }
      }

      if (!lnClass_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "lnClass",
          "");
      }

      if (!inst_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "inst",
          "");
      }
    }

    tLN* tLN::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class tLN (*this, f, c);
    }

    tLN::
    ~tLN ()
    {
    }

    // tLN0
    //

    const tLN0::lnClass_type tLN0::lnClass_default_value_ (
      ::std::string ("LLN0"), 0, 0, 0);

    tLN0::
    tLN0 (const lnType_type& lnType,
          const inst_type& inst)
    : ::IEC61850::SCL::tAnyLN (lnType),
      GSEControl_ (::xml_schema::flags (), this),
      SampledValueControl_ (::xml_schema::flags (), this),
      SettingControl_ (::xml_schema::flags (), this),
      SCLControl_ (::xml_schema::flags (), this),
      Log_ (::xml_schema::flags (), this),
      lnClass_ (lnClass_default_value (), ::xml_schema::flags (), this),
      inst_ (inst, ::xml_schema::flags (), this)
    {
    }

    tLN0::
    tLN0 (const tLN0& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
    : ::IEC61850::SCL::tAnyLN (x, f, c),
      GSEControl_ (x.GSEControl_, f, this),
      SampledValueControl_ (x.SampledValueControl_, f, this),
      SettingControl_ (x.SettingControl_, f, this),
      SCLControl_ (x.SCLControl_, f, this),
      Log_ (x.Log_, f, this),
      lnClass_ (x.lnClass_, f, this),
      inst_ (x.inst_, f, this)
    {
    }

    tLN0::
    tLN0 (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
    : ::IEC61850::SCL::tAnyLN (e, f | ::xml_schema::flags::base, c),
      GSEControl_ (f, this),
      SampledValueControl_ (f, this),
      SettingControl_ (f, this),
      SCLControl_ (f, this),
      Log_ (f, this),
      lnClass_ (f, this),
      inst_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void tLN0::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::IEC61850::SCL::tAnyLN::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // GSEControl
        //
        if (n.name () == "GSEControl" && n.namespace_ () == "http://www.iec.ch/61850/2003/SCL")
        {
          ::std::auto_ptr< GSEControl_type > r (
            GSEControl_traits::create (i, f, this));

          this->GSEControl_.push_back (r);
          continue;
        }

        // SampledValueControl
        //
        if (n.name () == "SampledValueControl" && n.namespace_ () == "http://www.iec.ch/61850/2003/SCL")
        {
          ::std::auto_ptr< SampledValueControl_type > r (
            SampledValueControl_traits::create (i, f, this));

          this->SampledValueControl_.push_back (r);
          continue;
        }

        // SettingControl
        //
        if (n.name () == "SettingControl" && n.namespace_ () == "http://www.iec.ch/61850/2003/SCL")
        {
          ::std::auto_ptr< SettingControl_type > r (
            SettingControl_traits::create (i, f, this));

          if (!this->SettingControl_)
          {
            this->SettingControl_.set (r);
            continue;
          }
        }

        // SCLControl
        //
        if (n.name () == "SCLControl" && n.namespace_ () == "http://www.iec.ch/61850/2003/SCL")
        {
          ::std::auto_ptr< SCLControl_type > r (
            SCLControl_traits::create (i, f, this));

          if (!this->SCLControl_)
          {
            this->SCLControl_.set (r);
            continue;
          }
        }

        // Log
        //
        if (n.name () == "Log" && n.namespace_ () == "http://www.iec.ch/61850/2003/SCL")
        {
          ::std::auto_ptr< Log_type > r (
            Log_traits::create (i, f, this));

          if (!this->Log_)
          {
            this->Log_.set (r);
            continue;
          }
        }

        break;
      }

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "lnClass" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< lnClass_type > r (
            lnClass_traits::create (i, f, this));

          this->lnClass_.set (r);
          continue;
        }

        if (n.name () == "inst" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< inst_type > r (
            inst_traits::create (i, f, this));

          this->inst_.set (r);
          continue;
        }
      }

      if (!lnClass_.present ())
      {
        this->lnClass_.set (lnClass_default_value ());
      }

      if (!inst_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "inst",
          "");
      }
    }

    tLN0* tLN0::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class tLN0 (*this, f, c);
    }

    tLN0::
    ~tLN0 ()
    {
    }

    // tDataSet
    //

    tDataSet::
    tDataSet (const name_type& name)
    : ::IEC61850::SCL::tNaming (name),
      FCDA_ (::xml_schema::flags (), this),
      FCCB_ (::xml_schema::flags (), this)
    {
    }

    tDataSet::
    tDataSet (const tDataSet& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
    : ::IEC61850::SCL::tNaming (x, f, c),
      FCDA_ (x.FCDA_, f, this),
      FCCB_ (x.FCCB_, f, this)
    {
    }

    tDataSet::
    tDataSet (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
    : ::IEC61850::SCL::tNaming (e, f | ::xml_schema::flags::base, c),
      FCDA_ (f, this),
      FCCB_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void tDataSet::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::IEC61850::SCL::tNaming::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // FCDA
        //
        if (n.name () == "FCDA" && n.namespace_ () == "http://www.iec.ch/61850/2003/SCL")
        {
          ::std::auto_ptr< FCDA_type > r (
            FCDA_traits::create (i, f, this));

          this->FCDA_.push_back (r);
          continue;
        }

        // FCCB
        //
        if (n.name () == "FCCB" && n.namespace_ () == "http://www.iec.ch/61850/2003/SCL")
        {
          ::std::auto_ptr< FCCB_type > r (
            FCCB_traits::create (i, f, this));

          this->FCCB_.push_back (r);
          continue;
        }

        break;
      }
    }

    tDataSet* tDataSet::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class tDataSet (*this, f, c);
    }

    tDataSet::
    ~tDataSet ()
    {
    }

    // tFCDA
    //

    tFCDA::
    tFCDA (const fc_type& fc)
    : ::xml_schema::type (),
      ldInst_ (::xml_schema::flags (), this),
      prefix_ (::xml_schema::flags (), this),
      lnClass_ (::xml_schema::flags (), this),
      lnInst_ (::xml_schema::flags (), this),
      doName_ (::xml_schema::flags (), this),
      daName_ (::xml_schema::flags (), this),
      fc_ (fc, ::xml_schema::flags (), this)
    {
    }

    tFCDA::
    tFCDA (const tFCDA& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      ldInst_ (x.ldInst_, f, this),
      prefix_ (x.prefix_, f, this),
      lnClass_ (x.lnClass_, f, this),
      lnInst_ (x.lnInst_, f, this),
      doName_ (x.doName_, f, this),
      daName_ (x.daName_, f, this),
      fc_ (x.fc_, f, this)
    {
    }

    tFCDA::
    tFCDA (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      ldInst_ (f, this),
      prefix_ (f, this),
      lnClass_ (f, this),
      lnInst_ (f, this),
      doName_ (f, this),
      daName_ (f, this),
      fc_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
        this->parse (p, f);
      }
    }

    void tFCDA::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "ldInst" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< ldInst_type > r (
            ldInst_traits::create (i, f, this));

          this->ldInst_.set (r);
          continue;
        }

        if (n.name () == "prefix" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< prefix_type > r (
            prefix_traits::create (i, f, this));

          this->prefix_.set (r);
          continue;
        }

        if (n.name () == "lnClass" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< lnClass_type > r (
            lnClass_traits::create (i, f, this));

          this->lnClass_.set (r);
          continue;
        }

        if (n.name () == "lnInst" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< lnInst_type > r (
            lnInst_traits::create (i, f, this));

          this->lnInst_.set (r);
          continue;
        }

        if (n.name () == "doName" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< doName_type > r (
            doName_traits::create (i, f, this));

          this->doName_.set (r);
          continue;
        }

        if (n.name () == "daName" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< daName_type > r (
            daName_traits::create (i, f, this));

          this->daName_.set (r);
          continue;
        }

        if (n.name () == "fc" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< fc_type > r (
            fc_traits::create (i, f, this));

          this->fc_.set (r);
          continue;
        }
      }

      if (!fc_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "fc",
          "");
      }
    }

    tFCDA* tFCDA::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class tFCDA (*this, f, c);
    }

    tFCDA::
    ~tFCDA ()
    {
    }

    // tFCCB
    //

    tFCCB::
    tFCCB (const ldInst_type& ldInst,
           const lnClass_type& lnClass,
           const cbName_type& cbName,
           const fc_type& fc)
    : ::xml_schema::type (),
      ldInst_ (ldInst, ::xml_schema::flags (), this),
      prefix_ (::xml_schema::flags (), this),
      lnClass_ (lnClass, ::xml_schema::flags (), this),
      lnInst_ (::xml_schema::flags (), this),
      cbName_ (cbName, ::xml_schema::flags (), this),
      daName_ (::xml_schema::flags (), this),
      fc_ (fc, ::xml_schema::flags (), this)
    {
    }

    tFCCB::
    tFCCB (const tFCCB& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      ldInst_ (x.ldInst_, f, this),
      prefix_ (x.prefix_, f, this),
      lnClass_ (x.lnClass_, f, this),
      lnInst_ (x.lnInst_, f, this),
      cbName_ (x.cbName_, f, this),
      daName_ (x.daName_, f, this),
      fc_ (x.fc_, f, this)
    {
    }

    tFCCB::
    tFCCB (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      ldInst_ (f, this),
      prefix_ (f, this),
      lnClass_ (f, this),
      lnInst_ (f, this),
      cbName_ (f, this),
      daName_ (f, this),
      fc_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
        this->parse (p, f);
      }
    }

    void tFCCB::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "ldInst" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< ldInst_type > r (
            ldInst_traits::create (i, f, this));

          this->ldInst_.set (r);
          continue;
        }

        if (n.name () == "prefix" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< prefix_type > r (
            prefix_traits::create (i, f, this));

          this->prefix_.set (r);
          continue;
        }

        if (n.name () == "lnClass" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< lnClass_type > r (
            lnClass_traits::create (i, f, this));

          this->lnClass_.set (r);
          continue;
        }

        if (n.name () == "lnInst" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< lnInst_type > r (
            lnInst_traits::create (i, f, this));

          this->lnInst_.set (r);
          continue;
        }

        if (n.name () == "cbName" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< cbName_type > r (
            cbName_traits::create (i, f, this));

          this->cbName_.set (r);
          continue;
        }

        if (n.name () == "daName" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< daName_type > r (
            daName_traits::create (i, f, this));

          this->daName_.set (r);
          continue;
        }

        if (n.name () == "fc" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< fc_type > r (
            fc_traits::create (i, f, this));

          this->fc_.set (r);
          continue;
        }
      }

      if (!ldInst_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "ldInst",
          "");
      }

      if (!lnClass_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "lnClass",
          "");
      }

      if (!cbName_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "cbName",
          "");
      }

      if (!fc_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "fc",
          "");
      }
    }

    tFCCB* tFCCB::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class tFCCB (*this, f, c);
    }

    tFCCB::
    ~tFCCB ()
    {
    }

    // tControl
    //

    tControl::
    tControl (const name_type& name)
    : ::IEC61850::SCL::tNaming (name),
      datSet_ (::xml_schema::flags (), this)
    {
    }

    tControl::
    tControl (const tControl& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
    : ::IEC61850::SCL::tNaming (x, f, c),
      datSet_ (x.datSet_, f, this)
    {
    }

    tControl::
    tControl (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
    : ::IEC61850::SCL::tNaming (e, f | ::xml_schema::flags::base, c),
      datSet_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void tControl::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::IEC61850::SCL::tNaming::parse (p, f);

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "datSet" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< datSet_type > r (
            datSet_traits::create (i, f, this));

          this->datSet_.set (r);
          continue;
        }
      }
    }

    tControl* tControl::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class tControl (*this, f, c);
    }

    tControl::
    ~tControl ()
    {
    }

    // tControlWithTriggerOpt
    //

    const tControlWithTriggerOpt::intgPd_type tControlWithTriggerOpt::intgPd_default_value_ (
      ::xsd::cxx::tree::traits< ::xml_schema::unsigned_int, char >::create (
        ::std::string ("0"), 0, 0, 0));

    tControlWithTriggerOpt::
    tControlWithTriggerOpt (const name_type& name)
    : ::IEC61850::SCL::tControl (name),
      TrgOps_ (::xml_schema::flags (), this),
      intgPd_ (intgPd_default_value (), ::xml_schema::flags (), this)
    {
    }

    tControlWithTriggerOpt::
    tControlWithTriggerOpt (const tControlWithTriggerOpt& x,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::IEC61850::SCL::tControl (x, f, c),
      TrgOps_ (x.TrgOps_, f, this),
      intgPd_ (x.intgPd_, f, this)
    {
    }

    tControlWithTriggerOpt::
    tControlWithTriggerOpt (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::IEC61850::SCL::tControl (e, f | ::xml_schema::flags::base, c),
      TrgOps_ (f, this),
      intgPd_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void tControlWithTriggerOpt::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::IEC61850::SCL::tControl::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // TrgOps
        //
        if (n.name () == "TrgOps" && n.namespace_ () == "http://www.iec.ch/61850/2003/SCL")
        {
          ::std::auto_ptr< TrgOps_type > r (
            TrgOps_traits::create (i, f, this));

          if (!this->TrgOps_)
          {
            this->TrgOps_.set (r);
            continue;
          }
        }

        break;
      }

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "intgPd" && n.namespace_ ().empty ())
        {
          this->intgPd_.set (intgPd_traits::create (i, f, this));
          continue;
        }
      }

      if (!intgPd_.present ())
      {
        this->intgPd_.set (intgPd_default_value ());
      }
    }

    tControlWithTriggerOpt* tControlWithTriggerOpt::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class tControlWithTriggerOpt (*this, f, c);
    }

    tControlWithTriggerOpt::
    ~tControlWithTriggerOpt ()
    {
    }

    // tTrgOps
    //

    const tTrgOps::dchg_type tTrgOps::dchg_default_value_ (
      ::xsd::cxx::tree::traits< ::xml_schema::boolean, char >::create (
        ::std::string ("false"), 0, 0, 0));

    const tTrgOps::qchg_type tTrgOps::qchg_default_value_ (
      ::xsd::cxx::tree::traits< ::xml_schema::boolean, char >::create (
        ::std::string ("false"), 0, 0, 0));

    const tTrgOps::dupd_type tTrgOps::dupd_default_value_ (
      ::xsd::cxx::tree::traits< ::xml_schema::boolean, char >::create (
        ::std::string ("false"), 0, 0, 0));

    const tTrgOps::period_type tTrgOps::period_default_value_ (
      ::xsd::cxx::tree::traits< ::xml_schema::boolean, char >::create (
        ::std::string ("false"), 0, 0, 0));

    tTrgOps::
    tTrgOps ()
    : ::xml_schema::type (),
      dchg_ (dchg_default_value (), ::xml_schema::flags (), this),
      qchg_ (qchg_default_value (), ::xml_schema::flags (), this),
      dupd_ (dupd_default_value (), ::xml_schema::flags (), this),
      period_ (period_default_value (), ::xml_schema::flags (), this)
    {
    }

    tTrgOps::
    tTrgOps (const tTrgOps& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      dchg_ (x.dchg_, f, this),
      qchg_ (x.qchg_, f, this),
      dupd_ (x.dupd_, f, this),
      period_ (x.period_, f, this)
    {
    }

    tTrgOps::
    tTrgOps (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      dchg_ (f, this),
      qchg_ (f, this),
      dupd_ (f, this),
      period_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
        this->parse (p, f);
      }
    }

    void tTrgOps::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "dchg" && n.namespace_ ().empty ())
        {
          this->dchg_.set (dchg_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "qchg" && n.namespace_ ().empty ())
        {
          this->qchg_.set (qchg_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "dupd" && n.namespace_ ().empty ())
        {
          this->dupd_.set (dupd_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "period" && n.namespace_ ().empty ())
        {
          this->period_.set (period_traits::create (i, f, this));
          continue;
        }
      }

      if (!dchg_.present ())
      {
        this->dchg_.set (dchg_default_value ());
      }

      if (!qchg_.present ())
      {
        this->qchg_.set (qchg_default_value ());
      }

      if (!dupd_.present ())
      {
        this->dupd_.set (dupd_default_value ());
      }

      if (!period_.present ())
      {
        this->period_.set (period_default_value ());
      }
    }

    tTrgOps* tTrgOps::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class tTrgOps (*this, f, c);
    }

    tTrgOps::
    ~tTrgOps ()
    {
    }

    // tReportControl
    //

    const tReportControl::buffered_type tReportControl::buffered_default_value_ (
      ::xsd::cxx::tree::traits< ::xml_schema::boolean, char >::create (
        ::std::string ("false"), 0, 0, 0));

    const tReportControl::bufTime_type tReportControl::bufTime_default_value_ (
      ::xsd::cxx::tree::traits< ::xml_schema::unsigned_int, char >::create (
        ::std::string ("0"), 0, 0, 0));

    tReportControl::
    tReportControl (const name_type& name,
                    const OptFields_type& OptFields,
                    const confRev_type& confRev)
    : ::IEC61850::SCL::tControlWithTriggerOpt (name),
      OptFields_ (OptFields, ::xml_schema::flags (), this),
      RptEnabled_ (::xml_schema::flags (), this),
      rptID_ (::xml_schema::flags (), this),
      confRev_ (confRev, ::xml_schema::flags (), this),
      buffered_ (buffered_default_value (), ::xml_schema::flags (), this),
      bufTime_ (bufTime_default_value (), ::xml_schema::flags (), this)
    {
    }

    tReportControl::
    tReportControl (const name_type& name,
                    ::std::auto_ptr< OptFields_type >& OptFields,
                    const confRev_type& confRev)
    : ::IEC61850::SCL::tControlWithTriggerOpt (name),
      OptFields_ (OptFields, ::xml_schema::flags (), this),
      RptEnabled_ (::xml_schema::flags (), this),
      rptID_ (::xml_schema::flags (), this),
      confRev_ (confRev, ::xml_schema::flags (), this),
      buffered_ (buffered_default_value (), ::xml_schema::flags (), this),
      bufTime_ (bufTime_default_value (), ::xml_schema::flags (), this)
    {
    }

    tReportControl::
    tReportControl (const tReportControl& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::IEC61850::SCL::tControlWithTriggerOpt (x, f, c),
      OptFields_ (x.OptFields_, f, this),
      RptEnabled_ (x.RptEnabled_, f, this),
      rptID_ (x.rptID_, f, this),
      confRev_ (x.confRev_, f, this),
      buffered_ (x.buffered_, f, this),
      bufTime_ (x.bufTime_, f, this)
    {
    }

    tReportControl::
    tReportControl (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::IEC61850::SCL::tControlWithTriggerOpt (e, f | ::xml_schema::flags::base, c),
      OptFields_ (f, this),
      RptEnabled_ (f, this),
      rptID_ (f, this),
      confRev_ (f, this),
      buffered_ (f, this),
      bufTime_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void tReportControl::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::IEC61850::SCL::tControlWithTriggerOpt::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // OptFields
        //
        if (n.name () == "OptFields" && n.namespace_ () == "http://www.iec.ch/61850/2003/SCL")
        {
          ::std::auto_ptr< OptFields_type > r (
            OptFields_traits::create (i, f, this));

          if (!OptFields_.present ())
          {
            this->OptFields_.set (r);
            continue;
          }
        }

        // RptEnabled
        //
        if (n.name () == "RptEnabled" && n.namespace_ () == "http://www.iec.ch/61850/2003/SCL")
        {
          ::std::auto_ptr< RptEnabled_type > r (
            RptEnabled_traits::create (i, f, this));

          if (!this->RptEnabled_)
          {
            this->RptEnabled_.set (r);
            continue;
          }
        }

        break;
      }

      if (!OptFields_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "OptFields",
          "http://www.iec.ch/61850/2003/SCL");
      }

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "rptID" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< rptID_type > r (
            rptID_traits::create (i, f, this));

          this->rptID_.set (r);
          continue;
        }

        if (n.name () == "confRev" && n.namespace_ ().empty ())
        {
          this->confRev_.set (confRev_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "buffered" && n.namespace_ ().empty ())
        {
          this->buffered_.set (buffered_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "bufTime" && n.namespace_ ().empty ())
        {
          this->bufTime_.set (bufTime_traits::create (i, f, this));
          continue;
        }
      }

      if (!confRev_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "confRev",
          "");
      }

      if (!buffered_.present ())
      {
        this->buffered_.set (buffered_default_value ());
      }

      if (!bufTime_.present ())
      {
        this->bufTime_.set (bufTime_default_value ());
      }
    }

    tReportControl* tReportControl::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class tReportControl (*this, f, c);
    }

    tReportControl::
    ~tReportControl ()
    {
    }

    // tRptEnabled
    //

    const tRptEnabled::max_type tRptEnabled::max_default_value_ (
      ::xsd::cxx::tree::traits< ::xml_schema::unsigned_int, char >::create (
        ::std::string ("1"), 0, 0, 0));

    tRptEnabled::
    tRptEnabled ()
    : ::IEC61850::SCL::tUnNaming (),
      ClientLN_ (::xml_schema::flags (), this),
      max_ (max_default_value (), ::xml_schema::flags (), this)
    {
    }

    tRptEnabled::
    tRptEnabled (const tRptEnabled& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::IEC61850::SCL::tUnNaming (x, f, c),
      ClientLN_ (x.ClientLN_, f, this),
      max_ (x.max_, f, this)
    {
    }

    tRptEnabled::
    tRptEnabled (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::IEC61850::SCL::tUnNaming (e, f | ::xml_schema::flags::base, c),
      ClientLN_ (f, this),
      max_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void tRptEnabled::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::IEC61850::SCL::tUnNaming::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // ClientLN
        //
        if (n.name () == "ClientLN" && n.namespace_ () == "http://www.iec.ch/61850/2003/SCL")
        {
          ::std::auto_ptr< ClientLN_type > r (
            ClientLN_traits::create (i, f, this));

          this->ClientLN_.push_back (r);
          continue;
        }

        break;
      }

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "max" && n.namespace_ ().empty ())
        {
          this->max_.set (max_traits::create (i, f, this));
          continue;
        }
      }

      if (!max_.present ())
      {
        this->max_.set (max_default_value ());
      }
    }

    tRptEnabled* tRptEnabled::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class tRptEnabled (*this, f, c);
    }

    tRptEnabled::
    ~tRptEnabled ()
    {
    }

    // tClientLN
    //

    tClientLN::
    tClientLN (const iedName_type& iedName,
               const ldInst_type& ldInst,
               const lnClass_type& lnClass,
               const lnInst_type& lnInst)
    : ::xml_schema::type (),
      iedName_ (iedName, ::xml_schema::flags (), this),
      ldInst_ (ldInst, ::xml_schema::flags (), this),
      prefix_ (::xml_schema::flags (), this),
      lnClass_ (lnClass, ::xml_schema::flags (), this),
      lnInst_ (lnInst, ::xml_schema::flags (), this)
    {
    }

    tClientLN::
    tClientLN (const tClientLN& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      iedName_ (x.iedName_, f, this),
      ldInst_ (x.ldInst_, f, this),
      prefix_ (x.prefix_, f, this),
      lnClass_ (x.lnClass_, f, this),
      lnInst_ (x.lnInst_, f, this)
    {
    }

    tClientLN::
    tClientLN (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      iedName_ (f, this),
      ldInst_ (f, this),
      prefix_ (f, this),
      lnClass_ (f, this),
      lnInst_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
        this->parse (p, f);
      }
    }

    void tClientLN::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "iedName" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< iedName_type > r (
            iedName_traits::create (i, f, this));

          this->iedName_.set (r);
          continue;
        }

        if (n.name () == "ldInst" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< ldInst_type > r (
            ldInst_traits::create (i, f, this));

          this->ldInst_.set (r);
          continue;
        }

        if (n.name () == "prefix" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< prefix_type > r (
            prefix_traits::create (i, f, this));

          this->prefix_.set (r);
          continue;
        }

        if (n.name () == "lnClass" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< lnClass_type > r (
            lnClass_traits::create (i, f, this));

          this->lnClass_.set (r);
          continue;
        }

        if (n.name () == "lnInst" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< lnInst_type > r (
            lnInst_traits::create (i, f, this));

          this->lnInst_.set (r);
          continue;
        }
      }

      if (!iedName_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "iedName",
          "");
      }

      if (!ldInst_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "ldInst",
          "");
      }

      if (!lnClass_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "lnClass",
          "");
      }

      if (!lnInst_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "lnInst",
          "");
      }
    }

    tClientLN* tClientLN::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class tClientLN (*this, f, c);
    }

    tClientLN::
    ~tClientLN ()
    {
    }

    // tLogControl
    //

    const tLogControl::logEna_type tLogControl::logEna_default_value_ (
      ::xsd::cxx::tree::traits< ::xml_schema::boolean, char >::create (
        ::std::string ("true"), 0, 0, 0));

    const tLogControl::reasonCode_type tLogControl::reasonCode_default_value_ (
      ::xsd::cxx::tree::traits< ::xml_schema::boolean, char >::create (
        ::std::string ("true"), 0, 0, 0));

    tLogControl::
    tLogControl (const name_type& name,
                 const logName_type& logName)
    : ::IEC61850::SCL::tControlWithTriggerOpt (name),
      logName_ (logName, ::xml_schema::flags (), this),
      logEna_ (logEna_default_value (), ::xml_schema::flags (), this),
      reasonCode_ (reasonCode_default_value (), ::xml_schema::flags (), this)
    {
    }

    tLogControl::
    tLogControl (const tLogControl& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::IEC61850::SCL::tControlWithTriggerOpt (x, f, c),
      logName_ (x.logName_, f, this),
      logEna_ (x.logEna_, f, this),
      reasonCode_ (x.reasonCode_, f, this)
    {
    }

    tLogControl::
    tLogControl (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::IEC61850::SCL::tControlWithTriggerOpt (e, f | ::xml_schema::flags::base, c),
      logName_ (f, this),
      logEna_ (f, this),
      reasonCode_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void tLogControl::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::IEC61850::SCL::tControlWithTriggerOpt::parse (p, f);

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "logName" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< logName_type > r (
            logName_traits::create (i, f, this));

          this->logName_.set (r);
          continue;
        }

        if (n.name () == "logEna" && n.namespace_ ().empty ())
        {
          this->logEna_.set (logEna_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "reasonCode" && n.namespace_ ().empty ())
        {
          this->reasonCode_.set (reasonCode_traits::create (i, f, this));
          continue;
        }
      }

      if (!logName_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "logName",
          "");
      }

      if (!logEna_.present ())
      {
        this->logEna_.set (logEna_default_value ());
      }

      if (!reasonCode_.present ())
      {
        this->reasonCode_.set (reasonCode_default_value ());
      }
    }

    tLogControl* tLogControl::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class tLogControl (*this, f, c);
    }

    tLogControl::
    ~tLogControl ()
    {
    }

    // tInputs
    //

    tInputs::
    tInputs ()
    : ::IEC61850::SCL::tUnNaming (),
      ExtRef_ (::xml_schema::flags (), this)
    {
    }

    tInputs::
    tInputs (const tInputs& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
    : ::IEC61850::SCL::tUnNaming (x, f, c),
      ExtRef_ (x.ExtRef_, f, this)
    {
    }

    tInputs::
    tInputs (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
    : ::IEC61850::SCL::tUnNaming (e, f | ::xml_schema::flags::base, c),
      ExtRef_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void tInputs::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::IEC61850::SCL::tUnNaming::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // ExtRef
        //
        if (n.name () == "ExtRef" && n.namespace_ () == "http://www.iec.ch/61850/2003/SCL")
        {
          ::std::auto_ptr< ExtRef_type > r (
            ExtRef_traits::create (i, f, this));

          this->ExtRef_.push_back (r);
          continue;
        }

        break;
      }
    }

    tInputs* tInputs::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class tInputs (*this, f, c);
    }

    tInputs::
    ~tInputs ()
    {
    }

    // tExtRef
    //

    tExtRef::
    tExtRef (const iedName_type& iedName,
             const ldInst_type& ldInst,
             const lnClass_type& lnClass,
             const lnInst_type& lnInst,
             const doName_type& doName)
    : ::xml_schema::type (),
      iedName_ (iedName, ::xml_schema::flags (), this),
      ldInst_ (ldInst, ::xml_schema::flags (), this),
      prefix_ (::xml_schema::flags (), this),
      lnClass_ (lnClass, ::xml_schema::flags (), this),
      lnInst_ (lnInst, ::xml_schema::flags (), this),
      doName_ (doName, ::xml_schema::flags (), this),
      daName_ (::xml_schema::flags (), this),
      intAddr_ (::xml_schema::flags (), this)
    {
    }

    tExtRef::
    tExtRef (const tExtRef& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      iedName_ (x.iedName_, f, this),
      ldInst_ (x.ldInst_, f, this),
      prefix_ (x.prefix_, f, this),
      lnClass_ (x.lnClass_, f, this),
      lnInst_ (x.lnInst_, f, this),
      doName_ (x.doName_, f, this),
      daName_ (x.daName_, f, this),
      intAddr_ (x.intAddr_, f, this)
    {
    }

    tExtRef::
    tExtRef (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      iedName_ (f, this),
      ldInst_ (f, this),
      prefix_ (f, this),
      lnClass_ (f, this),
      lnInst_ (f, this),
      doName_ (f, this),
      daName_ (f, this),
      intAddr_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
        this->parse (p, f);
      }
    }

    void tExtRef::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "iedName" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< iedName_type > r (
            iedName_traits::create (i, f, this));

          this->iedName_.set (r);
          continue;
        }

        if (n.name () == "ldInst" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< ldInst_type > r (
            ldInst_traits::create (i, f, this));

          this->ldInst_.set (r);
          continue;
        }

        if (n.name () == "prefix" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< prefix_type > r (
            prefix_traits::create (i, f, this));

          this->prefix_.set (r);
          continue;
        }

        if (n.name () == "lnClass" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< lnClass_type > r (
            lnClass_traits::create (i, f, this));

          this->lnClass_.set (r);
          continue;
        }

        if (n.name () == "lnInst" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< lnInst_type > r (
            lnInst_traits::create (i, f, this));

          this->lnInst_.set (r);
          continue;
        }

        if (n.name () == "doName" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< doName_type > r (
            doName_traits::create (i, f, this));

          this->doName_.set (r);
          continue;
        }

        if (n.name () == "daName" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< daName_type > r (
            daName_traits::create (i, f, this));

          this->daName_.set (r);
          continue;
        }

        if (n.name () == "intAddr" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< intAddr_type > r (
            intAddr_traits::create (i, f, this));

          this->intAddr_.set (r);
          continue;
        }
      }

      if (!iedName_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "iedName",
          "");
      }

      if (!ldInst_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "ldInst",
          "");
      }

      if (!lnClass_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "lnClass",
          "");
      }

      if (!lnInst_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "lnInst",
          "");
      }

      if (!doName_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "doName",
          "");
      }
    }

    tExtRef* tExtRef::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class tExtRef (*this, f, c);
    }

    tExtRef::
    ~tExtRef ()
    {
    }

    // tLog
    //

    tLog::
    tLog ()
    : ::IEC61850::SCL::tAnyContentFromOtherNamespace ()
    {
    }

    tLog::
    tLog (const tLog& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
    : ::IEC61850::SCL::tAnyContentFromOtherNamespace (x, f, c)
    {
    }

    tLog::
    tLog (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
    : ::IEC61850::SCL::tAnyContentFromOtherNamespace (e, f, c)
    {
    }

    tLog* tLog::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class tLog (*this, f, c);
    }

    tLog::
    ~tLog ()
    {
    }

    // tControlWithIEDName
    //

    tControlWithIEDName::
    tControlWithIEDName (const name_type& name)
    : ::IEC61850::SCL::tControl (name),
      IEDName_ (::xml_schema::flags (), this),
      confRev_ (::xml_schema::flags (), this)
    {
    }

    tControlWithIEDName::
    tControlWithIEDName (const tControlWithIEDName& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::IEC61850::SCL::tControl (x, f, c),
      IEDName_ (x.IEDName_, f, this),
      confRev_ (x.confRev_, f, this)
    {
    }

    tControlWithIEDName::
    tControlWithIEDName (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::IEC61850::SCL::tControl (e, f | ::xml_schema::flags::base, c),
      IEDName_ (f, this),
      confRev_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void tControlWithIEDName::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::IEC61850::SCL::tControl::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // IEDName
        //
        if (n.name () == "IEDName" && n.namespace_ () == "http://www.iec.ch/61850/2003/SCL")
        {
          ::std::auto_ptr< IEDName_type > r (
            IEDName_traits::create (i, f, this));

          this->IEDName_.push_back (r);
          continue;
        }

        break;
      }

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "confRev" && n.namespace_ ().empty ())
        {
          this->confRev_.set (confRev_traits::create (i, f, this));
          continue;
        }
      }
    }

    tControlWithIEDName* tControlWithIEDName::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class tControlWithIEDName (*this, f, c);
    }

    tControlWithIEDName::
    ~tControlWithIEDName ()
    {
    }

    // tGSEControl
    //

    const tGSEControl::type_type tGSEControl::type_default_value_ (
      ::std::string ("GOOSE"), 0, 0, 0);

    tGSEControl::
    tGSEControl (const name_type& name,
                 const appID_type& appID)
    : ::IEC61850::SCL::tControlWithIEDName (name),
      type_ (type_default_value (), ::xml_schema::flags (), this),
      appID_ (appID, ::xml_schema::flags (), this)
    {
    }

    tGSEControl::
    tGSEControl (const tGSEControl& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::IEC61850::SCL::tControlWithIEDName (x, f, c),
      type_ (x.type_, f, this),
      appID_ (x.appID_, f, this)
    {
    }

    tGSEControl::
    tGSEControl (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::IEC61850::SCL::tControlWithIEDName (e, f | ::xml_schema::flags::base, c),
      type_ (f, this),
      appID_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void tGSEControl::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::IEC61850::SCL::tControlWithIEDName::parse (p, f);

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "type" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< type_type > r (
            type_traits::create (i, f, this));

          this->type_.set (r);
          continue;
        }

        if (n.name () == "appID" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< appID_type > r (
            appID_traits::create (i, f, this));

          this->appID_.set (r);
          continue;
        }
      }

      if (!type_.present ())
      {
        this->type_.set (type_default_value ());
      }

      if (!appID_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "appID",
          "");
      }
    }

    tGSEControl* tGSEControl::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class tGSEControl (*this, f, c);
    }

    tGSEControl::
    ~tGSEControl ()
    {
    }

    // tSampledValueControl
    //

    const tSampledValueControl::multicast_type tSampledValueControl::multicast_default_value_ (
      ::xsd::cxx::tree::traits< ::xml_schema::boolean, char >::create (
        ::std::string ("true"), 0, 0, 0));

    tSampledValueControl::
    tSampledValueControl (const name_type& name,
                          const SmvOpts_type& SmvOpts,
                          const smvID_type& smvID,
                          const smpRate_type& smpRate,
                          const nofASDU_type& nofASDU)
    : ::IEC61850::SCL::tControlWithIEDName (name),
      SmvOpts_ (SmvOpts, ::xml_schema::flags (), this),
      smvID_ (smvID, ::xml_schema::flags (), this),
      multicast_ (multicast_default_value (), ::xml_schema::flags (), this),
      smpRate_ (smpRate, ::xml_schema::flags (), this),
      nofASDU_ (nofASDU, ::xml_schema::flags (), this)
    {
    }

    tSampledValueControl::
    tSampledValueControl (const name_type& name,
                          ::std::auto_ptr< SmvOpts_type >& SmvOpts,
                          const smvID_type& smvID,
                          const smpRate_type& smpRate,
                          const nofASDU_type& nofASDU)
    : ::IEC61850::SCL::tControlWithIEDName (name),
      SmvOpts_ (SmvOpts, ::xml_schema::flags (), this),
      smvID_ (smvID, ::xml_schema::flags (), this),
      multicast_ (multicast_default_value (), ::xml_schema::flags (), this),
      smpRate_ (smpRate, ::xml_schema::flags (), this),
      nofASDU_ (nofASDU, ::xml_schema::flags (), this)
    {
    }

    tSampledValueControl::
    tSampledValueControl (const tSampledValueControl& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::IEC61850::SCL::tControlWithIEDName (x, f, c),
      SmvOpts_ (x.SmvOpts_, f, this),
      smvID_ (x.smvID_, f, this),
      multicast_ (x.multicast_, f, this),
      smpRate_ (x.smpRate_, f, this),
      nofASDU_ (x.nofASDU_, f, this)
    {
    }

    tSampledValueControl::
    tSampledValueControl (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::IEC61850::SCL::tControlWithIEDName (e, f | ::xml_schema::flags::base, c),
      SmvOpts_ (f, this),
      smvID_ (f, this),
      multicast_ (f, this),
      smpRate_ (f, this),
      nofASDU_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void tSampledValueControl::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::IEC61850::SCL::tControlWithIEDName::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // SmvOpts
        //
        if (n.name () == "SmvOpts" && n.namespace_ () == "http://www.iec.ch/61850/2003/SCL")
        {
          ::std::auto_ptr< SmvOpts_type > r (
            SmvOpts_traits::create (i, f, this));

          if (!SmvOpts_.present ())
          {
            this->SmvOpts_.set (r);
            continue;
          }
        }

        break;
      }

      if (!SmvOpts_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "SmvOpts",
          "http://www.iec.ch/61850/2003/SCL");
      }

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "smvID" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< smvID_type > r (
            smvID_traits::create (i, f, this));

          this->smvID_.set (r);
          continue;
        }

        if (n.name () == "multicast" && n.namespace_ ().empty ())
        {
          this->multicast_.set (multicast_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "smpRate" && n.namespace_ ().empty ())
        {
          this->smpRate_.set (smpRate_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "nofASDU" && n.namespace_ ().empty ())
        {
          this->nofASDU_.set (nofASDU_traits::create (i, f, this));
          continue;
        }
      }

      if (!smvID_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "smvID",
          "");
      }

      if (!multicast_.present ())
      {
        this->multicast_.set (multicast_default_value ());
      }

      if (!smpRate_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "smpRate",
          "");
      }

      if (!nofASDU_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "nofASDU",
          "");
      }
    }

    tSampledValueControl* tSampledValueControl::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class tSampledValueControl (*this, f, c);
    }

    tSampledValueControl::
    ~tSampledValueControl ()
    {
    }

    // tSettingControl
    //

    const tSettingControl::actSG_type tSettingControl::actSG_default_value_ (
      ::xsd::cxx::tree::traits< ::xml_schema::unsigned_int, char >::create (
        ::std::string ("1"), 0, 0, 0));

    tSettingControl::
    tSettingControl (const numOfSGs_type& numOfSGs)
    : ::IEC61850::SCL::tUnNaming (),
      numOfSGs_ (numOfSGs, ::xml_schema::flags (), this),
      actSG_ (actSG_default_value (), ::xml_schema::flags (), this)
    {
    }

    tSettingControl::
    tSettingControl (const tSettingControl& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::IEC61850::SCL::tUnNaming (x, f, c),
      numOfSGs_ (x.numOfSGs_, f, this),
      actSG_ (x.actSG_, f, this)
    {
    }

    tSettingControl::
    tSettingControl (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::IEC61850::SCL::tUnNaming (e, f | ::xml_schema::flags::base, c),
      numOfSGs_ (f, this),
      actSG_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void tSettingControl::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::IEC61850::SCL::tUnNaming::parse (p, f);

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "numOfSGs" && n.namespace_ ().empty ())
        {
          this->numOfSGs_.set (numOfSGs_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "actSG" && n.namespace_ ().empty ())
        {
          this->actSG_.set (actSG_traits::create (i, f, this));
          continue;
        }
      }

      if (!numOfSGs_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "numOfSGs",
          "");
      }

      if (!actSG_.present ())
      {
        this->actSG_.set (actSG_default_value ());
      }
    }

    tSettingControl* tSettingControl::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class tSettingControl (*this, f, c);
    }

    tSettingControl::
    ~tSettingControl ()
    {
    }

    // tSCLControl
    //

    tSCLControl::
    tSCLControl ()
    : ::IEC61850::SCL::tUnNaming ()
    {
    }

    tSCLControl::
    tSCLControl (const tSCLControl& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::IEC61850::SCL::tUnNaming (x, f, c)
    {
    }

    tSCLControl::
    tSCLControl (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::IEC61850::SCL::tUnNaming (e, f, c)
    {
    }

    tSCLControl* tSCLControl::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class tSCLControl (*this, f, c);
    }

    tSCLControl::
    ~tSCLControl ()
    {
    }

    // tDOI
    //

    tDOI::
    tDOI (const name_type& name)
    : ::IEC61850::SCL::tUnNaming (),
      SDI_ (::xml_schema::flags (), this),
      DAI_ (::xml_schema::flags (), this),
      name_ (name, ::xml_schema::flags (), this),
      ix_ (::xml_schema::flags (), this),
      accessControl_ (::xml_schema::flags (), this)
    {
    }

    tDOI::
    tDOI (const tDOI& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
    : ::IEC61850::SCL::tUnNaming (x, f, c),
      SDI_ (x.SDI_, f, this),
      DAI_ (x.DAI_, f, this),
      name_ (x.name_, f, this),
      ix_ (x.ix_, f, this),
      accessControl_ (x.accessControl_, f, this)
    {
    }

    tDOI::
    tDOI (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
    : ::IEC61850::SCL::tUnNaming (e, f | ::xml_schema::flags::base, c),
      SDI_ (f, this),
      DAI_ (f, this),
      name_ (f, this),
      ix_ (f, this),
      accessControl_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void tDOI::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::IEC61850::SCL::tUnNaming::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // SDI
        //
        if (n.name () == "SDI" && n.namespace_ () == "http://www.iec.ch/61850/2003/SCL")
        {
          ::std::auto_ptr< SDI_type > r (
            SDI_traits::create (i, f, this));

          this->SDI_.push_back (r);
          continue;
        }

        // DAI
        //
        if (n.name () == "DAI" && n.namespace_ () == "http://www.iec.ch/61850/2003/SCL")
        {
          ::std::auto_ptr< DAI_type > r (
            DAI_traits::create (i, f, this));

          this->DAI_.push_back (r);
          continue;
        }

        break;
      }

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "name" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< name_type > r (
            name_traits::create (i, f, this));

          this->name_.set (r);
          continue;
        }

        if (n.name () == "ix" && n.namespace_ ().empty ())
        {
          this->ix_.set (ix_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "accessControl" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< accessControl_type > r (
            accessControl_traits::create (i, f, this));

          this->accessControl_.set (r);
          continue;
        }
      }

      if (!name_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "name",
          "");
      }
    }

    tDOI* tDOI::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class tDOI (*this, f, c);
    }

    tDOI::
    ~tDOI ()
    {
    }

    // tSDI
    //

    tSDI::
    tSDI (const name_type& name)
    : ::IEC61850::SCL::tUnNaming (),
      SDI_ (::xml_schema::flags (), this),
      DAI_ (::xml_schema::flags (), this),
      name_ (name, ::xml_schema::flags (), this),
      ix_ (::xml_schema::flags (), this)
    {
    }

    tSDI::
    tSDI (const tSDI& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
    : ::IEC61850::SCL::tUnNaming (x, f, c),
      SDI_ (x.SDI_, f, this),
      DAI_ (x.DAI_, f, this),
      name_ (x.name_, f, this),
      ix_ (x.ix_, f, this)
    {
    }

    tSDI::
    tSDI (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
    : ::IEC61850::SCL::tUnNaming (e, f | ::xml_schema::flags::base, c),
      SDI_ (f, this),
      DAI_ (f, this),
      name_ (f, this),
      ix_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void tSDI::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::IEC61850::SCL::tUnNaming::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // SDI
        //
        if (n.name () == "SDI" && n.namespace_ () == "http://www.iec.ch/61850/2003/SCL")
        {
          ::std::auto_ptr< SDI_type > r (
            SDI_traits::create (i, f, this));

          this->SDI_.push_back (r);
          continue;
        }

        // DAI
        //
        if (n.name () == "DAI" && n.namespace_ () == "http://www.iec.ch/61850/2003/SCL")
        {
          ::std::auto_ptr< DAI_type > r (
            DAI_traits::create (i, f, this));

          this->DAI_.push_back (r);
          continue;
        }

        break;
      }

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "name" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< name_type > r (
            name_traits::create (i, f, this));

          this->name_.set (r);
          continue;
        }

        if (n.name () == "ix" && n.namespace_ ().empty ())
        {
          this->ix_.set (ix_traits::create (i, f, this));
          continue;
        }
      }

      if (!name_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "name",
          "");
      }
    }

    tSDI* tSDI::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class tSDI (*this, f, c);
    }

    tSDI::
    ~tSDI ()
    {
    }

    // tDAI
    //

    const tDAI::valKind_type tDAI::valKind_default_value_ (
      ::std::string ("Set"), 0, 0, 0);

    tDAI::
    tDAI (const name_type& name)
    : ::IEC61850::SCL::tUnNaming (),
      Val_ (::xml_schema::flags (), this),
      name_ (name, ::xml_schema::flags (), this),
      sAddr_ (::xml_schema::flags (), this),
      valKind_ (valKind_default_value (), ::xml_schema::flags (), this),
      ix_ (::xml_schema::flags (), this)
    {
    }

    tDAI::
    tDAI (const tDAI& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
    : ::IEC61850::SCL::tUnNaming (x, f, c),
      Val_ (x.Val_, f, this),
      name_ (x.name_, f, this),
      sAddr_ (x.sAddr_, f, this),
      valKind_ (x.valKind_, f, this),
      ix_ (x.ix_, f, this)
    {
    }

    tDAI::
    tDAI (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
    : ::IEC61850::SCL::tUnNaming (e, f | ::xml_schema::flags::base, c),
      Val_ (f, this),
      name_ (f, this),
      sAddr_ (f, this),
      valKind_ (f, this),
      ix_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void tDAI::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::IEC61850::SCL::tUnNaming::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Val
        //
        if (n.name () == "Val" && n.namespace_ () == "http://www.iec.ch/61850/2003/SCL")
        {
          ::std::auto_ptr< Val_type > r (
            Val_traits::create (i, f, this));

          this->Val_.push_back (r);
          continue;
        }

        break;
      }

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "name" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< name_type > r (
            name_traits::create (i, f, this));

          this->name_.set (r);
          continue;
        }

        if (n.name () == "sAddr" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< sAddr_type > r (
            sAddr_traits::create (i, f, this));

          this->sAddr_.set (r);
          continue;
        }

        if (n.name () == "valKind" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< valKind_type > r (
            valKind_traits::create (i, f, this));

          this->valKind_.set (r);
          continue;
        }

        if (n.name () == "ix" && n.namespace_ ().empty ())
        {
          this->ix_.set (ix_traits::create (i, f, this));
          continue;
        }
      }

      if (!name_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "name",
          "");
      }

      if (!valKind_.present ())
      {
        this->valKind_.set (valKind_default_value ());
      }
    }

    tDAI* tDAI::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class tDAI (*this, f, c);
    }

    tDAI::
    ~tDAI ()
    {
    }

    // tServiceYesNo
    //

    tServiceYesNo::
    tServiceYesNo ()
    : ::xml_schema::type ()
    {
    }

    tServiceYesNo::
    tServiceYesNo (const tServiceYesNo& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c)
    {
    }

    tServiceYesNo::
    tServiceYesNo (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xml_schema::type (e, f, c)
    {
    }

    tServiceYesNo::
    tServiceYesNo (const ::xercesc::DOMAttr& a,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xml_schema::type (a, f, c)
    {
    }

    tServiceYesNo::
    tServiceYesNo (const ::std::string& s,
                   const ::xercesc::DOMElement* e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xml_schema::type (s, e, f, c)
    {
    }

    tServiceYesNo* tServiceYesNo::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class tServiceYesNo (*this, f, c);
    }

    tServiceYesNo::
    ~tServiceYesNo ()
    {
    }

    // tServiceWithMax
    //

    tServiceWithMax::
    tServiceWithMax (const max_type& max)
    : ::xml_schema::type (),
      max_ (max, ::xml_schema::flags (), this)
    {
    }

    tServiceWithMax::
    tServiceWithMax (const tServiceWithMax& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      max_ (x.max_, f, this)
    {
    }

    tServiceWithMax::
    tServiceWithMax (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      max_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
        this->parse (p, f);
      }
    }

    void tServiceWithMax::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "max" && n.namespace_ ().empty ())
        {
          this->max_.set (max_traits::create (i, f, this));
          continue;
        }
      }

      if (!max_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "max",
          "");
      }
    }

    tServiceWithMax* tServiceWithMax::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class tServiceWithMax (*this, f, c);
    }

    tServiceWithMax::
    ~tServiceWithMax ()
    {
    }

    // tServiceWithMaxAndMaxAttributes
    //

    tServiceWithMaxAndMaxAttributes::
    tServiceWithMaxAndMaxAttributes (const max_type& max)
    : ::IEC61850::SCL::tServiceWithMax (max),
      maxAttributes_ (::xml_schema::flags (), this)
    {
    }

    tServiceWithMaxAndMaxAttributes::
    tServiceWithMaxAndMaxAttributes (const tServiceWithMaxAndMaxAttributes& x,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
    : ::IEC61850::SCL::tServiceWithMax (x, f, c),
      maxAttributes_ (x.maxAttributes_, f, this)
    {
    }

    tServiceWithMaxAndMaxAttributes::
    tServiceWithMaxAndMaxAttributes (const ::xercesc::DOMElement& e,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
    : ::IEC61850::SCL::tServiceWithMax (e, f | ::xml_schema::flags::base, c),
      maxAttributes_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
        this->parse (p, f);
      }
    }

    void tServiceWithMaxAndMaxAttributes::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::IEC61850::SCL::tServiceWithMax::parse (p, f);

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "maxAttributes" && n.namespace_ ().empty ())
        {
          this->maxAttributes_.set (maxAttributes_traits::create (i, f, this));
          continue;
        }
      }
    }

    tServiceWithMaxAndMaxAttributes* tServiceWithMaxAndMaxAttributes::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class tServiceWithMaxAndMaxAttributes (*this, f, c);
    }

    tServiceWithMaxAndMaxAttributes::
    ~tServiceWithMaxAndMaxAttributes ()
    {
    }

    // tServiceWithMaxAndModify
    //

    const tServiceWithMaxAndModify::modify_type tServiceWithMaxAndModify::modify_default_value_ (
      ::xsd::cxx::tree::traits< ::xml_schema::boolean, char >::create (
        ::std::string ("true"), 0, 0, 0));

    tServiceWithMaxAndModify::
    tServiceWithMaxAndModify (const max_type& max)
    : ::IEC61850::SCL::tServiceWithMax (max),
      modify_ (modify_default_value (), ::xml_schema::flags (), this)
    {
    }

    tServiceWithMaxAndModify::
    tServiceWithMaxAndModify (const tServiceWithMaxAndModify& x,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::IEC61850::SCL::tServiceWithMax (x, f, c),
      modify_ (x.modify_, f, this)
    {
    }

    tServiceWithMaxAndModify::
    tServiceWithMaxAndModify (const ::xercesc::DOMElement& e,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::IEC61850::SCL::tServiceWithMax (e, f | ::xml_schema::flags::base, c),
      modify_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
        this->parse (p, f);
      }
    }

    void tServiceWithMaxAndModify::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::IEC61850::SCL::tServiceWithMax::parse (p, f);

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "modify" && n.namespace_ ().empty ())
        {
          this->modify_.set (modify_traits::create (i, f, this));
          continue;
        }
      }

      if (!modify_.present ())
      {
        this->modify_.set (modify_default_value ());
      }
    }

    tServiceWithMaxAndModify* tServiceWithMaxAndModify::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class tServiceWithMaxAndModify (*this, f, c);
    }

    tServiceWithMaxAndModify::
    ~tServiceWithMaxAndModify ()
    {
    }

    // tServiceWithMaxAndMaxAttributesAndModify
    //

    const tServiceWithMaxAndMaxAttributesAndModify::modify_type tServiceWithMaxAndMaxAttributesAndModify::modify_default_value_ (
      ::xsd::cxx::tree::traits< ::xml_schema::boolean, char >::create (
        ::std::string ("true"), 0, 0, 0));

    tServiceWithMaxAndMaxAttributesAndModify::
    tServiceWithMaxAndMaxAttributesAndModify (const max_type& max)
    : ::IEC61850::SCL::tServiceWithMaxAndMaxAttributes (max),
      modify_ (modify_default_value (), ::xml_schema::flags (), this)
    {
    }

    tServiceWithMaxAndMaxAttributesAndModify::
    tServiceWithMaxAndMaxAttributesAndModify (const tServiceWithMaxAndMaxAttributesAndModify& x,
                                              ::xml_schema::flags f,
                                              ::xml_schema::container* c)
    : ::IEC61850::SCL::tServiceWithMaxAndMaxAttributes (x, f, c),
      modify_ (x.modify_, f, this)
    {
    }

    tServiceWithMaxAndMaxAttributesAndModify::
    tServiceWithMaxAndMaxAttributesAndModify (const ::xercesc::DOMElement& e,
                                              ::xml_schema::flags f,
                                              ::xml_schema::container* c)
    : ::IEC61850::SCL::tServiceWithMaxAndMaxAttributes (e, f | ::xml_schema::flags::base, c),
      modify_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
        this->parse (p, f);
      }
    }

    void tServiceWithMaxAndMaxAttributesAndModify::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::IEC61850::SCL::tServiceWithMaxAndMaxAttributes::parse (p, f);

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "modify" && n.namespace_ ().empty ())
        {
          this->modify_.set (modify_traits::create (i, f, this));
          continue;
        }
      }

      if (!modify_.present ())
      {
        this->modify_.set (modify_default_value ());
      }
    }

    tServiceWithMaxAndMaxAttributesAndModify* tServiceWithMaxAndMaxAttributesAndModify::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class tServiceWithMaxAndMaxAttributesAndModify (*this, f, c);
    }

    tServiceWithMaxAndMaxAttributesAndModify::
    ~tServiceWithMaxAndMaxAttributesAndModify ()
    {
    }

    // tClientServices
    //

    const tClientServices::goose_type tClientServices::goose_default_value_ (
      ::xsd::cxx::tree::traits< ::xml_schema::boolean, char >::create (
        ::std::string ("false"), 0, 0, 0));

    const tClientServices::gsse_type tClientServices::gsse_default_value_ (
      ::xsd::cxx::tree::traits< ::xml_schema::boolean, char >::create (
        ::std::string ("false"), 0, 0, 0));

    const tClientServices::bufReport_type tClientServices::bufReport_default_value_ (
      ::xsd::cxx::tree::traits< ::xml_schema::boolean, char >::create (
        ::std::string ("false"), 0, 0, 0));

    const tClientServices::unbufReport_type tClientServices::unbufReport_default_value_ (
      ::xsd::cxx::tree::traits< ::xml_schema::boolean, char >::create (
        ::std::string ("false"), 0, 0, 0));

    const tClientServices::readLog_type tClientServices::readLog_default_value_ (
      ::xsd::cxx::tree::traits< ::xml_schema::boolean, char >::create (
        ::std::string ("false"), 0, 0, 0));

    tClientServices::
    tClientServices ()
    : ::xml_schema::type (),
      goose_ (goose_default_value (), ::xml_schema::flags (), this),
      gsse_ (gsse_default_value (), ::xml_schema::flags (), this),
      bufReport_ (bufReport_default_value (), ::xml_schema::flags (), this),
      unbufReport_ (unbufReport_default_value (), ::xml_schema::flags (), this),
      readLog_ (readLog_default_value (), ::xml_schema::flags (), this)
    {
    }

    tClientServices::
    tClientServices (const tClientServices& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      goose_ (x.goose_, f, this),
      gsse_ (x.gsse_, f, this),
      bufReport_ (x.bufReport_, f, this),
      unbufReport_ (x.unbufReport_, f, this),
      readLog_ (x.readLog_, f, this)
    {
    }

    tClientServices::
    tClientServices (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      goose_ (f, this),
      gsse_ (f, this),
      bufReport_ (f, this),
      unbufReport_ (f, this),
      readLog_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
        this->parse (p, f);
      }
    }

    void tClientServices::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "goose" && n.namespace_ ().empty ())
        {
          this->goose_.set (goose_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "gsse" && n.namespace_ ().empty ())
        {
          this->gsse_.set (gsse_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "bufReport" && n.namespace_ ().empty ())
        {
          this->bufReport_.set (bufReport_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "unbufReport" && n.namespace_ ().empty ())
        {
          this->unbufReport_.set (unbufReport_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "readLog" && n.namespace_ ().empty ())
        {
          this->readLog_.set (readLog_traits::create (i, f, this));
          continue;
        }
      }

      if (!goose_.present ())
      {
        this->goose_.set (goose_default_value ());
      }

      if (!gsse_.present ())
      {
        this->gsse_.set (gsse_default_value ());
      }

      if (!bufReport_.present ())
      {
        this->bufReport_.set (bufReport_default_value ());
      }

      if (!unbufReport_.present ())
      {
        this->unbufReport_.set (unbufReport_default_value ());
      }

      if (!readLog_.present ())
      {
        this->readLog_.set (readLog_default_value ());
      }
    }

    tClientServices* tClientServices::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class tClientServices (*this, f, c);
    }

    tClientServices::
    ~tClientServices ()
    {
    }

    // tServiceSettings
    //

    const tServiceSettings::cbName_type tServiceSettings::cbName_default_value_ (
      ::std::string ("Fix"), 0, 0, 0);

    const tServiceSettings::datSet_type tServiceSettings::datSet_default_value_ (
      ::std::string ("Fix"), 0, 0, 0);

    tServiceSettings::
    tServiceSettings ()
    : ::xml_schema::type (),
      cbName_ (cbName_default_value (), ::xml_schema::flags (), this),
      datSet_ (datSet_default_value (), ::xml_schema::flags (), this)
    {
    }

    tServiceSettings::
    tServiceSettings (const tServiceSettings& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      cbName_ (x.cbName_, f, this),
      datSet_ (x.datSet_, f, this)
    {
    }

    tServiceSettings::
    tServiceSettings (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      cbName_ (f, this),
      datSet_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
        this->parse (p, f);
      }
    }

    void tServiceSettings::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "cbName" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< cbName_type > r (
            cbName_traits::create (i, f, this));

          this->cbName_.set (r);
          continue;
        }

        if (n.name () == "datSet" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< datSet_type > r (
            datSet_traits::create (i, f, this));

          this->datSet_.set (r);
          continue;
        }
      }

      if (!cbName_.present ())
      {
        this->cbName_.set (cbName_default_value ());
      }

      if (!datSet_.present ())
      {
        this->datSet_.set (datSet_default_value ());
      }
    }

    tServiceSettings* tServiceSettings::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class tServiceSettings (*this, f, c);
    }

    tServiceSettings::
    ~tServiceSettings ()
    {
    }

    // tReportSettings
    //

    const tReportSettings::rptID_type tReportSettings::rptID_default_value_ (
      ::std::string ("Fix"), 0, 0, 0);

    const tReportSettings::optFields_type tReportSettings::optFields_default_value_ (
      ::std::string ("Fix"), 0, 0, 0);

    const tReportSettings::bufTime_type tReportSettings::bufTime_default_value_ (
      ::std::string ("Fix"), 0, 0, 0);

    const tReportSettings::trgOps_type tReportSettings::trgOps_default_value_ (
      ::std::string ("Fix"), 0, 0, 0);

    const tReportSettings::intgPd_type tReportSettings::intgPd_default_value_ (
      ::std::string ("Fix"), 0, 0, 0);

    tReportSettings::
    tReportSettings ()
    : ::IEC61850::SCL::tServiceSettings (),
      rptID_ (rptID_default_value (), ::xml_schema::flags (), this),
      optFields_ (optFields_default_value (), ::xml_schema::flags (), this),
      bufTime_ (bufTime_default_value (), ::xml_schema::flags (), this),
      trgOps_ (trgOps_default_value (), ::xml_schema::flags (), this),
      intgPd_ (intgPd_default_value (), ::xml_schema::flags (), this)
    {
    }

    tReportSettings::
    tReportSettings (const tReportSettings& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::IEC61850::SCL::tServiceSettings (x, f, c),
      rptID_ (x.rptID_, f, this),
      optFields_ (x.optFields_, f, this),
      bufTime_ (x.bufTime_, f, this),
      trgOps_ (x.trgOps_, f, this),
      intgPd_ (x.intgPd_, f, this)
    {
    }

    tReportSettings::
    tReportSettings (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::IEC61850::SCL::tServiceSettings (e, f | ::xml_schema::flags::base, c),
      rptID_ (f, this),
      optFields_ (f, this),
      bufTime_ (f, this),
      trgOps_ (f, this),
      intgPd_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
        this->parse (p, f);
      }
    }

    void tReportSettings::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::IEC61850::SCL::tServiceSettings::parse (p, f);

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "rptID" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< rptID_type > r (
            rptID_traits::create (i, f, this));

          this->rptID_.set (r);
          continue;
        }

        if (n.name () == "optFields" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< optFields_type > r (
            optFields_traits::create (i, f, this));

          this->optFields_.set (r);
          continue;
        }

        if (n.name () == "bufTime" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< bufTime_type > r (
            bufTime_traits::create (i, f, this));

          this->bufTime_.set (r);
          continue;
        }

        if (n.name () == "trgOps" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< trgOps_type > r (
            trgOps_traits::create (i, f, this));

          this->trgOps_.set (r);
          continue;
        }

        if (n.name () == "intgPd" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< intgPd_type > r (
            intgPd_traits::create (i, f, this));

          this->intgPd_.set (r);
          continue;
        }
      }

      if (!rptID_.present ())
      {
        this->rptID_.set (rptID_default_value ());
      }

      if (!optFields_.present ())
      {
        this->optFields_.set (optFields_default_value ());
      }

      if (!bufTime_.present ())
      {
        this->bufTime_.set (bufTime_default_value ());
      }

      if (!trgOps_.present ())
      {
        this->trgOps_.set (trgOps_default_value ());
      }

      if (!intgPd_.present ())
      {
        this->intgPd_.set (intgPd_default_value ());
      }
    }

    tReportSettings* tReportSettings::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class tReportSettings (*this, f, c);
    }

    tReportSettings::
    ~tReportSettings ()
    {
    }

    // tLogSettings
    //

    const tLogSettings::logEna_type tLogSettings::logEna_default_value_ (
      ::std::string ("Fix"), 0, 0, 0);

    const tLogSettings::trgOps_type tLogSettings::trgOps_default_value_ (
      ::std::string ("Fix"), 0, 0, 0);

    const tLogSettings::intgPd_type tLogSettings::intgPd_default_value_ (
      ::std::string ("Fix"), 0, 0, 0);

    tLogSettings::
    tLogSettings ()
    : ::IEC61850::SCL::tServiceSettings (),
      logEna_ (logEna_default_value (), ::xml_schema::flags (), this),
      trgOps_ (trgOps_default_value (), ::xml_schema::flags (), this),
      intgPd_ (intgPd_default_value (), ::xml_schema::flags (), this)
    {
    }

    tLogSettings::
    tLogSettings (const tLogSettings& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::IEC61850::SCL::tServiceSettings (x, f, c),
      logEna_ (x.logEna_, f, this),
      trgOps_ (x.trgOps_, f, this),
      intgPd_ (x.intgPd_, f, this)
    {
    }

    tLogSettings::
    tLogSettings (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::IEC61850::SCL::tServiceSettings (e, f | ::xml_schema::flags::base, c),
      logEna_ (f, this),
      trgOps_ (f, this),
      intgPd_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
        this->parse (p, f);
      }
    }

    void tLogSettings::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::IEC61850::SCL::tServiceSettings::parse (p, f);

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "logEna" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< logEna_type > r (
            logEna_traits::create (i, f, this));

          this->logEna_.set (r);
          continue;
        }

        if (n.name () == "trgOps" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< trgOps_type > r (
            trgOps_traits::create (i, f, this));

          this->trgOps_.set (r);
          continue;
        }

        if (n.name () == "intgPd" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< intgPd_type > r (
            intgPd_traits::create (i, f, this));

          this->intgPd_.set (r);
          continue;
        }
      }

      if (!logEna_.present ())
      {
        this->logEna_.set (logEna_default_value ());
      }

      if (!trgOps_.present ())
      {
        this->trgOps_.set (trgOps_default_value ());
      }

      if (!intgPd_.present ())
      {
        this->intgPd_.set (intgPd_default_value ());
      }
    }

    tLogSettings* tLogSettings::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class tLogSettings (*this, f, c);
    }

    tLogSettings::
    ~tLogSettings ()
    {
    }

    // tGSESettings
    //

    const tGSESettings::appID_type tGSESettings::appID_default_value_ (
      ::std::string ("Fix"), 0, 0, 0);

    const tGSESettings::dataLabel_type tGSESettings::dataLabel_default_value_ (
      ::std::string ("Fix"), 0, 0, 0);

    tGSESettings::
    tGSESettings ()
    : ::IEC61850::SCL::tServiceSettings (),
      appID_ (appID_default_value (), ::xml_schema::flags (), this),
      dataLabel_ (dataLabel_default_value (), ::xml_schema::flags (), this)
    {
    }

    tGSESettings::
    tGSESettings (const tGSESettings& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::IEC61850::SCL::tServiceSettings (x, f, c),
      appID_ (x.appID_, f, this),
      dataLabel_ (x.dataLabel_, f, this)
    {
    }

    tGSESettings::
    tGSESettings (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::IEC61850::SCL::tServiceSettings (e, f | ::xml_schema::flags::base, c),
      appID_ (f, this),
      dataLabel_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
        this->parse (p, f);
      }
    }

    void tGSESettings::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::IEC61850::SCL::tServiceSettings::parse (p, f);

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "appID" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< appID_type > r (
            appID_traits::create (i, f, this));

          this->appID_.set (r);
          continue;
        }

        if (n.name () == "dataLabel" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< dataLabel_type > r (
            dataLabel_traits::create (i, f, this));

          this->dataLabel_.set (r);
          continue;
        }
      }

      if (!appID_.present ())
      {
        this->appID_.set (appID_default_value ());
      }

      if (!dataLabel_.present ())
      {
        this->dataLabel_.set (dataLabel_default_value ());
      }
    }

    tGSESettings* tGSESettings::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class tGSESettings (*this, f, c);
    }

    tGSESettings::
    ~tGSESettings ()
    {
    }

    // tSMVSettings
    //

    const tSMVSettings::svID_type tSMVSettings::svID_default_value_ (
      ::std::string ("Fix"), 0, 0, 0);

    const tSMVSettings::optFields_type tSMVSettings::optFields_default_value_ (
      ::std::string ("Fix"), 0, 0, 0);

    const tSMVSettings::smpRate_type tSMVSettings::smpRate_default_value_ (
      ::std::string ("Fix"), 0, 0, 0);

    tSMVSettings::
    tSMVSettings ()
    : ::IEC61850::SCL::tServiceSettings (),
      SmpRate_ (::xml_schema::flags (), this),
      svID_ (svID_default_value (), ::xml_schema::flags (), this),
      optFields_ (optFields_default_value (), ::xml_schema::flags (), this),
      smpRate_ (smpRate_default_value (), ::xml_schema::flags (), this)
    {
    }

    tSMVSettings::
    tSMVSettings (const tSMVSettings& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::IEC61850::SCL::tServiceSettings (x, f, c),
      SmpRate_ (x.SmpRate_, f, this),
      svID_ (x.svID_, f, this),
      optFields_ (x.optFields_, f, this),
      smpRate_ (x.smpRate_, f, this)
    {
    }

    tSMVSettings::
    tSMVSettings (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::IEC61850::SCL::tServiceSettings (e, f | ::xml_schema::flags::base, c),
      SmpRate_ (f, this),
      svID_ (f, this),
      optFields_ (f, this),
      smpRate_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void tSMVSettings::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::IEC61850::SCL::tServiceSettings::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // SmpRate
        //
        if (n.name () == "SmpRate" && n.namespace_ () == "http://www.iec.ch/61850/2003/SCL")
        {
          ::std::auto_ptr< SmpRate_type > r (
            SmpRate_traits::create (i, f, this));

          this->SmpRate_.push_back (r);
          continue;
        }

        break;
      }

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "svID" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< svID_type > r (
            svID_traits::create (i, f, this));

          this->svID_.set (r);
          continue;
        }

        if (n.name () == "optFields" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< optFields_type > r (
            optFields_traits::create (i, f, this));

          this->optFields_.set (r);
          continue;
        }

        if (n.name () == "smpRate" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< smpRate_type > r (
            smpRate_traits::create (i, f, this));

          this->smpRate_.set (r);
          continue;
        }
      }

      if (!svID_.present ())
      {
        this->svID_.set (svID_default_value ());
      }

      if (!optFields_.present ())
      {
        this->optFields_.set (optFields_default_value ());
      }

      if (!smpRate_.present ())
      {
        this->smpRate_.set (smpRate_default_value ());
      }
    }

    tSMVSettings* tSMVSettings::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class tSMVSettings (*this, f, c);
    }

    tSMVSettings::
    ~tSMVSettings ()
    {
    }

    // tConfLNs
    //

    const tConfLNs::fixPrefix_type tConfLNs::fixPrefix_default_value_ (
      ::xsd::cxx::tree::traits< ::xml_schema::boolean, char >::create (
        ::std::string ("false"), 0, 0, 0));

    const tConfLNs::fixLnInst_type tConfLNs::fixLnInst_default_value_ (
      ::xsd::cxx::tree::traits< ::xml_schema::boolean, char >::create (
        ::std::string ("false"), 0, 0, 0));

    tConfLNs::
    tConfLNs ()
    : ::xml_schema::type (),
      fixPrefix_ (fixPrefix_default_value (), ::xml_schema::flags (), this),
      fixLnInst_ (fixLnInst_default_value (), ::xml_schema::flags (), this)
    {
    }

    tConfLNs::
    tConfLNs (const tConfLNs& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      fixPrefix_ (x.fixPrefix_, f, this),
      fixLnInst_ (x.fixLnInst_, f, this)
    {
    }

    tConfLNs::
    tConfLNs (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      fixPrefix_ (f, this),
      fixLnInst_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
        this->parse (p, f);
      }
    }

    void tConfLNs::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "fixPrefix" && n.namespace_ ().empty ())
        {
          this->fixPrefix_.set (fixPrefix_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "fixLnInst" && n.namespace_ ().empty ())
        {
          this->fixLnInst_.set (fixLnInst_traits::create (i, f, this));
          continue;
        }
      }

      if (!fixPrefix_.present ())
      {
        this->fixPrefix_.set (fixPrefix_default_value ());
      }

      if (!fixLnInst_.present ())
      {
        this->fixLnInst_.set (fixLnInst_default_value ());
      }
    }

    tConfLNs* tConfLNs::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class tConfLNs (*this, f, c);
    }

    tConfLNs::
    ~tConfLNs ()
    {
    }

    // SettingGroups
    //

    SettingGroups::
    SettingGroups ()
    : ::xml_schema::type (),
      SGEdit_ (::xml_schema::flags (), this),
      ConfSG_ (::xml_schema::flags (), this)
    {
    }

    SettingGroups::
    SettingGroups (const SettingGroups& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      SGEdit_ (x.SGEdit_, f, this),
      ConfSG_ (x.ConfSG_, f, this)
    {
    }

    SettingGroups::
    SettingGroups (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      SGEdit_ (f, this),
      ConfSG_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void SettingGroups::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // SGEdit
        //
        if (n.name () == "SGEdit" && n.namespace_ () == "http://www.iec.ch/61850/2003/SCL")
        {
          ::std::auto_ptr< SGEdit_type > r (
            SGEdit_traits::create (i, f, this));

          if (!this->SGEdit_)
          {
            this->SGEdit_.set (r);
            continue;
          }
        }

        // ConfSG
        //
        if (n.name () == "ConfSG" && n.namespace_ () == "http://www.iec.ch/61850/2003/SCL")
        {
          ::std::auto_ptr< ConfSG_type > r (
            ConfSG_traits::create (i, f, this));

          if (!this->ConfSG_)
          {
            this->ConfSG_.set (r);
            continue;
          }
        }

        break;
      }
    }

    SettingGroups* SettingGroups::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SettingGroups (*this, f, c);
    }

    SettingGroups::
    ~SettingGroups ()
    {
    }

    // Authentication
    //

    const Authentication::none_type Authentication::none_default_value_ (
      ::xsd::cxx::tree::traits< ::xml_schema::boolean, char >::create (
        ::std::string ("true"), 0, 0, 0));

    const Authentication::password_type Authentication::password_default_value_ (
      ::xsd::cxx::tree::traits< ::xml_schema::boolean, char >::create (
        ::std::string ("false"), 0, 0, 0));

    const Authentication::weak_type Authentication::weak_default_value_ (
      ::xsd::cxx::tree::traits< ::xml_schema::boolean, char >::create (
        ::std::string ("false"), 0, 0, 0));

    const Authentication::strong_type Authentication::strong_default_value_ (
      ::xsd::cxx::tree::traits< ::xml_schema::boolean, char >::create (
        ::std::string ("false"), 0, 0, 0));

    const Authentication::certificate_type Authentication::certificate_default_value_ (
      ::xsd::cxx::tree::traits< ::xml_schema::boolean, char >::create (
        ::std::string ("false"), 0, 0, 0));

    Authentication::
    Authentication ()
    : ::xml_schema::type (),
      none_ (none_default_value (), ::xml_schema::flags (), this),
      password_ (password_default_value (), ::xml_schema::flags (), this),
      weak_ (weak_default_value (), ::xml_schema::flags (), this),
      strong_ (strong_default_value (), ::xml_schema::flags (), this),
      certificate_ (certificate_default_value (), ::xml_schema::flags (), this)
    {
    }

    Authentication::
    Authentication (const Authentication& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      none_ (x.none_, f, this),
      password_ (x.password_, f, this),
      weak_ (x.weak_, f, this),
      strong_ (x.strong_, f, this),
      certificate_ (x.certificate_, f, this)
    {
    }

    Authentication::
    Authentication (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      none_ (f, this),
      password_ (f, this),
      weak_ (f, this),
      strong_ (f, this),
      certificate_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
        this->parse (p, f);
      }
    }

    void Authentication::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "none" && n.namespace_ ().empty ())
        {
          this->none_.set (none_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "password" && n.namespace_ ().empty ())
        {
          this->password_.set (password_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "weak" && n.namespace_ ().empty ())
        {
          this->weak_.set (weak_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "strong" && n.namespace_ ().empty ())
        {
          this->strong_.set (strong_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "certificate" && n.namespace_ ().empty ())
        {
          this->certificate_.set (certificate_traits::create (i, f, this));
          continue;
        }
      }

      if (!none_.present ())
      {
        this->none_.set (none_default_value ());
      }

      if (!password_.present ())
      {
        this->password_.set (password_default_value ());
      }

      if (!weak_.present ())
      {
        this->weak_.set (weak_default_value ());
      }

      if (!strong_.present ())
      {
        this->strong_.set (strong_default_value ());
      }

      if (!certificate_.present ())
      {
        this->certificate_.set (certificate_default_value ());
      }
    }

    Authentication* Authentication::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class Authentication (*this, f, c);
    }

    Authentication::
    ~Authentication ()
    {
    }

    // LN0
    //

    LN0::
    LN0 (const lnType_type& lnType,
         const inst_type& inst)
    : ::IEC61850::SCL::tLN0 (lnType,
                             inst)
    {
    }

    LN0::
    LN0 (const LN0& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
    : ::IEC61850::SCL::tLN0 (x, f, c)
    {
    }

    LN0::
    LN0 (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
    : ::IEC61850::SCL::tLN0 (e, f, c)
    {
    }

    LN0* LN0::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class LN0 (*this, f, c);
    }

    LN0::
    ~LN0 ()
    {
    }

    // OptFields
    //

    const OptFields::seqNum_type OptFields::seqNum_default_value_ (
      ::xsd::cxx::tree::traits< ::xml_schema::boolean, char >::create (
        ::std::string ("false"), 0, 0, 0));

    const OptFields::timeStamp_type OptFields::timeStamp_default_value_ (
      ::xsd::cxx::tree::traits< ::xml_schema::boolean, char >::create (
        ::std::string ("false"), 0, 0, 0));

    const OptFields::dataSet_type OptFields::dataSet_default_value_ (
      ::xsd::cxx::tree::traits< ::xml_schema::boolean, char >::create (
        ::std::string ("false"), 0, 0, 0));

    const OptFields::reasonCode_type OptFields::reasonCode_default_value_ (
      ::xsd::cxx::tree::traits< ::xml_schema::boolean, char >::create (
        ::std::string ("false"), 0, 0, 0));

    const OptFields::dataRef_type OptFields::dataRef_default_value_ (
      ::xsd::cxx::tree::traits< ::xml_schema::boolean, char >::create (
        ::std::string ("false"), 0, 0, 0));

    const OptFields::entryID_type OptFields::entryID_default_value_ (
      ::xsd::cxx::tree::traits< ::xml_schema::boolean, char >::create (
        ::std::string ("false"), 0, 0, 0));

    const OptFields::configRef_type OptFields::configRef_default_value_ (
      ::xsd::cxx::tree::traits< ::xml_schema::boolean, char >::create (
        ::std::string ("false"), 0, 0, 0));

    OptFields::
    OptFields ()
    : ::xml_schema::type (),
      seqNum_ (seqNum_default_value (), ::xml_schema::flags (), this),
      timeStamp_ (timeStamp_default_value (), ::xml_schema::flags (), this),
      dataSet_ (dataSet_default_value (), ::xml_schema::flags (), this),
      reasonCode_ (reasonCode_default_value (), ::xml_schema::flags (), this),
      dataRef_ (dataRef_default_value (), ::xml_schema::flags (), this),
      entryID_ (entryID_default_value (), ::xml_schema::flags (), this),
      configRef_ (configRef_default_value (), ::xml_schema::flags (), this)
    {
    }

    OptFields::
    OptFields (const OptFields& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      seqNum_ (x.seqNum_, f, this),
      timeStamp_ (x.timeStamp_, f, this),
      dataSet_ (x.dataSet_, f, this),
      reasonCode_ (x.reasonCode_, f, this),
      dataRef_ (x.dataRef_, f, this),
      entryID_ (x.entryID_, f, this),
      configRef_ (x.configRef_, f, this)
    {
    }

    OptFields::
    OptFields (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      seqNum_ (f, this),
      timeStamp_ (f, this),
      dataSet_ (f, this),
      reasonCode_ (f, this),
      dataRef_ (f, this),
      entryID_ (f, this),
      configRef_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
        this->parse (p, f);
      }
    }

    void OptFields::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "seqNum" && n.namespace_ ().empty ())
        {
          this->seqNum_.set (seqNum_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "timeStamp" && n.namespace_ ().empty ())
        {
          this->timeStamp_.set (timeStamp_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "dataSet" && n.namespace_ ().empty ())
        {
          this->dataSet_.set (dataSet_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "reasonCode" && n.namespace_ ().empty ())
        {
          this->reasonCode_.set (reasonCode_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "dataRef" && n.namespace_ ().empty ())
        {
          this->dataRef_.set (dataRef_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "entryID" && n.namespace_ ().empty ())
        {
          this->entryID_.set (entryID_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "configRef" && n.namespace_ ().empty ())
        {
          this->configRef_.set (configRef_traits::create (i, f, this));
          continue;
        }
      }

      if (!seqNum_.present ())
      {
        this->seqNum_.set (seqNum_default_value ());
      }

      if (!timeStamp_.present ())
      {
        this->timeStamp_.set (timeStamp_default_value ());
      }

      if (!dataSet_.present ())
      {
        this->dataSet_.set (dataSet_default_value ());
      }

      if (!reasonCode_.present ())
      {
        this->reasonCode_.set (reasonCode_default_value ());
      }

      if (!dataRef_.present ())
      {
        this->dataRef_.set (dataRef_default_value ());
      }

      if (!entryID_.present ())
      {
        this->entryID_.set (entryID_default_value ());
      }

      if (!configRef_.present ())
      {
        this->configRef_.set (configRef_default_value ());
      }
    }

    OptFields* OptFields::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class OptFields (*this, f, c);
    }

    OptFields::
    ~OptFields ()
    {
    }

    // SmvOpts
    //

    const SmvOpts::refreshTime_type SmvOpts::refreshTime_default_value_ (
      ::xsd::cxx::tree::traits< ::xml_schema::boolean, char >::create (
        ::std::string ("false"), 0, 0, 0));

    const SmvOpts::sampleSynchronized_type SmvOpts::sampleSynchronized_default_value_ (
      ::xsd::cxx::tree::traits< ::xml_schema::boolean, char >::create (
        ::std::string ("true"), 0, 0, 0));

    const SmvOpts::sampleRate_type SmvOpts::sampleRate_default_value_ (
      ::xsd::cxx::tree::traits< ::xml_schema::boolean, char >::create (
        ::std::string ("false"), 0, 0, 0));

    const SmvOpts::dataSet_type SmvOpts::dataSet_default_value_ (
      ::xsd::cxx::tree::traits< ::xml_schema::boolean, char >::create (
        ::std::string ("false"), 0, 0, 0));

    const SmvOpts::security_type SmvOpts::security_default_value_ (
      ::xsd::cxx::tree::traits< ::xml_schema::boolean, char >::create (
        ::std::string ("false"), 0, 0, 0));

    SmvOpts::
    SmvOpts ()
    : ::xml_schema::type (),
      refreshTime_ (refreshTime_default_value (), ::xml_schema::flags (), this),
      sampleSynchronized_ (sampleSynchronized_default_value (), ::xml_schema::flags (), this),
      sampleRate_ (sampleRate_default_value (), ::xml_schema::flags (), this),
      dataSet_ (dataSet_default_value (), ::xml_schema::flags (), this),
      security_ (security_default_value (), ::xml_schema::flags (), this)
    {
    }

    SmvOpts::
    SmvOpts (const SmvOpts& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      refreshTime_ (x.refreshTime_, f, this),
      sampleSynchronized_ (x.sampleSynchronized_, f, this),
      sampleRate_ (x.sampleRate_, f, this),
      dataSet_ (x.dataSet_, f, this),
      security_ (x.security_, f, this)
    {
    }

    SmvOpts::
    SmvOpts (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      refreshTime_ (f, this),
      sampleSynchronized_ (f, this),
      sampleRate_ (f, this),
      dataSet_ (f, this),
      security_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
        this->parse (p, f);
      }
    }

    void SmvOpts::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "refreshTime" && n.namespace_ ().empty ())
        {
          this->refreshTime_.set (refreshTime_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "sampleSynchronized" && n.namespace_ ().empty ())
        {
          this->sampleSynchronized_.set (sampleSynchronized_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "sampleRate" && n.namespace_ ().empty ())
        {
          this->sampleRate_.set (sampleRate_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "dataSet" && n.namespace_ ().empty ())
        {
          this->dataSet_.set (dataSet_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "security" && n.namespace_ ().empty ())
        {
          this->security_.set (security_traits::create (i, f, this));
          continue;
        }
      }

      if (!refreshTime_.present ())
      {
        this->refreshTime_.set (refreshTime_default_value ());
      }

      if (!sampleSynchronized_.present ())
      {
        this->sampleSynchronized_.set (sampleSynchronized_default_value ());
      }

      if (!sampleRate_.present ())
      {
        this->sampleRate_.set (sampleRate_default_value ());
      }

      if (!dataSet_.present ())
      {
        this->dataSet_.set (dataSet_default_value ());
      }

      if (!security_.present ())
      {
        this->security_.set (security_default_value ());
      }
    }

    SmvOpts* SmvOpts::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SmvOpts (*this, f, c);
    }

    SmvOpts::
    ~SmvOpts ()
    {
    }

    // SmpRate
    //

    SmpRate::
    SmpRate (const ::xml_schema::decimal& _xsd_decimal_base)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (_xsd_decimal_base)
    {
    }

    SmpRate::
    SmpRate (const SmpRate& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (x, f, c)
    {
    }

    SmpRate::
    SmpRate (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (e, f, c)
    {
    }

    SmpRate::
    SmpRate (const ::xercesc::DOMAttr& a,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (a, f, c)
    {
    }

    SmpRate::
    SmpRate (const ::std::string& s,
             const ::xercesc::DOMElement* e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (s, e, f, c)
    {
    }

    SmpRate* SmpRate::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SmpRate (*this, f, c);
    }

    SmpRate::
    ~SmpRate ()
    {
    }
  }
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

namespace IEC61850
{
  namespace SCL
  {
  }
}

#include <ostream>
#include <xsd/cxx/xml/dom/serialization-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

namespace IEC61850
{
  namespace SCL
  {
    void
    operator<< (::xercesc::DOMElement& e, const tIED& i)
    {
      e << static_cast< const ::IEC61850::SCL::tNaming& > (i);

      // Services
      //
      if (i.Services ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Services",
            "http://www.iec.ch/61850/2003/SCL",
            e));

        s << *i.Services ();
      }

      // AccessPoint
      //
      for (tIED::AccessPoint_const_iterator
           b (i.AccessPoint ().begin ()), n (i.AccessPoint ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "AccessPoint",
            "http://www.iec.ch/61850/2003/SCL",
            e));

        s << *b;
      }

      // type
      //
      if (i.type ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "type",
            e));

        a << *i.type ();
      }

      // manufacturer
      //
      if (i.manufacturer ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "manufacturer",
            e));

        a << *i.manufacturer ();
      }

      // configVersion
      //
      if (i.configVersion ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "configVersion",
            e));

        a << *i.configVersion ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const tServices& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // DynAssociation
      //
      if (i.DynAssociation ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "DynAssociation",
            "http://www.iec.ch/61850/2003/SCL",
            e));

        s << *i.DynAssociation ();
      }

      // SettingGroups
      //
      if (i.SettingGroups ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "SettingGroups",
            "http://www.iec.ch/61850/2003/SCL",
            e));

        s << *i.SettingGroups ();
      }

      // GetDirectory
      //
      if (i.GetDirectory ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "GetDirectory",
            "http://www.iec.ch/61850/2003/SCL",
            e));

        s << *i.GetDirectory ();
      }

      // GetDataObjectDefinition
      //
      if (i.GetDataObjectDefinition ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "GetDataObjectDefinition",
            "http://www.iec.ch/61850/2003/SCL",
            e));

        s << *i.GetDataObjectDefinition ();
      }

      // DataObjectDirectory
      //
      if (i.DataObjectDirectory ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "DataObjectDirectory",
            "http://www.iec.ch/61850/2003/SCL",
            e));

        s << *i.DataObjectDirectory ();
      }

      // GetDataSetValue
      //
      if (i.GetDataSetValue ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "GetDataSetValue",
            "http://www.iec.ch/61850/2003/SCL",
            e));

        s << *i.GetDataSetValue ();
      }

      // SetDataSetValue
      //
      if (i.SetDataSetValue ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "SetDataSetValue",
            "http://www.iec.ch/61850/2003/SCL",
            e));

        s << *i.SetDataSetValue ();
      }

      // DataSetDirectory
      //
      if (i.DataSetDirectory ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "DataSetDirectory",
            "http://www.iec.ch/61850/2003/SCL",
            e));

        s << *i.DataSetDirectory ();
      }

      // ConfDataSet
      //
      if (i.ConfDataSet ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "ConfDataSet",
            "http://www.iec.ch/61850/2003/SCL",
            e));

        s << *i.ConfDataSet ();
      }

      // DynDataSet
      //
      if (i.DynDataSet ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "DynDataSet",
            "http://www.iec.ch/61850/2003/SCL",
            e));

        s << *i.DynDataSet ();
      }

      // ReadWrite
      //
      if (i.ReadWrite ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "ReadWrite",
            "http://www.iec.ch/61850/2003/SCL",
            e));

        s << *i.ReadWrite ();
      }

      // TimerActivatedControl
      //
      if (i.TimerActivatedControl ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "TimerActivatedControl",
            "http://www.iec.ch/61850/2003/SCL",
            e));

        s << *i.TimerActivatedControl ();
      }

      // ConfReportControl
      //
      if (i.ConfReportControl ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "ConfReportControl",
            "http://www.iec.ch/61850/2003/SCL",
            e));

        s << *i.ConfReportControl ();
      }

      // GetCBValues
      //
      if (i.GetCBValues ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "GetCBValues",
            "http://www.iec.ch/61850/2003/SCL",
            e));

        s << *i.GetCBValues ();
      }

      // ConfLogControl
      //
      if (i.ConfLogControl ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "ConfLogControl",
            "http://www.iec.ch/61850/2003/SCL",
            e));

        s << *i.ConfLogControl ();
      }

      // ReportSettings
      //
      if (i.ReportSettings ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "ReportSettings",
            "http://www.iec.ch/61850/2003/SCL",
            e));

        s << *i.ReportSettings ();
      }

      // LogSettings
      //
      if (i.LogSettings ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "LogSettings",
            "http://www.iec.ch/61850/2003/SCL",
            e));

        s << *i.LogSettings ();
      }

      // GSESettings
      //
      if (i.GSESettings ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "GSESettings",
            "http://www.iec.ch/61850/2003/SCL",
            e));

        s << *i.GSESettings ();
      }

      // SMVSettings
      //
      if (i.SMVSettings ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "SMVSettings",
            "http://www.iec.ch/61850/2003/SCL",
            e));

        s << *i.SMVSettings ();
      }

      // GSEDir
      //
      if (i.GSEDir ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "GSEDir",
            "http://www.iec.ch/61850/2003/SCL",
            e));

        s << *i.GSEDir ();
      }

      // GOOSE
      //
      if (i.GOOSE ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "GOOSE",
            "http://www.iec.ch/61850/2003/SCL",
            e));

        s << *i.GOOSE ();
      }

      // GSSE
      //
      if (i.GSSE ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "GSSE",
            "http://www.iec.ch/61850/2003/SCL",
            e));

        s << *i.GSSE ();
      }

      // FileHandling
      //
      if (i.FileHandling ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "FileHandling",
            "http://www.iec.ch/61850/2003/SCL",
            e));

        s << *i.FileHandling ();
      }

      // ConfLNs
      //
      if (i.ConfLNs ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "ConfLNs",
            "http://www.iec.ch/61850/2003/SCL",
            e));

        s << *i.ConfLNs ();
      }

      // ClientServices
      //
      if (i.ClientServices ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "ClientServices",
            "http://www.iec.ch/61850/2003/SCL",
            e));

        s << *i.ClientServices ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const tAccessPoint& i)
    {
      e << static_cast< const ::IEC61850::SCL::tNaming& > (i);

      // Server
      //
      if (i.Server ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Server",
            "http://www.iec.ch/61850/2003/SCL",
            e));

        s << *i.Server ();
      }

      // LN
      //
      for (tAccessPoint::LN_const_iterator
           b (i.LN ().begin ()), n (i.LN ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "LN",
            "http://www.iec.ch/61850/2003/SCL",
            e));

        s << *b;
      }

      // router
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "router",
            e));

        a << i.router ();
      }

      // clock
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "clock",
            e));

        a << i.clock ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const tServer& i)
    {
      e << static_cast< const ::IEC61850::SCL::tUnNaming& > (i);

      // Authentication
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Authentication",
            "http://www.iec.ch/61850/2003/SCL",
            e));

        s << i.Authentication ();
      }

      // LDevice
      //
      for (tServer::LDevice_const_iterator
           b (i.LDevice ().begin ()), n (i.LDevice ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "LDevice",
            "http://www.iec.ch/61850/2003/SCL",
            e));

        s << *b;
      }

      // Association
      //
      for (tServer::Association_const_iterator
           b (i.Association ().begin ()), n (i.Association ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Association",
            "http://www.iec.ch/61850/2003/SCL",
            e));

        s << *b;
      }

      // timeout
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "timeout",
            e));

        a << i.timeout ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const tLDevice& i)
    {
      e << static_cast< const ::IEC61850::SCL::tUnNaming& > (i);

      // LN0
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "LN0",
            "http://www.iec.ch/61850/2003/SCL",
            e));

        s << i.LN0 ();
      }

      // LN
      //
      for (tLDevice::LN_const_iterator
           b (i.LN ().begin ()), n (i.LN ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "LN",
            "http://www.iec.ch/61850/2003/SCL",
            e));

        s << *b;
      }

      // AccessControl
      //
      if (i.AccessControl ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "AccessControl",
            "http://www.iec.ch/61850/2003/SCL",
            e));

        s << *i.AccessControl ();
      }

      // inst
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "inst",
            e));

        a << i.inst ();
      }

      // ldName
      //
      if (i.ldName ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "ldName",
            e));

        a << *i.ldName ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const tAccessControl& i)
    {
      e << static_cast< const ::IEC61850::SCL::tAnyContentFromOtherNamespace& > (i);
    }

    void
    operator<< (::xercesc::DOMElement& e, const tAssociation& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // kind
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "kind",
            e));

        a << i.kind ();
      }

      // associationID
      //
      if (i.associationID ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "associationID",
            e));

        a << *i.associationID ();
      }

      // iedName
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "iedName",
            e));

        a << i.iedName ();
      }

      // ldInst
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "ldInst",
            e));

        a << i.ldInst ();
      }

      // prefix
      //
      if (i.prefix ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "prefix",
            e));

        a << *i.prefix ();
      }

      // lnClass
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "lnClass",
            e));

        a << i.lnClass ();
      }

      // lnInst
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "lnInst",
            e));

        a << i.lnInst ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const tAnyLN& i)
    {
      e << static_cast< const ::IEC61850::SCL::tUnNaming& > (i);

      // DataSet
      //
      for (tAnyLN::DataSet_const_iterator
           b (i.DataSet ().begin ()), n (i.DataSet ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "DataSet",
            "http://www.iec.ch/61850/2003/SCL",
            e));

        s << *b;
      }

      // ReportControl
      //
      for (tAnyLN::ReportControl_const_iterator
           b (i.ReportControl ().begin ()), n (i.ReportControl ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "ReportControl",
            "http://www.iec.ch/61850/2003/SCL",
            e));

        s << *b;
      }

      // LogControl
      //
      for (tAnyLN::LogControl_const_iterator
           b (i.LogControl ().begin ()), n (i.LogControl ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "LogControl",
            "http://www.iec.ch/61850/2003/SCL",
            e));

        s << *b;
      }

      // DOI
      //
      for (tAnyLN::DOI_const_iterator
           b (i.DOI ().begin ()), n (i.DOI ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "DOI",
            "http://www.iec.ch/61850/2003/SCL",
            e));

        s << *b;
      }

      // Inputs
      //
      if (i.Inputs ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Inputs",
            "http://www.iec.ch/61850/2003/SCL",
            e));

        s << *i.Inputs ();
      }

      // lnType
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "lnType",
            e));

        a << i.lnType ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const tLN& i)
    {
      e << static_cast< const ::IEC61850::SCL::tAnyLN& > (i);

      // lnClass
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "lnClass",
            e));

        a << i.lnClass ();
      }

      // inst
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "inst",
            e));

        a << i.inst ();
      }

      // prefix
      //
      if (i.prefix ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "prefix",
            e));

        a << *i.prefix ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const tLN0& i)
    {
      e << static_cast< const ::IEC61850::SCL::tAnyLN& > (i);

      // GSEControl
      //
      for (tLN0::GSEControl_const_iterator
           b (i.GSEControl ().begin ()), n (i.GSEControl ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "GSEControl",
            "http://www.iec.ch/61850/2003/SCL",
            e));

        s << *b;
      }

      // SampledValueControl
      //
      for (tLN0::SampledValueControl_const_iterator
           b (i.SampledValueControl ().begin ()), n (i.SampledValueControl ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "SampledValueControl",
            "http://www.iec.ch/61850/2003/SCL",
            e));

        s << *b;
      }

      // SettingControl
      //
      if (i.SettingControl ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "SettingControl",
            "http://www.iec.ch/61850/2003/SCL",
            e));

        s << *i.SettingControl ();
      }

      // SCLControl
      //
      if (i.SCLControl ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "SCLControl",
            "http://www.iec.ch/61850/2003/SCL",
            e));

        s << *i.SCLControl ();
      }

      // Log
      //
      if (i.Log ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Log",
            "http://www.iec.ch/61850/2003/SCL",
            e));

        s << *i.Log ();
      }

      // lnClass
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "lnClass",
            e));

        a << i.lnClass ();
      }

      // inst
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "inst",
            e));

        a << i.inst ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const tDataSet& i)
    {
      e << static_cast< const ::IEC61850::SCL::tNaming& > (i);

      // FCDA
      //
      for (tDataSet::FCDA_const_iterator
           b (i.FCDA ().begin ()), n (i.FCDA ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "FCDA",
            "http://www.iec.ch/61850/2003/SCL",
            e));

        s << *b;
      }

      // FCCB
      //
      for (tDataSet::FCCB_const_iterator
           b (i.FCCB ().begin ()), n (i.FCCB ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "FCCB",
            "http://www.iec.ch/61850/2003/SCL",
            e));

        s << *b;
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const tFCDA& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // ldInst
      //
      if (i.ldInst ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "ldInst",
            e));

        a << *i.ldInst ();
      }

      // prefix
      //
      if (i.prefix ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "prefix",
            e));

        a << *i.prefix ();
      }

      // lnClass
      //
      if (i.lnClass ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "lnClass",
            e));

        a << *i.lnClass ();
      }

      // lnInst
      //
      if (i.lnInst ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "lnInst",
            e));

        a << *i.lnInst ();
      }

      // doName
      //
      if (i.doName ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "doName",
            e));

        a << *i.doName ();
      }

      // daName
      //
      if (i.daName ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "daName",
            e));

        a << *i.daName ();
      }

      // fc
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "fc",
            e));

        a << i.fc ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const tFCCB& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // ldInst
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "ldInst",
            e));

        a << i.ldInst ();
      }

      // prefix
      //
      if (i.prefix ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "prefix",
            e));

        a << *i.prefix ();
      }

      // lnClass
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "lnClass",
            e));

        a << i.lnClass ();
      }

      // lnInst
      //
      if (i.lnInst ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "lnInst",
            e));

        a << *i.lnInst ();
      }

      // cbName
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "cbName",
            e));

        a << i.cbName ();
      }

      // daName
      //
      if (i.daName ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "daName",
            e));

        a << *i.daName ();
      }

      // fc
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "fc",
            e));

        a << i.fc ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const tControl& i)
    {
      e << static_cast< const ::IEC61850::SCL::tNaming& > (i);

      // datSet
      //
      if (i.datSet ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "datSet",
            e));

        a << *i.datSet ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const tControlWithTriggerOpt& i)
    {
      e << static_cast< const ::IEC61850::SCL::tControl& > (i);

      // TrgOps
      //
      if (i.TrgOps ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "TrgOps",
            "http://www.iec.ch/61850/2003/SCL",
            e));

        s << *i.TrgOps ();
      }

      // intgPd
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "intgPd",
            e));

        a << i.intgPd ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const tTrgOps& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // dchg
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "dchg",
            e));

        a << i.dchg ();
      }

      // qchg
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "qchg",
            e));

        a << i.qchg ();
      }

      // dupd
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "dupd",
            e));

        a << i.dupd ();
      }

      // period
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "period",
            e));

        a << i.period ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const tReportControl& i)
    {
      e << static_cast< const ::IEC61850::SCL::tControlWithTriggerOpt& > (i);

      // OptFields
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "OptFields",
            "http://www.iec.ch/61850/2003/SCL",
            e));

        s << i.OptFields ();
      }

      // RptEnabled
      //
      if (i.RptEnabled ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "RptEnabled",
            "http://www.iec.ch/61850/2003/SCL",
            e));

        s << *i.RptEnabled ();
      }

      // rptID
      //
      if (i.rptID ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "rptID",
            e));

        a << *i.rptID ();
      }

      // confRev
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "confRev",
            e));

        a << i.confRev ();
      }

      // buffered
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "buffered",
            e));

        a << i.buffered ();
      }

      // bufTime
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "bufTime",
            e));

        a << i.bufTime ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const tRptEnabled& i)
    {
      e << static_cast< const ::IEC61850::SCL::tUnNaming& > (i);

      // ClientLN
      //
      for (tRptEnabled::ClientLN_const_iterator
           b (i.ClientLN ().begin ()), n (i.ClientLN ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "ClientLN",
            "http://www.iec.ch/61850/2003/SCL",
            e));

        s << *b;
      }

      // max
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "max",
            e));

        a << i.max ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const tClientLN& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // iedName
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "iedName",
            e));

        a << i.iedName ();
      }

      // ldInst
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "ldInst",
            e));

        a << i.ldInst ();
      }

      // prefix
      //
      if (i.prefix ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "prefix",
            e));

        a << *i.prefix ();
      }

      // lnClass
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "lnClass",
            e));

        a << i.lnClass ();
      }

      // lnInst
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "lnInst",
            e));

        a << i.lnInst ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const tLogControl& i)
    {
      e << static_cast< const ::IEC61850::SCL::tControlWithTriggerOpt& > (i);

      // logName
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "logName",
            e));

        a << i.logName ();
      }

      // logEna
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "logEna",
            e));

        a << i.logEna ();
      }

      // reasonCode
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "reasonCode",
            e));

        a << i.reasonCode ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const tInputs& i)
    {
      e << static_cast< const ::IEC61850::SCL::tUnNaming& > (i);

      // ExtRef
      //
      for (tInputs::ExtRef_const_iterator
           b (i.ExtRef ().begin ()), n (i.ExtRef ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "ExtRef",
            "http://www.iec.ch/61850/2003/SCL",
            e));

        s << *b;
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const tExtRef& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // iedName
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "iedName",
            e));

        a << i.iedName ();
      }

      // ldInst
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "ldInst",
            e));

        a << i.ldInst ();
      }

      // prefix
      //
      if (i.prefix ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "prefix",
            e));

        a << *i.prefix ();
      }

      // lnClass
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "lnClass",
            e));

        a << i.lnClass ();
      }

      // lnInst
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "lnInst",
            e));

        a << i.lnInst ();
      }

      // doName
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "doName",
            e));

        a << i.doName ();
      }

      // daName
      //
      if (i.daName ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "daName",
            e));

        a << *i.daName ();
      }

      // intAddr
      //
      if (i.intAddr ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "intAddr",
            e));

        a << *i.intAddr ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const tLog& i)
    {
      e << static_cast< const ::IEC61850::SCL::tAnyContentFromOtherNamespace& > (i);
    }

    void
    operator<< (::xercesc::DOMElement& e, const tControlWithIEDName& i)
    {
      e << static_cast< const ::IEC61850::SCL::tControl& > (i);

      // IEDName
      //
      for (tControlWithIEDName::IEDName_const_iterator
           b (i.IEDName ().begin ()), n (i.IEDName ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "IEDName",
            "http://www.iec.ch/61850/2003/SCL",
            e));

        s << *b;
      }

      // confRev
      //
      if (i.confRev ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "confRev",
            e));

        a << *i.confRev ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const tGSEControl& i)
    {
      e << static_cast< const ::IEC61850::SCL::tControlWithIEDName& > (i);

      // type
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "type",
            e));

        a << i.type ();
      }

      // appID
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "appID",
            e));

        a << i.appID ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const tSampledValueControl& i)
    {
      e << static_cast< const ::IEC61850::SCL::tControlWithIEDName& > (i);

      // SmvOpts
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "SmvOpts",
            "http://www.iec.ch/61850/2003/SCL",
            e));

        s << i.SmvOpts ();
      }

      // smvID
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "smvID",
            e));

        a << i.smvID ();
      }

      // multicast
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "multicast",
            e));

        a << i.multicast ();
      }

      // smpRate
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "smpRate",
            e));

        a << i.smpRate ();
      }

      // nofASDU
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "nofASDU",
            e));

        a << i.nofASDU ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const tSettingControl& i)
    {
      e << static_cast< const ::IEC61850::SCL::tUnNaming& > (i);

      // numOfSGs
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "numOfSGs",
            e));

        a << i.numOfSGs ();
      }

      // actSG
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "actSG",
            e));

        a << i.actSG ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const tSCLControl& i)
    {
      e << static_cast< const ::IEC61850::SCL::tUnNaming& > (i);
    }

    void
    operator<< (::xercesc::DOMElement& e, const tDOI& i)
    {
      e << static_cast< const ::IEC61850::SCL::tUnNaming& > (i);

      // SDI
      //
      for (tDOI::SDI_const_iterator
           b (i.SDI ().begin ()), n (i.SDI ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "SDI",
            "http://www.iec.ch/61850/2003/SCL",
            e));

        s << *b;
      }

      // DAI
      //
      for (tDOI::DAI_const_iterator
           b (i.DAI ().begin ()), n (i.DAI ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "DAI",
            "http://www.iec.ch/61850/2003/SCL",
            e));

        s << *b;
      }

      // name
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "name",
            e));

        a << i.name ();
      }

      // ix
      //
      if (i.ix ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "ix",
            e));

        a << *i.ix ();
      }

      // accessControl
      //
      if (i.accessControl ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "accessControl",
            e));

        a << *i.accessControl ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const tSDI& i)
    {
      e << static_cast< const ::IEC61850::SCL::tUnNaming& > (i);

      // SDI
      //
      for (tSDI::SDI_const_iterator
           b (i.SDI ().begin ()), n (i.SDI ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "SDI",
            "http://www.iec.ch/61850/2003/SCL",
            e));

        s << *b;
      }

      // DAI
      //
      for (tSDI::DAI_const_iterator
           b (i.DAI ().begin ()), n (i.DAI ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "DAI",
            "http://www.iec.ch/61850/2003/SCL",
            e));

        s << *b;
      }

      // name
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "name",
            e));

        a << i.name ();
      }

      // ix
      //
      if (i.ix ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "ix",
            e));

        a << *i.ix ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const tDAI& i)
    {
      e << static_cast< const ::IEC61850::SCL::tUnNaming& > (i);

      // Val
      //
      for (tDAI::Val_const_iterator
           b (i.Val ().begin ()), n (i.Val ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Val",
            "http://www.iec.ch/61850/2003/SCL",
            e));

        s << *b;
      }

      // name
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "name",
            e));

        a << i.name ();
      }

      // sAddr
      //
      if (i.sAddr ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "sAddr",
            e));

        a << *i.sAddr ();
      }

      // valKind
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "valKind",
            e));

        a << i.valKind ();
      }

      // ix
      //
      if (i.ix ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "ix",
            e));

        a << *i.ix ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const tServiceYesNo& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);
    }

    void
    operator<< (::xercesc::DOMAttr&,const tServiceYesNo&)
    {
    }

    void
    operator<< (::xml_schema::list_stream&,
                const tServiceYesNo&)
    {
    }

    void
    operator<< (::xercesc::DOMElement& e, const tServiceWithMax& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // max
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "max",
            e));

        a << i.max ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const tServiceWithMaxAndMaxAttributes& i)
    {
      e << static_cast< const ::IEC61850::SCL::tServiceWithMax& > (i);

      // maxAttributes
      //
      if (i.maxAttributes ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "maxAttributes",
            e));

        a << *i.maxAttributes ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const tServiceWithMaxAndModify& i)
    {
      e << static_cast< const ::IEC61850::SCL::tServiceWithMax& > (i);

      // modify
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "modify",
            e));

        a << i.modify ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const tServiceWithMaxAndMaxAttributesAndModify& i)
    {
      e << static_cast< const ::IEC61850::SCL::tServiceWithMaxAndMaxAttributes& > (i);

      // modify
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "modify",
            e));

        a << i.modify ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const tClientServices& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // goose
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "goose",
            e));

        a << i.goose ();
      }

      // gsse
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "gsse",
            e));

        a << i.gsse ();
      }

      // bufReport
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "bufReport",
            e));

        a << i.bufReport ();
      }

      // unbufReport
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "unbufReport",
            e));

        a << i.unbufReport ();
      }

      // readLog
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "readLog",
            e));

        a << i.readLog ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const tServiceSettings& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // cbName
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "cbName",
            e));

        a << i.cbName ();
      }

      // datSet
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "datSet",
            e));

        a << i.datSet ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const tReportSettings& i)
    {
      e << static_cast< const ::IEC61850::SCL::tServiceSettings& > (i);

      // rptID
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "rptID",
            e));

        a << i.rptID ();
      }

      // optFields
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "optFields",
            e));

        a << i.optFields ();
      }

      // bufTime
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "bufTime",
            e));

        a << i.bufTime ();
      }

      // trgOps
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "trgOps",
            e));

        a << i.trgOps ();
      }

      // intgPd
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "intgPd",
            e));

        a << i.intgPd ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const tLogSettings& i)
    {
      e << static_cast< const ::IEC61850::SCL::tServiceSettings& > (i);

      // logEna
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "logEna",
            e));

        a << i.logEna ();
      }

      // trgOps
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "trgOps",
            e));

        a << i.trgOps ();
      }

      // intgPd
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "intgPd",
            e));

        a << i.intgPd ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const tGSESettings& i)
    {
      e << static_cast< const ::IEC61850::SCL::tServiceSettings& > (i);

      // appID
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "appID",
            e));

        a << i.appID ();
      }

      // dataLabel
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "dataLabel",
            e));

        a << i.dataLabel ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const tSMVSettings& i)
    {
      e << static_cast< const ::IEC61850::SCL::tServiceSettings& > (i);

      // SmpRate
      //
      for (tSMVSettings::SmpRate_const_iterator
           b (i.SmpRate ().begin ()), n (i.SmpRate ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "SmpRate",
            "http://www.iec.ch/61850/2003/SCL",
            e));

        s << *b;
      }

      // svID
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "svID",
            e));

        a << i.svID ();
      }

      // optFields
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "optFields",
            e));

        a << i.optFields ();
      }

      // smpRate
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "smpRate",
            e));

        a << i.smpRate ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const tConfLNs& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // fixPrefix
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "fixPrefix",
            e));

        a << i.fixPrefix ();
      }

      // fixLnInst
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "fixLnInst",
            e));

        a << i.fixLnInst ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const SettingGroups& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // SGEdit
      //
      if (i.SGEdit ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "SGEdit",
            "http://www.iec.ch/61850/2003/SCL",
            e));

        s << *i.SGEdit ();
      }

      // ConfSG
      //
      if (i.ConfSG ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "ConfSG",
            "http://www.iec.ch/61850/2003/SCL",
            e));

        s << *i.ConfSG ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const Authentication& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // none
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "none",
            e));

        a << i.none ();
      }

      // password
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "password",
            e));

        a << i.password ();
      }

      // weak
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "weak",
            e));

        a << i.weak ();
      }

      // strong
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "strong",
            e));

        a << i.strong ();
      }

      // certificate
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "certificate",
            e));

        a << i.certificate ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const LN0& i)
    {
      e << static_cast< const ::IEC61850::SCL::tLN0& > (i);
    }

    void
    operator<< (::xercesc::DOMElement& e, const OptFields& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // seqNum
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "seqNum",
            e));

        a << i.seqNum ();
      }

      // timeStamp
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "timeStamp",
            e));

        a << i.timeStamp ();
      }

      // dataSet
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "dataSet",
            e));

        a << i.dataSet ();
      }

      // reasonCode
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "reasonCode",
            e));

        a << i.reasonCode ();
      }

      // dataRef
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "dataRef",
            e));

        a << i.dataRef ();
      }

      // entryID
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "entryID",
            e));

        a << i.entryID ();
      }

      // configRef
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "configRef",
            e));

        a << i.configRef ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const SmvOpts& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // refreshTime
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "refreshTime",
            e));

        a << i.refreshTime ();
      }

      // sampleSynchronized
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "sampleSynchronized",
            e));

        a << i.sampleSynchronized ();
      }

      // sampleRate
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "sampleRate",
            e));

        a << i.sampleRate ();
      }

      // dataSet
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "dataSet",
            e));

        a << i.dataSet ();
      }

      // security
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "security",
            e));

        a << i.security ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const SmpRate& i)
    {
      e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal >& > (i);
    }

    void
    operator<< (::xercesc::DOMAttr& a,const SmpRate& i)
    {
      a << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal >& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const SmpRate& i)
    {
      l << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal >& > (i);
    }
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

