// Copyright (C) 2005-2008 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "SCL_Substation.h"

namespace IEC61850
{
  namespace SCL
  {
    // tLNodeContainer
    // 

    const tLNodeContainer::LNode_sequence& tLNodeContainer::
    LNode () const
    {
      return this->LNode_;
    }

    tLNodeContainer::LNode_sequence& tLNodeContainer::
    LNode ()
    {
      return this->LNode_;
    }

    void tLNodeContainer::
    LNode (const LNode_sequence& s)
    {
      this->LNode_ = s;
    }


    // tPowerSystemResource
    // 


    // tEquipmentContainer
    // 

    const tEquipmentContainer::PowerTransformer_sequence& tEquipmentContainer::
    PowerTransformer () const
    {
      return this->PowerTransformer_;
    }

    tEquipmentContainer::PowerTransformer_sequence& tEquipmentContainer::
    PowerTransformer ()
    {
      return this->PowerTransformer_;
    }

    void tEquipmentContainer::
    PowerTransformer (const PowerTransformer_sequence& s)
    {
      this->PowerTransformer_ = s;
    }

    const tEquipmentContainer::GeneralEquipment_sequence& tEquipmentContainer::
    GeneralEquipment () const
    {
      return this->GeneralEquipment_;
    }

    tEquipmentContainer::GeneralEquipment_sequence& tEquipmentContainer::
    GeneralEquipment ()
    {
      return this->GeneralEquipment_;
    }

    void tEquipmentContainer::
    GeneralEquipment (const GeneralEquipment_sequence& s)
    {
      this->GeneralEquipment_ = s;
    }


    // tEquipment
    // 

    const tEquipment::virtual_type& tEquipment::
    virtual_ () const
    {
      return this->virtual__.get ();
    }

    tEquipment::virtual_type& tEquipment::
    virtual_ ()
    {
      return this->virtual__.get ();
    }

    void tEquipment::
    virtual_ (const virtual_type& x)
    {
      this->virtual__.set (x);
    }

    const tEquipment::virtual_type& tEquipment::
    virtual_default_value ()
    {
      return virtual__default_value_;
    }


    // tAbstractConductingEquipment
    // 

    const tAbstractConductingEquipment::Terminal_sequence& tAbstractConductingEquipment::
    Terminal () const
    {
      return this->Terminal_;
    }

    tAbstractConductingEquipment::Terminal_sequence& tAbstractConductingEquipment::
    Terminal ()
    {
      return this->Terminal_;
    }

    void tAbstractConductingEquipment::
    Terminal (const Terminal_sequence& s)
    {
      this->Terminal_ = s;
    }

    const tAbstractConductingEquipment::SubEquipment_sequence& tAbstractConductingEquipment::
    SubEquipment () const
    {
      return this->SubEquipment_;
    }

    tAbstractConductingEquipment::SubEquipment_sequence& tAbstractConductingEquipment::
    SubEquipment ()
    {
      return this->SubEquipment_;
    }

    void tAbstractConductingEquipment::
    SubEquipment (const SubEquipment_sequence& s)
    {
      this->SubEquipment_ = s;
    }


    // tConductingEquipment
    // 

    const tConductingEquipment::type_type& tConductingEquipment::
    type () const
    {
      return this->type_.get ();
    }

    tConductingEquipment::type_type& tConductingEquipment::
    type ()
    {
      return this->type_.get ();
    }

    void tConductingEquipment::
    type (const type_type& x)
    {
      this->type_.set (x);
    }

    void tConductingEquipment::
    type (::std::auto_ptr< type_type > x)
    {
      this->type_.set (x);
    }


    // tSubEquipment
    // 

    const tSubEquipment::phase_type& tSubEquipment::
    phase () const
    {
      return this->phase_.get ();
    }

    tSubEquipment::phase_type& tSubEquipment::
    phase ()
    {
      return this->phase_.get ();
    }

    void tSubEquipment::
    phase (const phase_type& x)
    {
      this->phase_.set (x);
    }

    void tSubEquipment::
    phase (::std::auto_ptr< phase_type > x)
    {
      this->phase_.set (x);
    }

    const tSubEquipment::phase_type& tSubEquipment::
    phase_default_value ()
    {
      return phase_default_value_;
    }

    const tSubEquipment::virtual_type& tSubEquipment::
    virtual_ () const
    {
      return this->virtual__.get ();
    }

    tSubEquipment::virtual_type& tSubEquipment::
    virtual_ ()
    {
      return this->virtual__.get ();
    }

    void tSubEquipment::
    virtual_ (const virtual_type& x)
    {
      this->virtual__.set (x);
    }

    const tSubEquipment::virtual_type& tSubEquipment::
    virtual_default_value ()
    {
      return virtual__default_value_;
    }


    // tPowerTransformer
    // 

    const tPowerTransformer::TransformerWinding_sequence& tPowerTransformer::
    TransformerWinding () const
    {
      return this->TransformerWinding_;
    }

    tPowerTransformer::TransformerWinding_sequence& tPowerTransformer::
    TransformerWinding ()
    {
      return this->TransformerWinding_;
    }

    void tPowerTransformer::
    TransformerWinding (const TransformerWinding_sequence& s)
    {
      this->TransformerWinding_ = s;
    }

    const tPowerTransformer::type_type& tPowerTransformer::
    type () const
    {
      return this->type_.get ();
    }

    const tPowerTransformer::type_type& tPowerTransformer::
    type_default_value ()
    {
      return type_default_value_;
    }


    // tTransformerWinding
    // 

    const tTransformerWinding::TapChanger_optional& tTransformerWinding::
    TapChanger () const
    {
      return this->TapChanger_;
    }

    tTransformerWinding::TapChanger_optional& tTransformerWinding::
    TapChanger ()
    {
      return this->TapChanger_;
    }

    void tTransformerWinding::
    TapChanger (const TapChanger_type& x)
    {
      this->TapChanger_.set (x);
    }

    void tTransformerWinding::
    TapChanger (const TapChanger_optional& x)
    {
      this->TapChanger_ = x;
    }

    void tTransformerWinding::
    TapChanger (::std::auto_ptr< TapChanger_type > x)
    {
      this->TapChanger_.set (x);
    }

    const tTransformerWinding::type_type& tTransformerWinding::
    type () const
    {
      return this->type_.get ();
    }

    const tTransformerWinding::type_type& tTransformerWinding::
    type_default_value ()
    {
      return type_default_value_;
    }


    // tTapChanger
    // 

    const tTapChanger::type_type& tTapChanger::
    type () const
    {
      return this->type_.get ();
    }

    const tTapChanger::type_type& tTapChanger::
    type_default_value ()
    {
      return type_default_value_;
    }

    const tTapChanger::virtual_type& tTapChanger::
    virtual_ () const
    {
      return this->virtual__.get ();
    }

    tTapChanger::virtual_type& tTapChanger::
    virtual_ ()
    {
      return this->virtual__.get ();
    }

    void tTapChanger::
    virtual_ (const virtual_type& x)
    {
      this->virtual__.set (x);
    }

    const tTapChanger::virtual_type& tTapChanger::
    virtual_default_value ()
    {
      return virtual__default_value_;
    }


    // tGeneralEquipment
    // 

    const tGeneralEquipment::type_type& tGeneralEquipment::
    type () const
    {
      return this->type_.get ();
    }

    tGeneralEquipment::type_type& tGeneralEquipment::
    type ()
    {
      return this->type_.get ();
    }

    void tGeneralEquipment::
    type (const type_type& x)
    {
      this->type_.set (x);
    }

    void tGeneralEquipment::
    type (::std::auto_ptr< type_type > x)
    {
      this->type_.set (x);
    }


    // tSubstation
    // 

    const tSubstation::VoltageLevel_sequence& tSubstation::
    VoltageLevel () const
    {
      return this->VoltageLevel_;
    }

    tSubstation::VoltageLevel_sequence& tSubstation::
    VoltageLevel ()
    {
      return this->VoltageLevel_;
    }

    void tSubstation::
    VoltageLevel (const VoltageLevel_sequence& s)
    {
      this->VoltageLevel_ = s;
    }

    const tSubstation::Function_sequence& tSubstation::
    Function () const
    {
      return this->Function_;
    }

    tSubstation::Function_sequence& tSubstation::
    Function ()
    {
      return this->Function_;
    }

    void tSubstation::
    Function (const Function_sequence& s)
    {
      this->Function_ = s;
    }


    // tVoltageLevel
    // 

    const tVoltageLevel::Voltage_optional& tVoltageLevel::
    Voltage () const
    {
      return this->Voltage_;
    }

    tVoltageLevel::Voltage_optional& tVoltageLevel::
    Voltage ()
    {
      return this->Voltage_;
    }

    void tVoltageLevel::
    Voltage (const Voltage_type& x)
    {
      this->Voltage_.set (x);
    }

    void tVoltageLevel::
    Voltage (const Voltage_optional& x)
    {
      this->Voltage_ = x;
    }

    void tVoltageLevel::
    Voltage (::std::auto_ptr< Voltage_type > x)
    {
      this->Voltage_.set (x);
    }

    const tVoltageLevel::Bay_sequence& tVoltageLevel::
    Bay () const
    {
      return this->Bay_;
    }

    tVoltageLevel::Bay_sequence& tVoltageLevel::
    Bay ()
    {
      return this->Bay_;
    }

    void tVoltageLevel::
    Bay (const Bay_sequence& s)
    {
      this->Bay_ = s;
    }

    const tVoltageLevel::Function_sequence& tVoltageLevel::
    Function () const
    {
      return this->Function_;
    }

    tVoltageLevel::Function_sequence& tVoltageLevel::
    Function ()
    {
      return this->Function_;
    }

    void tVoltageLevel::
    Function (const Function_sequence& s)
    {
      this->Function_ = s;
    }


    // tBay
    // 

    const tBay::ConductingEquipment_sequence& tBay::
    ConductingEquipment () const
    {
      return this->ConductingEquipment_;
    }

    tBay::ConductingEquipment_sequence& tBay::
    ConductingEquipment ()
    {
      return this->ConductingEquipment_;
    }

    void tBay::
    ConductingEquipment (const ConductingEquipment_sequence& s)
    {
      this->ConductingEquipment_ = s;
    }

    const tBay::ConnectivityNode_sequence& tBay::
    ConnectivityNode () const
    {
      return this->ConnectivityNode_;
    }

    tBay::ConnectivityNode_sequence& tBay::
    ConnectivityNode ()
    {
      return this->ConnectivityNode_;
    }

    void tBay::
    ConnectivityNode (const ConnectivityNode_sequence& s)
    {
      this->ConnectivityNode_ = s;
    }

    const tBay::Function_sequence& tBay::
    Function () const
    {
      return this->Function_;
    }

    tBay::Function_sequence& tBay::
    Function ()
    {
      return this->Function_;
    }

    void tBay::
    Function (const Function_sequence& s)
    {
      this->Function_ = s;
    }


    // tLNode
    // 

    const tLNode::lnInst_optional& tLNode::
    lnInst () const
    {
      return this->lnInst_;
    }

    tLNode::lnInst_optional& tLNode::
    lnInst ()
    {
      return this->lnInst_;
    }

    void tLNode::
    lnInst (const lnInst_type& x)
    {
      this->lnInst_.set (x);
    }

    void tLNode::
    lnInst (const lnInst_optional& x)
    {
      this->lnInst_ = x;
    }

    void tLNode::
    lnInst (::std::auto_ptr< lnInst_type > x)
    {
      this->lnInst_.set (x);
    }

    const tLNode::lnClass_type& tLNode::
    lnClass () const
    {
      return this->lnClass_.get ();
    }

    tLNode::lnClass_type& tLNode::
    lnClass ()
    {
      return this->lnClass_.get ();
    }

    void tLNode::
    lnClass (const lnClass_type& x)
    {
      this->lnClass_.set (x);
    }

    void tLNode::
    lnClass (::std::auto_ptr< lnClass_type > x)
    {
      this->lnClass_.set (x);
    }

    const tLNode::iedName_type& tLNode::
    iedName () const
    {
      return this->iedName_.get ();
    }

    tLNode::iedName_type& tLNode::
    iedName ()
    {
      return this->iedName_.get ();
    }

    void tLNode::
    iedName (const iedName_type& x)
    {
      this->iedName_.set (x);
    }

    void tLNode::
    iedName (::std::auto_ptr< iedName_type > x)
    {
      this->iedName_.set (x);
    }

    const tLNode::iedName_type& tLNode::
    iedName_default_value ()
    {
      return iedName_default_value_;
    }

    const tLNode::ldInst_optional& tLNode::
    ldInst () const
    {
      return this->ldInst_;
    }

    tLNode::ldInst_optional& tLNode::
    ldInst ()
    {
      return this->ldInst_;
    }

    void tLNode::
    ldInst (const ldInst_type& x)
    {
      this->ldInst_.set (x);
    }

    void tLNode::
    ldInst (const ldInst_optional& x)
    {
      this->ldInst_ = x;
    }

    void tLNode::
    ldInst (::std::auto_ptr< ldInst_type > x)
    {
      this->ldInst_.set (x);
    }

    const tLNode::prefix_optional& tLNode::
    prefix () const
    {
      return this->prefix_;
    }

    tLNode::prefix_optional& tLNode::
    prefix ()
    {
      return this->prefix_;
    }

    void tLNode::
    prefix (const prefix_type& x)
    {
      this->prefix_.set (x);
    }

    void tLNode::
    prefix (const prefix_optional& x)
    {
      this->prefix_ = x;
    }

    void tLNode::
    prefix (::std::auto_ptr< prefix_type > x)
    {
      this->prefix_.set (x);
    }

    const tLNode::lnType_optional& tLNode::
    lnType () const
    {
      return this->lnType_;
    }

    tLNode::lnType_optional& tLNode::
    lnType ()
    {
      return this->lnType_;
    }

    void tLNode::
    lnType (const lnType_type& x)
    {
      this->lnType_.set (x);
    }

    void tLNode::
    lnType (const lnType_optional& x)
    {
      this->lnType_ = x;
    }

    void tLNode::
    lnType (::std::auto_ptr< lnType_type > x)
    {
      this->lnType_.set (x);
    }


    // tFunction
    // 

    const tFunction::SubFunction_sequence& tFunction::
    SubFunction () const
    {
      return this->SubFunction_;
    }

    tFunction::SubFunction_sequence& tFunction::
    SubFunction ()
    {
      return this->SubFunction_;
    }

    void tFunction::
    SubFunction (const SubFunction_sequence& s)
    {
      this->SubFunction_ = s;
    }

    const tFunction::GeneralEquipment_sequence& tFunction::
    GeneralEquipment () const
    {
      return this->GeneralEquipment_;
    }

    tFunction::GeneralEquipment_sequence& tFunction::
    GeneralEquipment ()
    {
      return this->GeneralEquipment_;
    }

    void tFunction::
    GeneralEquipment (const GeneralEquipment_sequence& s)
    {
      this->GeneralEquipment_ = s;
    }


    // tSubFunction
    // 

    const tSubFunction::GeneralEquipment_sequence& tSubFunction::
    GeneralEquipment () const
    {
      return this->GeneralEquipment_;
    }

    tSubFunction::GeneralEquipment_sequence& tSubFunction::
    GeneralEquipment ()
    {
      return this->GeneralEquipment_;
    }

    void tSubFunction::
    GeneralEquipment (const GeneralEquipment_sequence& s)
    {
      this->GeneralEquipment_ = s;
    }


    // tConnectivityNode
    // 

    const tConnectivityNode::pathName_type& tConnectivityNode::
    pathName () const
    {
      return this->pathName_.get ();
    }

    tConnectivityNode::pathName_type& tConnectivityNode::
    pathName ()
    {
      return this->pathName_.get ();
    }

    void tConnectivityNode::
    pathName (const pathName_type& x)
    {
      this->pathName_.set (x);
    }

    void tConnectivityNode::
    pathName (::std::auto_ptr< pathName_type > x)
    {
      this->pathName_.set (x);
    }


    // tTerminal
    // 

    const tTerminal::name_optional& tTerminal::
    name () const
    {
      return this->name_;
    }

    tTerminal::name_optional& tTerminal::
    name ()
    {
      return this->name_;
    }

    void tTerminal::
    name (const name_type& x)
    {
      this->name_.set (x);
    }

    void tTerminal::
    name (const name_optional& x)
    {
      this->name_ = x;
    }

    void tTerminal::
    name (::std::auto_ptr< name_type > x)
    {
      this->name_.set (x);
    }

    const tTerminal::connectivityNode_type& tTerminal::
    connectivityNode () const
    {
      return this->connectivityNode_.get ();
    }

    tTerminal::connectivityNode_type& tTerminal::
    connectivityNode ()
    {
      return this->connectivityNode_.get ();
    }

    void tTerminal::
    connectivityNode (const connectivityNode_type& x)
    {
      this->connectivityNode_.set (x);
    }

    void tTerminal::
    connectivityNode (::std::auto_ptr< connectivityNode_type > x)
    {
      this->connectivityNode_.set (x);
    }

    const tTerminal::substationName_type& tTerminal::
    substationName () const
    {
      return this->substationName_.get ();
    }

    tTerminal::substationName_type& tTerminal::
    substationName ()
    {
      return this->substationName_.get ();
    }

    void tTerminal::
    substationName (const substationName_type& x)
    {
      this->substationName_.set (x);
    }

    void tTerminal::
    substationName (::std::auto_ptr< substationName_type > x)
    {
      this->substationName_.set (x);
    }

    const tTerminal::voltageLevelName_type& tTerminal::
    voltageLevelName () const
    {
      return this->voltageLevelName_.get ();
    }

    tTerminal::voltageLevelName_type& tTerminal::
    voltageLevelName ()
    {
      return this->voltageLevelName_.get ();
    }

    void tTerminal::
    voltageLevelName (const voltageLevelName_type& x)
    {
      this->voltageLevelName_.set (x);
    }

    void tTerminal::
    voltageLevelName (::std::auto_ptr< voltageLevelName_type > x)
    {
      this->voltageLevelName_.set (x);
    }

    const tTerminal::bayName_type& tTerminal::
    bayName () const
    {
      return this->bayName_.get ();
    }

    tTerminal::bayName_type& tTerminal::
    bayName ()
    {
      return this->bayName_.get ();
    }

    void tTerminal::
    bayName (const bayName_type& x)
    {
      this->bayName_.set (x);
    }

    void tTerminal::
    bayName (::std::auto_ptr< bayName_type > x)
    {
      this->bayName_.set (x);
    }

    const tTerminal::cNodeName_type& tTerminal::
    cNodeName () const
    {
      return this->cNodeName_.get ();
    }

    tTerminal::cNodeName_type& tTerminal::
    cNodeName ()
    {
      return this->cNodeName_.get ();
    }

    void tTerminal::
    cNodeName (const cNodeName_type& x)
    {
      this->cNodeName_.set (x);
    }

    void tTerminal::
    cNodeName (::std::auto_ptr< cNodeName_type > x)
    {
      this->cNodeName_.set (x);
    }
  }
}

#include <xsd/cxx/xml/dom/parsing-source.hxx>

namespace IEC61850
{
  namespace SCL
  {
    // tLNodeContainer
    //

    tLNodeContainer::
    tLNodeContainer (const name_type& name)
    : ::IEC61850::SCL::tNaming (name),
      LNode_ (::xml_schema::flags (), this)
    {
    }

    tLNodeContainer::
    tLNodeContainer (const tLNodeContainer& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::IEC61850::SCL::tNaming (x, f, c),
      LNode_ (x.LNode_, f, this)
    {
    }

    tLNodeContainer::
    tLNodeContainer (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::IEC61850::SCL::tNaming (e, f | ::xml_schema::flags::base, c),
      LNode_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void tLNodeContainer::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::IEC61850::SCL::tNaming::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // LNode
        //
        if (n.name () == "LNode" && n.namespace_ () == "http://www.iec.ch/61850/2003/SCL")
        {
          ::std::auto_ptr< LNode_type > r (
            LNode_traits::create (i, f, this));

          this->LNode_.push_back (r);
          continue;
        }

        break;
      }
    }

    tLNodeContainer* tLNodeContainer::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class tLNodeContainer (*this, f, c);
    }

    tLNodeContainer::
    ~tLNodeContainer ()
    {
    }

    // tPowerSystemResource
    //

    tPowerSystemResource::
    tPowerSystemResource (const name_type& name)
    : ::IEC61850::SCL::tLNodeContainer (name)
    {
    }

    tPowerSystemResource::
    tPowerSystemResource (const tPowerSystemResource& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::IEC61850::SCL::tLNodeContainer (x, f, c)
    {
    }

    tPowerSystemResource::
    tPowerSystemResource (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::IEC61850::SCL::tLNodeContainer (e, f, c)
    {
    }

    tPowerSystemResource* tPowerSystemResource::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class tPowerSystemResource (*this, f, c);
    }

    tPowerSystemResource::
    ~tPowerSystemResource ()
    {
    }

    // tEquipmentContainer
    //

    tEquipmentContainer::
    tEquipmentContainer (const name_type& name)
    : ::IEC61850::SCL::tPowerSystemResource (name),
      PowerTransformer_ (::xml_schema::flags (), this),
      GeneralEquipment_ (::xml_schema::flags (), this)
    {
    }

    tEquipmentContainer::
    tEquipmentContainer (const tEquipmentContainer& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::IEC61850::SCL::tPowerSystemResource (x, f, c),
      PowerTransformer_ (x.PowerTransformer_, f, this),
      GeneralEquipment_ (x.GeneralEquipment_, f, this)
    {
    }

    tEquipmentContainer::
    tEquipmentContainer (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::IEC61850::SCL::tPowerSystemResource (e, f | ::xml_schema::flags::base, c),
      PowerTransformer_ (f, this),
      GeneralEquipment_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void tEquipmentContainer::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::IEC61850::SCL::tPowerSystemResource::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // PowerTransformer
        //
        if (n.name () == "PowerTransformer" && n.namespace_ () == "http://www.iec.ch/61850/2003/SCL")
        {
          ::std::auto_ptr< PowerTransformer_type > r (
            PowerTransformer_traits::create (i, f, this));

          this->PowerTransformer_.push_back (r);
          continue;
        }

        // GeneralEquipment
        //
        if (n.name () == "GeneralEquipment" && n.namespace_ () == "http://www.iec.ch/61850/2003/SCL")
        {
          ::std::auto_ptr< GeneralEquipment_type > r (
            GeneralEquipment_traits::create (i, f, this));

          this->GeneralEquipment_.push_back (r);
          continue;
        }

        break;
      }
    }

    tEquipmentContainer* tEquipmentContainer::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class tEquipmentContainer (*this, f, c);
    }

    tEquipmentContainer::
    ~tEquipmentContainer ()
    {
    }

    // tEquipment
    //

    const tEquipment::virtual_type tEquipment::virtual__default_value_ (
      ::xsd::cxx::tree::traits< ::xml_schema::boolean, char >::create (
        ::std::string ("false"), 0, 0, 0));

    tEquipment::
    tEquipment (const name_type& name)
    : ::IEC61850::SCL::tPowerSystemResource (name),
      virtual__ (virtual_default_value (), ::xml_schema::flags (), this)
    {
    }

    tEquipment::
    tEquipment (const tEquipment& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
    : ::IEC61850::SCL::tPowerSystemResource (x, f, c),
      virtual__ (x.virtual__, f, this)
    {
    }

    tEquipment::
    tEquipment (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
    : ::IEC61850::SCL::tPowerSystemResource (e, f | ::xml_schema::flags::base, c),
      virtual__ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void tEquipment::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::IEC61850::SCL::tPowerSystemResource::parse (p, f);

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "virtual" && n.namespace_ ().empty ())
        {
          this->virtual__.set (virtual_traits::create (i, f, this));
          continue;
        }
      }

      if (!virtual__.present ())
      {
        this->virtual__.set (virtual_default_value ());
      }
    }

    tEquipment* tEquipment::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class tEquipment (*this, f, c);
    }

    tEquipment::
    ~tEquipment ()
    {
    }

    // tAbstractConductingEquipment
    //

    tAbstractConductingEquipment::
    tAbstractConductingEquipment (const name_type& name)
    : ::IEC61850::SCL::tEquipment (name),
      Terminal_ (::xml_schema::flags (), this),
      SubEquipment_ (::xml_schema::flags (), this)
    {
    }

    tAbstractConductingEquipment::
    tAbstractConductingEquipment (const tAbstractConductingEquipment& x,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::IEC61850::SCL::tEquipment (x, f, c),
      Terminal_ (x.Terminal_, f, this),
      SubEquipment_ (x.SubEquipment_, f, this)
    {
    }

    tAbstractConductingEquipment::
    tAbstractConductingEquipment (const ::xercesc::DOMElement& e,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::IEC61850::SCL::tEquipment (e, f | ::xml_schema::flags::base, c),
      Terminal_ (f, this),
      SubEquipment_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void tAbstractConductingEquipment::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::IEC61850::SCL::tEquipment::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Terminal
        //
        if (n.name () == "Terminal" && n.namespace_ () == "http://www.iec.ch/61850/2003/SCL")
        {
          ::std::auto_ptr< Terminal_type > r (
            Terminal_traits::create (i, f, this));

          this->Terminal_.push_back (r);
          continue;
        }

        // SubEquipment
        //
        if (n.name () == "SubEquipment" && n.namespace_ () == "http://www.iec.ch/61850/2003/SCL")
        {
          ::std::auto_ptr< SubEquipment_type > r (
            SubEquipment_traits::create (i, f, this));

          this->SubEquipment_.push_back (r);
          continue;
        }

        break;
      }
    }

    tAbstractConductingEquipment* tAbstractConductingEquipment::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class tAbstractConductingEquipment (*this, f, c);
    }

    tAbstractConductingEquipment::
    ~tAbstractConductingEquipment ()
    {
    }

    // tConductingEquipment
    //

    tConductingEquipment::
    tConductingEquipment (const name_type& name,
                          const type_type& type)
    : ::IEC61850::SCL::tAbstractConductingEquipment (name),
      type_ (type, ::xml_schema::flags (), this)
    {
    }

    tConductingEquipment::
    tConductingEquipment (const tConductingEquipment& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::IEC61850::SCL::tAbstractConductingEquipment (x, f, c),
      type_ (x.type_, f, this)
    {
    }

    tConductingEquipment::
    tConductingEquipment (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::IEC61850::SCL::tAbstractConductingEquipment (e, f | ::xml_schema::flags::base, c),
      type_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void tConductingEquipment::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::IEC61850::SCL::tAbstractConductingEquipment::parse (p, f);

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "type" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< type_type > r (
            type_traits::create (i, f, this));

          this->type_.set (r);
          continue;
        }
      }

      if (!type_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "type",
          "");
      }
    }

    tConductingEquipment* tConductingEquipment::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class tConductingEquipment (*this, f, c);
    }

    tConductingEquipment::
    ~tConductingEquipment ()
    {
    }

    // tSubEquipment
    //

    const tSubEquipment::phase_type tSubEquipment::phase_default_value_ (
      ::std::string ("none"), 0, 0, 0);

    const tSubEquipment::virtual_type tSubEquipment::virtual__default_value_ (
      ::xsd::cxx::tree::traits< ::xml_schema::boolean, char >::create (
        ::std::string ("false"), 0, 0, 0));

    tSubEquipment::
    tSubEquipment (const name_type& name)
    : ::IEC61850::SCL::tPowerSystemResource (name),
      phase_ (phase_default_value (), ::xml_schema::flags (), this),
      virtual__ (virtual_default_value (), ::xml_schema::flags (), this)
    {
    }

    tSubEquipment::
    tSubEquipment (const tSubEquipment& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::IEC61850::SCL::tPowerSystemResource (x, f, c),
      phase_ (x.phase_, f, this),
      virtual__ (x.virtual__, f, this)
    {
    }

    tSubEquipment::
    tSubEquipment (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::IEC61850::SCL::tPowerSystemResource (e, f | ::xml_schema::flags::base, c),
      phase_ (f, this),
      virtual__ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void tSubEquipment::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::IEC61850::SCL::tPowerSystemResource::parse (p, f);

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "phase" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< phase_type > r (
            phase_traits::create (i, f, this));

          this->phase_.set (r);
          continue;
        }

        if (n.name () == "virtual" && n.namespace_ ().empty ())
        {
          this->virtual__.set (virtual_traits::create (i, f, this));
          continue;
        }
      }

      if (!phase_.present ())
      {
        this->phase_.set (phase_default_value ());
      }

      if (!virtual__.present ())
      {
        this->virtual__.set (virtual_default_value ());
      }
    }

    tSubEquipment* tSubEquipment::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class tSubEquipment (*this, f, c);
    }

    tSubEquipment::
    ~tSubEquipment ()
    {
    }

    // tPowerTransformer
    //

    const tPowerTransformer::type_type tPowerTransformer::type_default_value_ (
      ::std::string ("PTR"), 0, 0, 0);

    tPowerTransformer::
    tPowerTransformer (const name_type& name)
    : ::IEC61850::SCL::tEquipment (name),
      TransformerWinding_ (::xml_schema::flags (), this),
      type_ (type_default_value (), ::xml_schema::flags (), this)
    {
    }

    tPowerTransformer::
    tPowerTransformer (const tPowerTransformer& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::IEC61850::SCL::tEquipment (x, f, c),
      TransformerWinding_ (x.TransformerWinding_, f, this),
      type_ (x.type_, f, this)
    {
    }

    tPowerTransformer::
    tPowerTransformer (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::IEC61850::SCL::tEquipment (e, f | ::xml_schema::flags::base, c),
      TransformerWinding_ (f, this),
      type_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void tPowerTransformer::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::IEC61850::SCL::tEquipment::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // TransformerWinding
        //
        if (n.name () == "TransformerWinding" && n.namespace_ () == "http://www.iec.ch/61850/2003/SCL")
        {
          ::std::auto_ptr< TransformerWinding_type > r (
            TransformerWinding_traits::create (i, f, this));

          this->TransformerWinding_.push_back (r);
          continue;
        }

        break;
      }

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "type" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< type_type > r (
            type_traits::create (i, f, this));

          this->type_.set (r);
          continue;
        }
      }

      if (!type_.present ())
      {
        this->type_.set (type_default_value ());
      }
    }

    tPowerTransformer* tPowerTransformer::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class tPowerTransformer (*this, f, c);
    }

    tPowerTransformer::
    ~tPowerTransformer ()
    {
    }

    // tTransformerWinding
    //

    const tTransformerWinding::type_type tTransformerWinding::type_default_value_ (
      ::std::string ("PTW"), 0, 0, 0);

    tTransformerWinding::
    tTransformerWinding (const name_type& name)
    : ::IEC61850::SCL::tAbstractConductingEquipment (name),
      TapChanger_ (::xml_schema::flags (), this),
      type_ (type_default_value (), ::xml_schema::flags (), this)
    {
    }

    tTransformerWinding::
    tTransformerWinding (const tTransformerWinding& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::IEC61850::SCL::tAbstractConductingEquipment (x, f, c),
      TapChanger_ (x.TapChanger_, f, this),
      type_ (x.type_, f, this)
    {
    }

    tTransformerWinding::
    tTransformerWinding (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::IEC61850::SCL::tAbstractConductingEquipment (e, f | ::xml_schema::flags::base, c),
      TapChanger_ (f, this),
      type_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void tTransformerWinding::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::IEC61850::SCL::tAbstractConductingEquipment::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // TapChanger
        //
        if (n.name () == "TapChanger" && n.namespace_ () == "http://www.iec.ch/61850/2003/SCL")
        {
          ::std::auto_ptr< TapChanger_type > r (
            TapChanger_traits::create (i, f, this));

          if (!this->TapChanger_)
          {
            this->TapChanger_.set (r);
            continue;
          }
        }

        break;
      }

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "type" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< type_type > r (
            type_traits::create (i, f, this));

          this->type_.set (r);
          continue;
        }
      }

      if (!type_.present ())
      {
        this->type_.set (type_default_value ());
      }
    }

    tTransformerWinding* tTransformerWinding::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class tTransformerWinding (*this, f, c);
    }

    tTransformerWinding::
    ~tTransformerWinding ()
    {
    }

    // tTapChanger
    //

    const tTapChanger::type_type tTapChanger::type_default_value_ (
      ::std::string ("LTC"), 0, 0, 0);

    const tTapChanger::virtual_type tTapChanger::virtual__default_value_ (
      ::xsd::cxx::tree::traits< ::xml_schema::boolean, char >::create (
        ::std::string ("false"), 0, 0, 0));

    tTapChanger::
    tTapChanger (const name_type& name)
    : ::IEC61850::SCL::tPowerSystemResource (name),
      type_ (type_default_value (), ::xml_schema::flags (), this),
      virtual__ (virtual_default_value (), ::xml_schema::flags (), this)
    {
    }

    tTapChanger::
    tTapChanger (const tTapChanger& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::IEC61850::SCL::tPowerSystemResource (x, f, c),
      type_ (x.type_, f, this),
      virtual__ (x.virtual__, f, this)
    {
    }

    tTapChanger::
    tTapChanger (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::IEC61850::SCL::tPowerSystemResource (e, f | ::xml_schema::flags::base, c),
      type_ (f, this),
      virtual__ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void tTapChanger::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::IEC61850::SCL::tPowerSystemResource::parse (p, f);

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "type" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< type_type > r (
            type_traits::create (i, f, this));

          this->type_.set (r);
          continue;
        }

        if (n.name () == "virtual" && n.namespace_ ().empty ())
        {
          this->virtual__.set (virtual_traits::create (i, f, this));
          continue;
        }
      }

      if (!type_.present ())
      {
        this->type_.set (type_default_value ());
      }

      if (!virtual__.present ())
      {
        this->virtual__.set (virtual_default_value ());
      }
    }

    tTapChanger* tTapChanger::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class tTapChanger (*this, f, c);
    }

    tTapChanger::
    ~tTapChanger ()
    {
    }

    // tGeneralEquipment
    //

    tGeneralEquipment::
    tGeneralEquipment (const name_type& name,
                       const type_type& type)
    : ::IEC61850::SCL::tEquipment (name),
      type_ (type, ::xml_schema::flags (), this)
    {
    }

    tGeneralEquipment::
    tGeneralEquipment (const tGeneralEquipment& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::IEC61850::SCL::tEquipment (x, f, c),
      type_ (x.type_, f, this)
    {
    }

    tGeneralEquipment::
    tGeneralEquipment (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::IEC61850::SCL::tEquipment (e, f | ::xml_schema::flags::base, c),
      type_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void tGeneralEquipment::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::IEC61850::SCL::tEquipment::parse (p, f);

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "type" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< type_type > r (
            type_traits::create (i, f, this));

          this->type_.set (r);
          continue;
        }
      }

      if (!type_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "type",
          "");
      }
    }

    tGeneralEquipment* tGeneralEquipment::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class tGeneralEquipment (*this, f, c);
    }

    tGeneralEquipment::
    ~tGeneralEquipment ()
    {
    }

    // tSubstation
    //

    tSubstation::
    tSubstation (const name_type& name)
    : ::IEC61850::SCL::tEquipmentContainer (name),
      VoltageLevel_ (::xml_schema::flags (), this),
      Function_ (::xml_schema::flags (), this)
    {
    }

    tSubstation::
    tSubstation (const tSubstation& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::IEC61850::SCL::tEquipmentContainer (x, f, c),
      VoltageLevel_ (x.VoltageLevel_, f, this),
      Function_ (x.Function_, f, this)
    {
    }

    tSubstation::
    tSubstation (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::IEC61850::SCL::tEquipmentContainer (e, f | ::xml_schema::flags::base, c),
      VoltageLevel_ (f, this),
      Function_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void tSubstation::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::IEC61850::SCL::tEquipmentContainer::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // VoltageLevel
        //
        if (n.name () == "VoltageLevel" && n.namespace_ () == "http://www.iec.ch/61850/2003/SCL")
        {
          ::std::auto_ptr< VoltageLevel_type > r (
            VoltageLevel_traits::create (i, f, this));

          this->VoltageLevel_.push_back (r);
          continue;
        }

        // Function
        //
        if (n.name () == "Function" && n.namespace_ () == "http://www.iec.ch/61850/2003/SCL")
        {
          ::std::auto_ptr< Function_type > r (
            Function_traits::create (i, f, this));

          this->Function_.push_back (r);
          continue;
        }

        break;
      }
    }

    tSubstation* tSubstation::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class tSubstation (*this, f, c);
    }

    tSubstation::
    ~tSubstation ()
    {
    }

    // tVoltageLevel
    //

    tVoltageLevel::
    tVoltageLevel (const name_type& name)
    : ::IEC61850::SCL::tEquipmentContainer (name),
      Voltage_ (::xml_schema::flags (), this),
      Bay_ (::xml_schema::flags (), this),
      Function_ (::xml_schema::flags (), this)
    {
    }

    tVoltageLevel::
    tVoltageLevel (const tVoltageLevel& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::IEC61850::SCL::tEquipmentContainer (x, f, c),
      Voltage_ (x.Voltage_, f, this),
      Bay_ (x.Bay_, f, this),
      Function_ (x.Function_, f, this)
    {
    }

    tVoltageLevel::
    tVoltageLevel (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::IEC61850::SCL::tEquipmentContainer (e, f | ::xml_schema::flags::base, c),
      Voltage_ (f, this),
      Bay_ (f, this),
      Function_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void tVoltageLevel::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::IEC61850::SCL::tEquipmentContainer::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Voltage
        //
        if (n.name () == "Voltage" && n.namespace_ () == "http://www.iec.ch/61850/2003/SCL")
        {
          ::std::auto_ptr< Voltage_type > r (
            Voltage_traits::create (i, f, this));

          if (!this->Voltage_)
          {
            this->Voltage_.set (r);
            continue;
          }
        }

        // Bay
        //
        if (n.name () == "Bay" && n.namespace_ () == "http://www.iec.ch/61850/2003/SCL")
        {
          ::std::auto_ptr< Bay_type > r (
            Bay_traits::create (i, f, this));

          this->Bay_.push_back (r);
          continue;
        }

        // Function
        //
        if (n.name () == "Function" && n.namespace_ () == "http://www.iec.ch/61850/2003/SCL")
        {
          ::std::auto_ptr< Function_type > r (
            Function_traits::create (i, f, this));

          this->Function_.push_back (r);
          continue;
        }

        break;
      }
    }

    tVoltageLevel* tVoltageLevel::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class tVoltageLevel (*this, f, c);
    }

    tVoltageLevel::
    ~tVoltageLevel ()
    {
    }

    // tBay
    //

    tBay::
    tBay (const name_type& name)
    : ::IEC61850::SCL::tEquipmentContainer (name),
      ConductingEquipment_ (::xml_schema::flags (), this),
      ConnectivityNode_ (::xml_schema::flags (), this),
      Function_ (::xml_schema::flags (), this)
    {
    }

    tBay::
    tBay (const tBay& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
    : ::IEC61850::SCL::tEquipmentContainer (x, f, c),
      ConductingEquipment_ (x.ConductingEquipment_, f, this),
      ConnectivityNode_ (x.ConnectivityNode_, f, this),
      Function_ (x.Function_, f, this)
    {
    }

    tBay::
    tBay (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
    : ::IEC61850::SCL::tEquipmentContainer (e, f | ::xml_schema::flags::base, c),
      ConductingEquipment_ (f, this),
      ConnectivityNode_ (f, this),
      Function_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void tBay::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::IEC61850::SCL::tEquipmentContainer::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // ConductingEquipment
        //
        if (n.name () == "ConductingEquipment" && n.namespace_ () == "http://www.iec.ch/61850/2003/SCL")
        {
          ::std::auto_ptr< ConductingEquipment_type > r (
            ConductingEquipment_traits::create (i, f, this));

          this->ConductingEquipment_.push_back (r);
          continue;
        }

        // ConnectivityNode
        //
        if (n.name () == "ConnectivityNode" && n.namespace_ () == "http://www.iec.ch/61850/2003/SCL")
        {
          ::std::auto_ptr< ConnectivityNode_type > r (
            ConnectivityNode_traits::create (i, f, this));

          this->ConnectivityNode_.push_back (r);
          continue;
        }

        // Function
        //
        if (n.name () == "Function" && n.namespace_ () == "http://www.iec.ch/61850/2003/SCL")
        {
          ::std::auto_ptr< Function_type > r (
            Function_traits::create (i, f, this));

          this->Function_.push_back (r);
          continue;
        }

        break;
      }
    }

    tBay* tBay::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class tBay (*this, f, c);
    }

    tBay::
    ~tBay ()
    {
    }

    // tLNode
    //

    const tLNode::iedName_type tLNode::iedName_default_value_ (
      ::std::string ("None"), 0, 0, 0);

    tLNode::
    tLNode (const lnClass_type& lnClass)
    : ::IEC61850::SCL::tUnNaming (),
      lnInst_ (::xml_schema::flags (), this),
      lnClass_ (lnClass, ::xml_schema::flags (), this),
      iedName_ (iedName_default_value (), ::xml_schema::flags (), this),
      ldInst_ (::xml_schema::flags (), this),
      prefix_ (::xml_schema::flags (), this),
      lnType_ (::xml_schema::flags (), this)
    {
    }

    tLNode::
    tLNode (const tLNode& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
    : ::IEC61850::SCL::tUnNaming (x, f, c),
      lnInst_ (x.lnInst_, f, this),
      lnClass_ (x.lnClass_, f, this),
      iedName_ (x.iedName_, f, this),
      ldInst_ (x.ldInst_, f, this),
      prefix_ (x.prefix_, f, this),
      lnType_ (x.lnType_, f, this)
    {
    }

    tLNode::
    tLNode (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
    : ::IEC61850::SCL::tUnNaming (e, f | ::xml_schema::flags::base, c),
      lnInst_ (f, this),
      lnClass_ (f, this),
      iedName_ (f, this),
      ldInst_ (f, this),
      prefix_ (f, this),
      lnType_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void tLNode::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::IEC61850::SCL::tUnNaming::parse (p, f);

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "lnInst" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< lnInst_type > r (
            lnInst_traits::create (i, f, this));

          this->lnInst_.set (r);
          continue;
        }

        if (n.name () == "lnClass" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< lnClass_type > r (
            lnClass_traits::create (i, f, this));

          this->lnClass_.set (r);
          continue;
        }

        if (n.name () == "iedName" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< iedName_type > r (
            iedName_traits::create (i, f, this));

          this->iedName_.set (r);
          continue;
        }

        if (n.name () == "ldInst" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< ldInst_type > r (
            ldInst_traits::create (i, f, this));

          this->ldInst_.set (r);
          continue;
        }

        if (n.name () == "prefix" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< prefix_type > r (
            prefix_traits::create (i, f, this));

          this->prefix_.set (r);
          continue;
        }

        if (n.name () == "lnType" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< lnType_type > r (
            lnType_traits::create (i, f, this));

          this->lnType_.set (r);
          continue;
        }
      }

      if (!lnClass_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "lnClass",
          "");
      }

      if (!iedName_.present ())
      {
        this->iedName_.set (iedName_default_value ());
      }
    }

    tLNode* tLNode::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class tLNode (*this, f, c);
    }

    tLNode::
    ~tLNode ()
    {
    }

    // tFunction
    //

    tFunction::
    tFunction (const name_type& name)
    : ::IEC61850::SCL::tPowerSystemResource (name),
      SubFunction_ (::xml_schema::flags (), this),
      GeneralEquipment_ (::xml_schema::flags (), this)
    {
    }

    tFunction::
    tFunction (const tFunction& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
    : ::IEC61850::SCL::tPowerSystemResource (x, f, c),
      SubFunction_ (x.SubFunction_, f, this),
      GeneralEquipment_ (x.GeneralEquipment_, f, this)
    {
    }

    tFunction::
    tFunction (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
    : ::IEC61850::SCL::tPowerSystemResource (e, f | ::xml_schema::flags::base, c),
      SubFunction_ (f, this),
      GeneralEquipment_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void tFunction::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::IEC61850::SCL::tPowerSystemResource::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // SubFunction
        //
        if (n.name () == "SubFunction" && n.namespace_ () == "http://www.iec.ch/61850/2003/SCL")
        {
          ::std::auto_ptr< SubFunction_type > r (
            SubFunction_traits::create (i, f, this));

          this->SubFunction_.push_back (r);
          continue;
        }

        // GeneralEquipment
        //
        if (n.name () == "GeneralEquipment" && n.namespace_ () == "http://www.iec.ch/61850/2003/SCL")
        {
          ::std::auto_ptr< GeneralEquipment_type > r (
            GeneralEquipment_traits::create (i, f, this));

          this->GeneralEquipment_.push_back (r);
          continue;
        }

        break;
      }
    }

    tFunction* tFunction::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class tFunction (*this, f, c);
    }

    tFunction::
    ~tFunction ()
    {
    }

    // tSubFunction
    //

    tSubFunction::
    tSubFunction (const name_type& name)
    : ::IEC61850::SCL::tPowerSystemResource (name),
      GeneralEquipment_ (::xml_schema::flags (), this)
    {
    }

    tSubFunction::
    tSubFunction (const tSubFunction& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::IEC61850::SCL::tPowerSystemResource (x, f, c),
      GeneralEquipment_ (x.GeneralEquipment_, f, this)
    {
    }

    tSubFunction::
    tSubFunction (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::IEC61850::SCL::tPowerSystemResource (e, f | ::xml_schema::flags::base, c),
      GeneralEquipment_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void tSubFunction::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::IEC61850::SCL::tPowerSystemResource::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // GeneralEquipment
        //
        if (n.name () == "GeneralEquipment" && n.namespace_ () == "http://www.iec.ch/61850/2003/SCL")
        {
          ::std::auto_ptr< GeneralEquipment_type > r (
            GeneralEquipment_traits::create (i, f, this));

          this->GeneralEquipment_.push_back (r);
          continue;
        }

        break;
      }
    }

    tSubFunction* tSubFunction::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class tSubFunction (*this, f, c);
    }

    tSubFunction::
    ~tSubFunction ()
    {
    }

    // tConnectivityNode
    //

    tConnectivityNode::
    tConnectivityNode (const name_type& name,
                       const pathName_type& pathName)
    : ::IEC61850::SCL::tLNodeContainer (name),
      pathName_ (pathName, ::xml_schema::flags (), this)
    {
    }

    tConnectivityNode::
    tConnectivityNode (const tConnectivityNode& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::IEC61850::SCL::tLNodeContainer (x, f, c),
      pathName_ (x.pathName_, f, this)
    {
    }

    tConnectivityNode::
    tConnectivityNode (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::IEC61850::SCL::tLNodeContainer (e, f | ::xml_schema::flags::base, c),
      pathName_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void tConnectivityNode::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::IEC61850::SCL::tLNodeContainer::parse (p, f);

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "pathName" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< pathName_type > r (
            pathName_traits::create (i, f, this));

          this->pathName_.set (r);
          continue;
        }
      }

      if (!pathName_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "pathName",
          "");
      }
    }

    tConnectivityNode* tConnectivityNode::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class tConnectivityNode (*this, f, c);
    }

    tConnectivityNode::
    ~tConnectivityNode ()
    {
    }

    // tTerminal
    //

    tTerminal::
    tTerminal (const connectivityNode_type& connectivityNode,
               const substationName_type& substationName,
               const voltageLevelName_type& voltageLevelName,
               const bayName_type& bayName,
               const cNodeName_type& cNodeName)
    : ::IEC61850::SCL::tUnNaming (),
      name_ (::xml_schema::flags (), this),
      connectivityNode_ (connectivityNode, ::xml_schema::flags (), this),
      substationName_ (substationName, ::xml_schema::flags (), this),
      voltageLevelName_ (voltageLevelName, ::xml_schema::flags (), this),
      bayName_ (bayName, ::xml_schema::flags (), this),
      cNodeName_ (cNodeName, ::xml_schema::flags (), this)
    {
    }

    tTerminal::
    tTerminal (const tTerminal& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
    : ::IEC61850::SCL::tUnNaming (x, f, c),
      name_ (x.name_, f, this),
      connectivityNode_ (x.connectivityNode_, f, this),
      substationName_ (x.substationName_, f, this),
      voltageLevelName_ (x.voltageLevelName_, f, this),
      bayName_ (x.bayName_, f, this),
      cNodeName_ (x.cNodeName_, f, this)
    {
    }

    tTerminal::
    tTerminal (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
    : ::IEC61850::SCL::tUnNaming (e, f | ::xml_schema::flags::base, c),
      name_ (f, this),
      connectivityNode_ (f, this),
      substationName_ (f, this),
      voltageLevelName_ (f, this),
      bayName_ (f, this),
      cNodeName_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void tTerminal::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::IEC61850::SCL::tUnNaming::parse (p, f);

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "name" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< name_type > r (
            name_traits::create (i, f, this));

          this->name_.set (r);
          continue;
        }

        if (n.name () == "connectivityNode" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< connectivityNode_type > r (
            connectivityNode_traits::create (i, f, this));

          this->connectivityNode_.set (r);
          continue;
        }

        if (n.name () == "substationName" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< substationName_type > r (
            substationName_traits::create (i, f, this));

          this->substationName_.set (r);
          continue;
        }

        if (n.name () == "voltageLevelName" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< voltageLevelName_type > r (
            voltageLevelName_traits::create (i, f, this));

          this->voltageLevelName_.set (r);
          continue;
        }

        if (n.name () == "bayName" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< bayName_type > r (
            bayName_traits::create (i, f, this));

          this->bayName_.set (r);
          continue;
        }

        if (n.name () == "cNodeName" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< cNodeName_type > r (
            cNodeName_traits::create (i, f, this));

          this->cNodeName_.set (r);
          continue;
        }
      }

      if (!connectivityNode_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "connectivityNode",
          "");
      }

      if (!substationName_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "substationName",
          "");
      }

      if (!voltageLevelName_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "voltageLevelName",
          "");
      }

      if (!bayName_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "bayName",
          "");
      }

      if (!cNodeName_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "cNodeName",
          "");
      }
    }

    tTerminal* tTerminal::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class tTerminal (*this, f, c);
    }

    tTerminal::
    ~tTerminal ()
    {
    }
  }
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

namespace IEC61850
{
  namespace SCL
  {
  }
}

#include <ostream>
#include <xsd/cxx/xml/dom/serialization-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

namespace IEC61850
{
  namespace SCL
  {
    void
    operator<< (::xercesc::DOMElement& e, const tLNodeContainer& i)
    {
      e << static_cast< const ::IEC61850::SCL::tNaming& > (i);

      // LNode
      //
      for (tLNodeContainer::LNode_const_iterator
           b (i.LNode ().begin ()), n (i.LNode ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "LNode",
            "http://www.iec.ch/61850/2003/SCL",
            e));

        s << *b;
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const tPowerSystemResource& i)
    {
      e << static_cast< const ::IEC61850::SCL::tLNodeContainer& > (i);
    }

    void
    operator<< (::xercesc::DOMElement& e, const tEquipmentContainer& i)
    {
      e << static_cast< const ::IEC61850::SCL::tPowerSystemResource& > (i);

      // PowerTransformer
      //
      for (tEquipmentContainer::PowerTransformer_const_iterator
           b (i.PowerTransformer ().begin ()), n (i.PowerTransformer ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "PowerTransformer",
            "http://www.iec.ch/61850/2003/SCL",
            e));

        s << *b;
      }

      // GeneralEquipment
      //
      for (tEquipmentContainer::GeneralEquipment_const_iterator
           b (i.GeneralEquipment ().begin ()), n (i.GeneralEquipment ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "GeneralEquipment",
            "http://www.iec.ch/61850/2003/SCL",
            e));

        s << *b;
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const tEquipment& i)
    {
      e << static_cast< const ::IEC61850::SCL::tPowerSystemResource& > (i);

      // virtual
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "virtual",
            e));

        a << i.virtual_ ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const tAbstractConductingEquipment& i)
    {
      e << static_cast< const ::IEC61850::SCL::tEquipment& > (i);

      // Terminal
      //
      for (tAbstractConductingEquipment::Terminal_const_iterator
           b (i.Terminal ().begin ()), n (i.Terminal ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Terminal",
            "http://www.iec.ch/61850/2003/SCL",
            e));

        s << *b;
      }

      // SubEquipment
      //
      for (tAbstractConductingEquipment::SubEquipment_const_iterator
           b (i.SubEquipment ().begin ()), n (i.SubEquipment ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "SubEquipment",
            "http://www.iec.ch/61850/2003/SCL",
            e));

        s << *b;
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const tConductingEquipment& i)
    {
      e << static_cast< const ::IEC61850::SCL::tAbstractConductingEquipment& > (i);

      // type
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "type",
            e));

        a << i.type ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const tSubEquipment& i)
    {
      e << static_cast< const ::IEC61850::SCL::tPowerSystemResource& > (i);

      // phase
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "phase",
            e));

        a << i.phase ();
      }

      // virtual
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "virtual",
            e));

        a << i.virtual_ ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const tPowerTransformer& i)
    {
      e << static_cast< const ::IEC61850::SCL::tEquipment& > (i);

      // TransformerWinding
      //
      for (tPowerTransformer::TransformerWinding_const_iterator
           b (i.TransformerWinding ().begin ()), n (i.TransformerWinding ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "TransformerWinding",
            "http://www.iec.ch/61850/2003/SCL",
            e));

        s << *b;
      }

      // type
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "type",
            e));

        a << i.type ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const tTransformerWinding& i)
    {
      e << static_cast< const ::IEC61850::SCL::tAbstractConductingEquipment& > (i);

      // TapChanger
      //
      if (i.TapChanger ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "TapChanger",
            "http://www.iec.ch/61850/2003/SCL",
            e));

        s << *i.TapChanger ();
      }

      // type
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "type",
            e));

        a << i.type ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const tTapChanger& i)
    {
      e << static_cast< const ::IEC61850::SCL::tPowerSystemResource& > (i);

      // type
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "type",
            e));

        a << i.type ();
      }

      // virtual
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "virtual",
            e));

        a << i.virtual_ ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const tGeneralEquipment& i)
    {
      e << static_cast< const ::IEC61850::SCL::tEquipment& > (i);

      // type
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "type",
            e));

        a << i.type ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const tSubstation& i)
    {
      e << static_cast< const ::IEC61850::SCL::tEquipmentContainer& > (i);

      // VoltageLevel
      //
      for (tSubstation::VoltageLevel_const_iterator
           b (i.VoltageLevel ().begin ()), n (i.VoltageLevel ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "VoltageLevel",
            "http://www.iec.ch/61850/2003/SCL",
            e));

        s << *b;
      }

      // Function
      //
      for (tSubstation::Function_const_iterator
           b (i.Function ().begin ()), n (i.Function ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Function",
            "http://www.iec.ch/61850/2003/SCL",
            e));

        s << *b;
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const tVoltageLevel& i)
    {
      e << static_cast< const ::IEC61850::SCL::tEquipmentContainer& > (i);

      // Voltage
      //
      if (i.Voltage ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Voltage",
            "http://www.iec.ch/61850/2003/SCL",
            e));

        s << *i.Voltage ();
      }

      // Bay
      //
      for (tVoltageLevel::Bay_const_iterator
           b (i.Bay ().begin ()), n (i.Bay ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Bay",
            "http://www.iec.ch/61850/2003/SCL",
            e));

        s << *b;
      }

      // Function
      //
      for (tVoltageLevel::Function_const_iterator
           b (i.Function ().begin ()), n (i.Function ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Function",
            "http://www.iec.ch/61850/2003/SCL",
            e));

        s << *b;
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const tBay& i)
    {
      e << static_cast< const ::IEC61850::SCL::tEquipmentContainer& > (i);

      // ConductingEquipment
      //
      for (tBay::ConductingEquipment_const_iterator
           b (i.ConductingEquipment ().begin ()), n (i.ConductingEquipment ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "ConductingEquipment",
            "http://www.iec.ch/61850/2003/SCL",
            e));

        s << *b;
      }

      // ConnectivityNode
      //
      for (tBay::ConnectivityNode_const_iterator
           b (i.ConnectivityNode ().begin ()), n (i.ConnectivityNode ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "ConnectivityNode",
            "http://www.iec.ch/61850/2003/SCL",
            e));

        s << *b;
      }

      // Function
      //
      for (tBay::Function_const_iterator
           b (i.Function ().begin ()), n (i.Function ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Function",
            "http://www.iec.ch/61850/2003/SCL",
            e));

        s << *b;
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const tLNode& i)
    {
      e << static_cast< const ::IEC61850::SCL::tUnNaming& > (i);

      // lnInst
      //
      if (i.lnInst ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "lnInst",
            e));

        a << *i.lnInst ();
      }

      // lnClass
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "lnClass",
            e));

        a << i.lnClass ();
      }

      // iedName
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "iedName",
            e));

        a << i.iedName ();
      }

      // ldInst
      //
      if (i.ldInst ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "ldInst",
            e));

        a << *i.ldInst ();
      }

      // prefix
      //
      if (i.prefix ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "prefix",
            e));

        a << *i.prefix ();
      }

      // lnType
      //
      if (i.lnType ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "lnType",
            e));

        a << *i.lnType ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const tFunction& i)
    {
      e << static_cast< const ::IEC61850::SCL::tPowerSystemResource& > (i);

      // SubFunction
      //
      for (tFunction::SubFunction_const_iterator
           b (i.SubFunction ().begin ()), n (i.SubFunction ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "SubFunction",
            "http://www.iec.ch/61850/2003/SCL",
            e));

        s << *b;
      }

      // GeneralEquipment
      //
      for (tFunction::GeneralEquipment_const_iterator
           b (i.GeneralEquipment ().begin ()), n (i.GeneralEquipment ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "GeneralEquipment",
            "http://www.iec.ch/61850/2003/SCL",
            e));

        s << *b;
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const tSubFunction& i)
    {
      e << static_cast< const ::IEC61850::SCL::tPowerSystemResource& > (i);

      // GeneralEquipment
      //
      for (tSubFunction::GeneralEquipment_const_iterator
           b (i.GeneralEquipment ().begin ()), n (i.GeneralEquipment ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "GeneralEquipment",
            "http://www.iec.ch/61850/2003/SCL",
            e));

        s << *b;
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const tConnectivityNode& i)
    {
      e << static_cast< const ::IEC61850::SCL::tLNodeContainer& > (i);

      // pathName
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "pathName",
            e));

        a << i.pathName ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const tTerminal& i)
    {
      e << static_cast< const ::IEC61850::SCL::tUnNaming& > (i);

      // name
      //
      if (i.name ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "name",
            e));

        a << *i.name ();
      }

      // connectivityNode
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "connectivityNode",
            e));

        a << i.connectivityNode ();
      }

      // substationName
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "substationName",
            e));

        a << i.substationName ();
      }

      // voltageLevelName
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "voltageLevelName",
            e));

        a << i.voltageLevelName ();
      }

      // bayName
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "bayName",
            e));

        a << i.bayName ();
      }

      // cNodeName
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "cNodeName",
            e));

        a << i.cNodeName ();
      }
    }
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

