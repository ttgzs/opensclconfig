// Copyright (C) 2005-2008 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include "SCL_IED-pskel.h"

namespace IEC61850
{
  namespace SCL
  {
    namespace Validation
    {
      // tIED_pskel
      //

      void tIED_pskel::
      Services_parser (::IEC61850::SCL::Validation::tServices_pskel& p)
      {
        this->Services_parser_ = &p;
      }

      void tIED_pskel::
      AccessPoint_parser (::IEC61850::SCL::Validation::tAccessPoint_pskel& p)
      {
        this->AccessPoint_parser_ = &p;
      }

      void tIED_pskel::
      type_parser (::xml_schema::normalized_string_pskel& p)
      {
        this->type_parser_ = &p;
      }

      void tIED_pskel::
      manufacturer_parser (::xml_schema::normalized_string_pskel& p)
      {
        this->manufacturer_parser_ = &p;
      }

      void tIED_pskel::
      configVersion_parser (::xml_schema::normalized_string_pskel& p)
      {
        this->configVersion_parser_ = &p;
      }

      void tIED_pskel::
      parsers (::IEC61850::SCL::Validation::tText_pskel& Text,
               ::IEC61850::SCL::Validation::tPrivate_pskel& Private,
               ::IEC61850::SCL::Validation::tName_pskel& name,
               ::xml_schema::normalized_string_pskel& desc,
               ::IEC61850::SCL::Validation::tServices_pskel& Services,
               ::IEC61850::SCL::Validation::tAccessPoint_pskel& AccessPoint,
               ::xml_schema::normalized_string_pskel& type,
               ::xml_schema::normalized_string_pskel& manufacturer,
               ::xml_schema::normalized_string_pskel& configVersion)
      {
        this->Text_parser_ = &Text;
        this->Private_parser_ = &Private;
        this->name_parser_ = &name;
        this->desc_parser_ = &desc;
        this->Services_parser_ = &Services;
        this->AccessPoint_parser_ = &AccessPoint;
        this->type_parser_ = &type;
        this->manufacturer_parser_ = &manufacturer;
        this->configVersion_parser_ = &configVersion;
      }

      tIED_pskel::
      tIED_pskel ()
      : Services_parser_ (0),
        AccessPoint_parser_ (0),
        type_parser_ (0),
        manufacturer_parser_ (0),
        configVersion_parser_ (0),
        v_state_stack_ (sizeof (v_state_), &v_state_first_)
      {
      }

      // tServices_pskel
      //

      void tServices_pskel::
      DynAssociation_parser (::IEC61850::SCL::Validation::tServiceYesNo_pskel& p)
      {
        this->DynAssociation_parser_ = &p;
      }

      void tServices_pskel::
      SettingGroups_parser (::IEC61850::SCL::Validation::SettingGroups_pskel& p)
      {
        this->SettingGroups_parser_ = &p;
      }

      void tServices_pskel::
      GetDirectory_parser (::IEC61850::SCL::Validation::tServiceYesNo_pskel& p)
      {
        this->GetDirectory_parser_ = &p;
      }

      void tServices_pskel::
      GetDataObjectDefinition_parser (::IEC61850::SCL::Validation::tServiceYesNo_pskel& p)
      {
        this->GetDataObjectDefinition_parser_ = &p;
      }

      void tServices_pskel::
      DataObjectDirectory_parser (::IEC61850::SCL::Validation::tServiceYesNo_pskel& p)
      {
        this->DataObjectDirectory_parser_ = &p;
      }

      void tServices_pskel::
      GetDataSetValue_parser (::IEC61850::SCL::Validation::tServiceYesNo_pskel& p)
      {
        this->GetDataSetValue_parser_ = &p;
      }

      void tServices_pskel::
      SetDataSetValue_parser (::IEC61850::SCL::Validation::tServiceYesNo_pskel& p)
      {
        this->SetDataSetValue_parser_ = &p;
      }

      void tServices_pskel::
      DataSetDirectory_parser (::IEC61850::SCL::Validation::tServiceYesNo_pskel& p)
      {
        this->DataSetDirectory_parser_ = &p;
      }

      void tServices_pskel::
      ConfDataSet_parser (::IEC61850::SCL::Validation::tServiceWithMaxAndMaxAttributesAndModify_pskel& p)
      {
        this->ConfDataSet_parser_ = &p;
      }

      void tServices_pskel::
      DynDataSet_parser (::IEC61850::SCL::Validation::tServiceWithMaxAndMaxAttributes_pskel& p)
      {
        this->DynDataSet_parser_ = &p;
      }

      void tServices_pskel::
      ReadWrite_parser (::IEC61850::SCL::Validation::tServiceYesNo_pskel& p)
      {
        this->ReadWrite_parser_ = &p;
      }

      void tServices_pskel::
      TimerActivatedControl_parser (::IEC61850::SCL::Validation::tServiceYesNo_pskel& p)
      {
        this->TimerActivatedControl_parser_ = &p;
      }

      void tServices_pskel::
      ConfReportControl_parser (::IEC61850::SCL::Validation::tServiceWithMax_pskel& p)
      {
        this->ConfReportControl_parser_ = &p;
      }

      void tServices_pskel::
      GetCBValues_parser (::IEC61850::SCL::Validation::tServiceYesNo_pskel& p)
      {
        this->GetCBValues_parser_ = &p;
      }

      void tServices_pskel::
      ConfLogControl_parser (::IEC61850::SCL::Validation::tServiceWithMax_pskel& p)
      {
        this->ConfLogControl_parser_ = &p;
      }

      void tServices_pskel::
      ReportSettings_parser (::IEC61850::SCL::Validation::tReportSettings_pskel& p)
      {
        this->ReportSettings_parser_ = &p;
      }

      void tServices_pskel::
      LogSettings_parser (::IEC61850::SCL::Validation::tLogSettings_pskel& p)
      {
        this->LogSettings_parser_ = &p;
      }

      void tServices_pskel::
      GSESettings_parser (::IEC61850::SCL::Validation::tGSESettings_pskel& p)
      {
        this->GSESettings_parser_ = &p;
      }

      void tServices_pskel::
      SMVSettings_parser (::IEC61850::SCL::Validation::tSMVSettings_pskel& p)
      {
        this->SMVSettings_parser_ = &p;
      }

      void tServices_pskel::
      GSEDir_parser (::IEC61850::SCL::Validation::tServiceYesNo_pskel& p)
      {
        this->GSEDir_parser_ = &p;
      }

      void tServices_pskel::
      GOOSE_parser (::IEC61850::SCL::Validation::tServiceWithMax_pskel& p)
      {
        this->GOOSE_parser_ = &p;
      }

      void tServices_pskel::
      GSSE_parser (::IEC61850::SCL::Validation::tServiceWithMax_pskel& p)
      {
        this->GSSE_parser_ = &p;
      }

      void tServices_pskel::
      FileHandling_parser (::IEC61850::SCL::Validation::tServiceYesNo_pskel& p)
      {
        this->FileHandling_parser_ = &p;
      }

      void tServices_pskel::
      ConfLNs_parser (::IEC61850::SCL::Validation::tConfLNs_pskel& p)
      {
        this->ConfLNs_parser_ = &p;
      }

      void tServices_pskel::
      ClientServices_parser (::IEC61850::SCL::Validation::tClientServices_pskel& p)
      {
        this->ClientServices_parser_ = &p;
      }

      void tServices_pskel::
      parsers (::IEC61850::SCL::Validation::tServiceYesNo_pskel& DynAssociation,
               ::IEC61850::SCL::Validation::SettingGroups_pskel& SettingGroups,
               ::IEC61850::SCL::Validation::tServiceYesNo_pskel& GetDirectory,
               ::IEC61850::SCL::Validation::tServiceYesNo_pskel& GetDataObjectDefinition,
               ::IEC61850::SCL::Validation::tServiceYesNo_pskel& DataObjectDirectory,
               ::IEC61850::SCL::Validation::tServiceYesNo_pskel& GetDataSetValue,
               ::IEC61850::SCL::Validation::tServiceYesNo_pskel& SetDataSetValue,
               ::IEC61850::SCL::Validation::tServiceYesNo_pskel& DataSetDirectory,
               ::IEC61850::SCL::Validation::tServiceWithMaxAndMaxAttributesAndModify_pskel& ConfDataSet,
               ::IEC61850::SCL::Validation::tServiceWithMaxAndMaxAttributes_pskel& DynDataSet,
               ::IEC61850::SCL::Validation::tServiceYesNo_pskel& ReadWrite,
               ::IEC61850::SCL::Validation::tServiceYesNo_pskel& TimerActivatedControl,
               ::IEC61850::SCL::Validation::tServiceWithMax_pskel& ConfReportControl,
               ::IEC61850::SCL::Validation::tServiceYesNo_pskel& GetCBValues,
               ::IEC61850::SCL::Validation::tServiceWithMax_pskel& ConfLogControl,
               ::IEC61850::SCL::Validation::tReportSettings_pskel& ReportSettings,
               ::IEC61850::SCL::Validation::tLogSettings_pskel& LogSettings,
               ::IEC61850::SCL::Validation::tGSESettings_pskel& GSESettings,
               ::IEC61850::SCL::Validation::tSMVSettings_pskel& SMVSettings,
               ::IEC61850::SCL::Validation::tServiceYesNo_pskel& GSEDir,
               ::IEC61850::SCL::Validation::tServiceWithMax_pskel& GOOSE,
               ::IEC61850::SCL::Validation::tServiceWithMax_pskel& GSSE,
               ::IEC61850::SCL::Validation::tServiceYesNo_pskel& FileHandling,
               ::IEC61850::SCL::Validation::tConfLNs_pskel& ConfLNs,
               ::IEC61850::SCL::Validation::tClientServices_pskel& ClientServices)
      {
        this->DynAssociation_parser_ = &DynAssociation;
        this->SettingGroups_parser_ = &SettingGroups;
        this->GetDirectory_parser_ = &GetDirectory;
        this->GetDataObjectDefinition_parser_ = &GetDataObjectDefinition;
        this->DataObjectDirectory_parser_ = &DataObjectDirectory;
        this->GetDataSetValue_parser_ = &GetDataSetValue;
        this->SetDataSetValue_parser_ = &SetDataSetValue;
        this->DataSetDirectory_parser_ = &DataSetDirectory;
        this->ConfDataSet_parser_ = &ConfDataSet;
        this->DynDataSet_parser_ = &DynDataSet;
        this->ReadWrite_parser_ = &ReadWrite;
        this->TimerActivatedControl_parser_ = &TimerActivatedControl;
        this->ConfReportControl_parser_ = &ConfReportControl;
        this->GetCBValues_parser_ = &GetCBValues;
        this->ConfLogControl_parser_ = &ConfLogControl;
        this->ReportSettings_parser_ = &ReportSettings;
        this->LogSettings_parser_ = &LogSettings;
        this->GSESettings_parser_ = &GSESettings;
        this->SMVSettings_parser_ = &SMVSettings;
        this->GSEDir_parser_ = &GSEDir;
        this->GOOSE_parser_ = &GOOSE;
        this->GSSE_parser_ = &GSSE;
        this->FileHandling_parser_ = &FileHandling;
        this->ConfLNs_parser_ = &ConfLNs;
        this->ClientServices_parser_ = &ClientServices;
      }

      tServices_pskel::
      tServices_pskel ()
      : DynAssociation_parser_ (0),
        SettingGroups_parser_ (0),
        GetDirectory_parser_ (0),
        GetDataObjectDefinition_parser_ (0),
        DataObjectDirectory_parser_ (0),
        GetDataSetValue_parser_ (0),
        SetDataSetValue_parser_ (0),
        DataSetDirectory_parser_ (0),
        ConfDataSet_parser_ (0),
        DynDataSet_parser_ (0),
        ReadWrite_parser_ (0),
        TimerActivatedControl_parser_ (0),
        ConfReportControl_parser_ (0),
        GetCBValues_parser_ (0),
        ConfLogControl_parser_ (0),
        ReportSettings_parser_ (0),
        LogSettings_parser_ (0),
        GSESettings_parser_ (0),
        SMVSettings_parser_ (0),
        GSEDir_parser_ (0),
        GOOSE_parser_ (0),
        GSSE_parser_ (0),
        FileHandling_parser_ (0),
        ConfLNs_parser_ (0),
        ClientServices_parser_ (0),
        v_state_stack_ (sizeof (v_state_), &v_state_first_),
        v_all_count_ (25UL, v_all_first_)
      {
      }

      // tAccessPoint_pskel
      //

      void tAccessPoint_pskel::
      Server_parser (::IEC61850::SCL::Validation::tServer_pskel& p)
      {
        this->Server_parser_ = &p;
      }

      void tAccessPoint_pskel::
      LN_parser (::IEC61850::SCL::Validation::tLN_pskel& p)
      {
        this->LN_parser_ = &p;
      }

      void tAccessPoint_pskel::
      router_parser (::xml_schema::boolean_pskel& p)
      {
        this->router_parser_ = &p;
      }

      void tAccessPoint_pskel::
      clock_parser (::xml_schema::boolean_pskel& p)
      {
        this->clock_parser_ = &p;
      }

      void tAccessPoint_pskel::
      parsers (::IEC61850::SCL::Validation::tText_pskel& Text,
               ::IEC61850::SCL::Validation::tPrivate_pskel& Private,
               ::IEC61850::SCL::Validation::tName_pskel& name,
               ::xml_schema::normalized_string_pskel& desc,
               ::IEC61850::SCL::Validation::tServer_pskel& Server,
               ::IEC61850::SCL::Validation::tLN_pskel& LN,
               ::xml_schema::boolean_pskel& router,
               ::xml_schema::boolean_pskel& clock)
      {
        this->Text_parser_ = &Text;
        this->Private_parser_ = &Private;
        this->name_parser_ = &name;
        this->desc_parser_ = &desc;
        this->Server_parser_ = &Server;
        this->LN_parser_ = &LN;
        this->router_parser_ = &router;
        this->clock_parser_ = &clock;
      }

      tAccessPoint_pskel::
      tAccessPoint_pskel ()
      : Server_parser_ (0),
        LN_parser_ (0),
        router_parser_ (0),
        clock_parser_ (0),
        v_state_stack_ (sizeof (v_state_), &v_state_first_)
      {
      }

      // tServer_pskel
      //

      void tServer_pskel::
      Authentication_parser (::IEC61850::SCL::Validation::Authentication_pskel& p)
      {
        this->Authentication_parser_ = &p;
      }

      void tServer_pskel::
      LDevice_parser (::IEC61850::SCL::Validation::tLDevice_pskel& p)
      {
        this->LDevice_parser_ = &p;
      }

      void tServer_pskel::
      Association_parser (::IEC61850::SCL::Validation::tAssociation_pskel& p)
      {
        this->Association_parser_ = &p;
      }

      void tServer_pskel::
      timeout_parser (::xml_schema::unsigned_int_pskel& p)
      {
        this->timeout_parser_ = &p;
      }

      void tServer_pskel::
      parsers (::IEC61850::SCL::Validation::tText_pskel& Text,
               ::IEC61850::SCL::Validation::tPrivate_pskel& Private,
               ::xml_schema::normalized_string_pskel& desc,
               ::IEC61850::SCL::Validation::Authentication_pskel& Authentication,
               ::IEC61850::SCL::Validation::tLDevice_pskel& LDevice,
               ::IEC61850::SCL::Validation::tAssociation_pskel& Association,
               ::xml_schema::unsigned_int_pskel& timeout)
      {
        this->Text_parser_ = &Text;
        this->Private_parser_ = &Private;
        this->desc_parser_ = &desc;
        this->Authentication_parser_ = &Authentication;
        this->LDevice_parser_ = &LDevice;
        this->Association_parser_ = &Association;
        this->timeout_parser_ = &timeout;
      }

      tServer_pskel::
      tServer_pskel ()
      : Authentication_parser_ (0),
        LDevice_parser_ (0),
        Association_parser_ (0),
        timeout_parser_ (0),
        v_state_stack_ (sizeof (v_state_), &v_state_first_)
      {
      }

      // tLDevice_pskel
      //

      void tLDevice_pskel::
      LN0_parser (::IEC61850::SCL::Validation::LN0_pskel& p)
      {
        this->LN0_parser_ = &p;
      }

      void tLDevice_pskel::
      LN_parser (::IEC61850::SCL::Validation::tLN_pskel& p)
      {
        this->LN_parser_ = &p;
      }

      void tLDevice_pskel::
      AccessControl_parser (::IEC61850::SCL::Validation::tAccessControl_pskel& p)
      {
        this->AccessControl_parser_ = &p;
      }

      void tLDevice_pskel::
      inst_parser (::IEC61850::SCL::Validation::tName_pskel& p)
      {
        this->inst_parser_ = &p;
      }

      void tLDevice_pskel::
      ldName_parser (::IEC61850::SCL::Validation::tRestrLdName_pskel& p)
      {
        this->ldName_parser_ = &p;
      }

      void tLDevice_pskel::
      parsers (::IEC61850::SCL::Validation::tText_pskel& Text,
               ::IEC61850::SCL::Validation::tPrivate_pskel& Private,
               ::xml_schema::normalized_string_pskel& desc,
               ::IEC61850::SCL::Validation::LN0_pskel& LN0,
               ::IEC61850::SCL::Validation::tLN_pskel& LN,
               ::IEC61850::SCL::Validation::tAccessControl_pskel& AccessControl,
               ::IEC61850::SCL::Validation::tName_pskel& inst,
               ::IEC61850::SCL::Validation::tRestrLdName_pskel& ldName)
      {
        this->Text_parser_ = &Text;
        this->Private_parser_ = &Private;
        this->desc_parser_ = &desc;
        this->LN0_parser_ = &LN0;
        this->LN_parser_ = &LN;
        this->AccessControl_parser_ = &AccessControl;
        this->inst_parser_ = &inst;
        this->ldName_parser_ = &ldName;
      }

      tLDevice_pskel::
      tLDevice_pskel ()
      : LN0_parser_ (0),
        LN_parser_ (0),
        AccessControl_parser_ (0),
        inst_parser_ (0),
        ldName_parser_ (0),
        v_state_stack_ (sizeof (v_state_), &v_state_first_),
        v_state_attr_stack_ (sizeof (v_state_attr_), &v_state_attr_first_)
      {
      }

      // tAssociation_pskel
      //

      void tAssociation_pskel::
      kind_parser (::IEC61850::SCL::Validation::tAssociationKindEnum_pskel& p)
      {
        this->kind_parser_ = &p;
      }

      void tAssociation_pskel::
      associationID_parser (::IEC61850::SCL::Validation::tName_pskel& p)
      {
        this->associationID_parser_ = &p;
      }

      void tAssociation_pskel::
      iedName_parser (::IEC61850::SCL::Validation::tName_pskel& p)
      {
        this->iedName_parser_ = &p;
      }

      void tAssociation_pskel::
      ldInst_parser (::IEC61850::SCL::Validation::tName_pskel& p)
      {
        this->ldInst_parser_ = &p;
      }

      void tAssociation_pskel::
      prefix_parser (::IEC61850::SCL::Validation::tAnyName_pskel& p)
      {
        this->prefix_parser_ = &p;
      }

      void tAssociation_pskel::
      lnClass_parser (::IEC61850::SCL::Validation::tLNClassEnum_pskel& p)
      {
        this->lnClass_parser_ = &p;
      }

      void tAssociation_pskel::
      lnInst_parser (::IEC61850::SCL::Validation::tAnyName_pskel& p)
      {
        this->lnInst_parser_ = &p;
      }

      void tAssociation_pskel::
      parsers (::IEC61850::SCL::Validation::tAssociationKindEnum_pskel& kind,
               ::IEC61850::SCL::Validation::tName_pskel& associationID,
               ::IEC61850::SCL::Validation::tName_pskel& iedName,
               ::IEC61850::SCL::Validation::tName_pskel& ldInst,
               ::IEC61850::SCL::Validation::tAnyName_pskel& prefix,
               ::IEC61850::SCL::Validation::tLNClassEnum_pskel& lnClass,
               ::IEC61850::SCL::Validation::tAnyName_pskel& lnInst)
      {
        this->kind_parser_ = &kind;
        this->associationID_parser_ = &associationID;
        this->iedName_parser_ = &iedName;
        this->ldInst_parser_ = &ldInst;
        this->prefix_parser_ = &prefix;
        this->lnClass_parser_ = &lnClass;
        this->lnInst_parser_ = &lnInst;
      }

      tAssociation_pskel::
      tAssociation_pskel ()
      : kind_parser_ (0),
        associationID_parser_ (0),
        iedName_parser_ (0),
        ldInst_parser_ (0),
        prefix_parser_ (0),
        lnClass_parser_ (0),
        lnInst_parser_ (0),
        v_state_attr_stack_ (sizeof (v_state_attr_), &v_state_attr_first_)
      {
      }

      // tAnyLN_pskel
      //

      void tAnyLN_pskel::
      DataSet_parser (::IEC61850::SCL::Validation::tDataSet_pskel& p)
      {
        this->DataSet_parser_ = &p;
      }

      void tAnyLN_pskel::
      ReportControl_parser (::IEC61850::SCL::Validation::tReportControl_pskel& p)
      {
        this->ReportControl_parser_ = &p;
      }

      void tAnyLN_pskel::
      LogControl_parser (::IEC61850::SCL::Validation::tLogControl_pskel& p)
      {
        this->LogControl_parser_ = &p;
      }

      void tAnyLN_pskel::
      DOI_parser (::IEC61850::SCL::Validation::tDOI_pskel& p)
      {
        this->DOI_parser_ = &p;
      }

      void tAnyLN_pskel::
      Inputs_parser (::IEC61850::SCL::Validation::tInputs_pskel& p)
      {
        this->Inputs_parser_ = &p;
      }

      void tAnyLN_pskel::
      lnType_parser (::IEC61850::SCL::Validation::tName_pskel& p)
      {
        this->lnType_parser_ = &p;
      }

      void tAnyLN_pskel::
      parsers (::IEC61850::SCL::Validation::tText_pskel& Text,
               ::IEC61850::SCL::Validation::tPrivate_pskel& Private,
               ::xml_schema::normalized_string_pskel& desc,
               ::IEC61850::SCL::Validation::tDataSet_pskel& DataSet,
               ::IEC61850::SCL::Validation::tReportControl_pskel& ReportControl,
               ::IEC61850::SCL::Validation::tLogControl_pskel& LogControl,
               ::IEC61850::SCL::Validation::tDOI_pskel& DOI,
               ::IEC61850::SCL::Validation::tInputs_pskel& Inputs,
               ::IEC61850::SCL::Validation::tName_pskel& lnType)
      {
        this->Text_parser_ = &Text;
        this->Private_parser_ = &Private;
        this->desc_parser_ = &desc;
        this->DataSet_parser_ = &DataSet;
        this->ReportControl_parser_ = &ReportControl;
        this->LogControl_parser_ = &LogControl;
        this->DOI_parser_ = &DOI;
        this->Inputs_parser_ = &Inputs;
        this->lnType_parser_ = &lnType;
      }

      tAnyLN_pskel::
      tAnyLN_pskel ()
      : DataSet_parser_ (0),
        ReportControl_parser_ (0),
        LogControl_parser_ (0),
        DOI_parser_ (0),
        Inputs_parser_ (0),
        lnType_parser_ (0),
        v_state_stack_ (sizeof (v_state_), &v_state_first_),
        v_state_attr_stack_ (sizeof (v_state_attr_), &v_state_attr_first_)
      {
      }

      // tLN_pskel
      //

      void tLN_pskel::
      lnClass_parser (::IEC61850::SCL::Validation::tLNClassEnum_pskel& p)
      {
        this->lnClass_parser_ = &p;
      }

      void tLN_pskel::
      inst_parser (::xml_schema::unsigned_int_pskel& p)
      {
        this->inst_parser_ = &p;
      }

      void tLN_pskel::
      prefix_parser (::IEC61850::SCL::Validation::tAnyName_pskel& p)
      {
        this->prefix_parser_ = &p;
      }

      void tLN_pskel::
      parsers (::IEC61850::SCL::Validation::tText_pskel& Text,
               ::IEC61850::SCL::Validation::tPrivate_pskel& Private,
               ::xml_schema::normalized_string_pskel& desc,
               ::IEC61850::SCL::Validation::tDataSet_pskel& DataSet,
               ::IEC61850::SCL::Validation::tReportControl_pskel& ReportControl,
               ::IEC61850::SCL::Validation::tLogControl_pskel& LogControl,
               ::IEC61850::SCL::Validation::tDOI_pskel& DOI,
               ::IEC61850::SCL::Validation::tInputs_pskel& Inputs,
               ::IEC61850::SCL::Validation::tName_pskel& lnType,
               ::IEC61850::SCL::Validation::tLNClassEnum_pskel& lnClass,
               ::xml_schema::unsigned_int_pskel& inst,
               ::IEC61850::SCL::Validation::tAnyName_pskel& prefix)
      {
        this->Text_parser_ = &Text;
        this->Private_parser_ = &Private;
        this->desc_parser_ = &desc;
        this->DataSet_parser_ = &DataSet;
        this->ReportControl_parser_ = &ReportControl;
        this->LogControl_parser_ = &LogControl;
        this->DOI_parser_ = &DOI;
        this->Inputs_parser_ = &Inputs;
        this->lnType_parser_ = &lnType;
        this->lnClass_parser_ = &lnClass;
        this->inst_parser_ = &inst;
        this->prefix_parser_ = &prefix;
      }

      tLN_pskel::
      tLN_pskel ()
      : lnClass_parser_ (0),
        inst_parser_ (0),
        prefix_parser_ (0),
        v_state_attr_stack_ (sizeof (v_state_attr_), &v_state_attr_first_)
      {
      }

      // tLN0_pskel
      //

      void tLN0_pskel::
      GSEControl_parser (::IEC61850::SCL::Validation::tGSEControl_pskel& p)
      {
        this->GSEControl_parser_ = &p;
      }

      void tLN0_pskel::
      SampledValueControl_parser (::IEC61850::SCL::Validation::tSampledValueControl_pskel& p)
      {
        this->SampledValueControl_parser_ = &p;
      }

      void tLN0_pskel::
      SettingControl_parser (::IEC61850::SCL::Validation::tSettingControl_pskel& p)
      {
        this->SettingControl_parser_ = &p;
      }

      void tLN0_pskel::
      SCLControl_parser (::IEC61850::SCL::Validation::tSCLControl_pskel& p)
      {
        this->SCLControl_parser_ = &p;
      }

      void tLN0_pskel::
      Log_parser (::IEC61850::SCL::Validation::tLog_pskel& p)
      {
        this->Log_parser_ = &p;
      }

      void tLN0_pskel::
      lnClass_parser (::IEC61850::SCL::Validation::tLNClassEnum_pskel& p)
      {
        this->lnClass_parser_ = &p;
      }

      void tLN0_pskel::
      inst_parser (::xml_schema::normalized_string_pskel& p)
      {
        this->inst_parser_ = &p;
      }

      void tLN0_pskel::
      parsers (::IEC61850::SCL::Validation::tText_pskel& Text,
               ::IEC61850::SCL::Validation::tPrivate_pskel& Private,
               ::xml_schema::normalized_string_pskel& desc,
               ::IEC61850::SCL::Validation::tDataSet_pskel& DataSet,
               ::IEC61850::SCL::Validation::tReportControl_pskel& ReportControl,
               ::IEC61850::SCL::Validation::tLogControl_pskel& LogControl,
               ::IEC61850::SCL::Validation::tDOI_pskel& DOI,
               ::IEC61850::SCL::Validation::tInputs_pskel& Inputs,
               ::IEC61850::SCL::Validation::tName_pskel& lnType,
               ::IEC61850::SCL::Validation::tGSEControl_pskel& GSEControl,
               ::IEC61850::SCL::Validation::tSampledValueControl_pskel& SampledValueControl,
               ::IEC61850::SCL::Validation::tSettingControl_pskel& SettingControl,
               ::IEC61850::SCL::Validation::tSCLControl_pskel& SCLControl,
               ::IEC61850::SCL::Validation::tLog_pskel& Log,
               ::IEC61850::SCL::Validation::tLNClassEnum_pskel& lnClass,
               ::xml_schema::normalized_string_pskel& inst)
      {
        this->Text_parser_ = &Text;
        this->Private_parser_ = &Private;
        this->desc_parser_ = &desc;
        this->DataSet_parser_ = &DataSet;
        this->ReportControl_parser_ = &ReportControl;
        this->LogControl_parser_ = &LogControl;
        this->DOI_parser_ = &DOI;
        this->Inputs_parser_ = &Inputs;
        this->lnType_parser_ = &lnType;
        this->GSEControl_parser_ = &GSEControl;
        this->SampledValueControl_parser_ = &SampledValueControl;
        this->SettingControl_parser_ = &SettingControl;
        this->SCLControl_parser_ = &SCLControl;
        this->Log_parser_ = &Log;
        this->lnClass_parser_ = &lnClass;
        this->inst_parser_ = &inst;
      }

      tLN0_pskel::
      tLN0_pskel ()
      : GSEControl_parser_ (0),
        SampledValueControl_parser_ (0),
        SettingControl_parser_ (0),
        SCLControl_parser_ (0),
        Log_parser_ (0),
        lnClass_parser_ (0),
        inst_parser_ (0),
        v_state_stack_ (sizeof (v_state_), &v_state_first_),
        v_state_attr_stack_ (sizeof (v_state_attr_), &v_state_attr_first_)
      {
      }

      // tDataSet_pskel
      //

      void tDataSet_pskel::
      FCDA_parser (::IEC61850::SCL::Validation::tFCDA_pskel& p)
      {
        this->FCDA_parser_ = &p;
      }

      void tDataSet_pskel::
      FCCB_parser (::IEC61850::SCL::Validation::tFCCB_pskel& p)
      {
        this->FCCB_parser_ = &p;
      }

      void tDataSet_pskel::
      parsers (::IEC61850::SCL::Validation::tText_pskel& Text,
               ::IEC61850::SCL::Validation::tPrivate_pskel& Private,
               ::IEC61850::SCL::Validation::tName_pskel& name,
               ::xml_schema::normalized_string_pskel& desc,
               ::IEC61850::SCL::Validation::tFCDA_pskel& FCDA,
               ::IEC61850::SCL::Validation::tFCCB_pskel& FCCB)
      {
        this->Text_parser_ = &Text;
        this->Private_parser_ = &Private;
        this->name_parser_ = &name;
        this->desc_parser_ = &desc;
        this->FCDA_parser_ = &FCDA;
        this->FCCB_parser_ = &FCCB;
      }

      tDataSet_pskel::
      tDataSet_pskel ()
      : FCDA_parser_ (0),
        FCCB_parser_ (0),
        v_state_stack_ (sizeof (v_state_), &v_state_first_)
      {
      }

      // tFCDA_pskel
      //

      void tFCDA_pskel::
      ldInst_parser (::IEC61850::SCL::Validation::tName_pskel& p)
      {
        this->ldInst_parser_ = &p;
      }

      void tFCDA_pskel::
      prefix_parser (::IEC61850::SCL::Validation::tAnyName_pskel& p)
      {
        this->prefix_parser_ = &p;
      }

      void tFCDA_pskel::
      lnClass_parser (::IEC61850::SCL::Validation::tLNClassEnum_pskel& p)
      {
        this->lnClass_parser_ = &p;
      }

      void tFCDA_pskel::
      lnInst_parser (::IEC61850::SCL::Validation::tName_pskel& p)
      {
        this->lnInst_parser_ = &p;
      }

      void tFCDA_pskel::
      doName_parser (::IEC61850::SCL::Validation::tName_pskel& p)
      {
        this->doName_parser_ = &p;
      }

      void tFCDA_pskel::
      daName_parser (::IEC61850::SCL::Validation::tName_pskel& p)
      {
        this->daName_parser_ = &p;
      }

      void tFCDA_pskel::
      fc_parser (::IEC61850::SCL::Validation::tFCEnum_pskel& p)
      {
        this->fc_parser_ = &p;
      }

      void tFCDA_pskel::
      parsers (::IEC61850::SCL::Validation::tName_pskel& ldInst,
               ::IEC61850::SCL::Validation::tAnyName_pskel& prefix,
               ::IEC61850::SCL::Validation::tLNClassEnum_pskel& lnClass,
               ::IEC61850::SCL::Validation::tName_pskel& lnInst,
               ::IEC61850::SCL::Validation::tName_pskel& doName,
               ::IEC61850::SCL::Validation::tName_pskel& daName,
               ::IEC61850::SCL::Validation::tFCEnum_pskel& fc)
      {
        this->ldInst_parser_ = &ldInst;
        this->prefix_parser_ = &prefix;
        this->lnClass_parser_ = &lnClass;
        this->lnInst_parser_ = &lnInst;
        this->doName_parser_ = &doName;
        this->daName_parser_ = &daName;
        this->fc_parser_ = &fc;
      }

      tFCDA_pskel::
      tFCDA_pskel ()
      : ldInst_parser_ (0),
        prefix_parser_ (0),
        lnClass_parser_ (0),
        lnInst_parser_ (0),
        doName_parser_ (0),
        daName_parser_ (0),
        fc_parser_ (0),
        v_state_attr_stack_ (sizeof (v_state_attr_), &v_state_attr_first_)
      {
      }

      // tFCCB_pskel
      //

      void tFCCB_pskel::
      ldInst_parser (::IEC61850::SCL::Validation::tName_pskel& p)
      {
        this->ldInst_parser_ = &p;
      }

      void tFCCB_pskel::
      prefix_parser (::IEC61850::SCL::Validation::tAnyName_pskel& p)
      {
        this->prefix_parser_ = &p;
      }

      void tFCCB_pskel::
      lnClass_parser (::IEC61850::SCL::Validation::tLNClassEnum_pskel& p)
      {
        this->lnClass_parser_ = &p;
      }

      void tFCCB_pskel::
      lnInst_parser (::IEC61850::SCL::Validation::tName_pskel& p)
      {
        this->lnInst_parser_ = &p;
      }

      void tFCCB_pskel::
      cbName_parser (::IEC61850::SCL::Validation::tName_pskel& p)
      {
        this->cbName_parser_ = &p;
      }

      void tFCCB_pskel::
      daName_parser (::IEC61850::SCL::Validation::tName_pskel& p)
      {
        this->daName_parser_ = &p;
      }

      void tFCCB_pskel::
      fc_parser (::IEC61850::SCL::Validation::tServiceFCEnum_pskel& p)
      {
        this->fc_parser_ = &p;
      }

      void tFCCB_pskel::
      parsers (::IEC61850::SCL::Validation::tName_pskel& ldInst,
               ::IEC61850::SCL::Validation::tAnyName_pskel& prefix,
               ::IEC61850::SCL::Validation::tLNClassEnum_pskel& lnClass,
               ::IEC61850::SCL::Validation::tName_pskel& lnInst,
               ::IEC61850::SCL::Validation::tName_pskel& cbName,
               ::IEC61850::SCL::Validation::tName_pskel& daName,
               ::IEC61850::SCL::Validation::tServiceFCEnum_pskel& fc)
      {
        this->ldInst_parser_ = &ldInst;
        this->prefix_parser_ = &prefix;
        this->lnClass_parser_ = &lnClass;
        this->lnInst_parser_ = &lnInst;
        this->cbName_parser_ = &cbName;
        this->daName_parser_ = &daName;
        this->fc_parser_ = &fc;
      }

      tFCCB_pskel::
      tFCCB_pskel ()
      : ldInst_parser_ (0),
        prefix_parser_ (0),
        lnClass_parser_ (0),
        lnInst_parser_ (0),
        cbName_parser_ (0),
        daName_parser_ (0),
        fc_parser_ (0),
        v_state_attr_stack_ (sizeof (v_state_attr_), &v_state_attr_first_)
      {
      }

      // tControl_pskel
      //

      void tControl_pskel::
      datSet_parser (::IEC61850::SCL::Validation::tName_pskel& p)
      {
        this->datSet_parser_ = &p;
      }

      void tControl_pskel::
      parsers (::IEC61850::SCL::Validation::tText_pskel& Text,
               ::IEC61850::SCL::Validation::tPrivate_pskel& Private,
               ::IEC61850::SCL::Validation::tName_pskel& name,
               ::xml_schema::normalized_string_pskel& desc,
               ::IEC61850::SCL::Validation::tName_pskel& datSet)
      {
        this->Text_parser_ = &Text;
        this->Private_parser_ = &Private;
        this->name_parser_ = &name;
        this->desc_parser_ = &desc;
        this->datSet_parser_ = &datSet;
      }

      tControl_pskel::
      tControl_pskel ()
      : datSet_parser_ (0)
      {
      }

      // tControlWithTriggerOpt_pskel
      //

      void tControlWithTriggerOpt_pskel::
      TrgOps_parser (::IEC61850::SCL::Validation::tTrgOps_pskel& p)
      {
        this->TrgOps_parser_ = &p;
      }

      void tControlWithTriggerOpt_pskel::
      intgPd_parser (::xml_schema::unsigned_int_pskel& p)
      {
        this->intgPd_parser_ = &p;
      }

      void tControlWithTriggerOpt_pskel::
      parsers (::IEC61850::SCL::Validation::tText_pskel& Text,
               ::IEC61850::SCL::Validation::tPrivate_pskel& Private,
               ::IEC61850::SCL::Validation::tName_pskel& name,
               ::xml_schema::normalized_string_pskel& desc,
               ::IEC61850::SCL::Validation::tName_pskel& datSet,
               ::IEC61850::SCL::Validation::tTrgOps_pskel& TrgOps,
               ::xml_schema::unsigned_int_pskel& intgPd)
      {
        this->Text_parser_ = &Text;
        this->Private_parser_ = &Private;
        this->name_parser_ = &name;
        this->desc_parser_ = &desc;
        this->datSet_parser_ = &datSet;
        this->TrgOps_parser_ = &TrgOps;
        this->intgPd_parser_ = &intgPd;
      }

      tControlWithTriggerOpt_pskel::
      tControlWithTriggerOpt_pskel ()
      : TrgOps_parser_ (0),
        intgPd_parser_ (0),
        v_state_stack_ (sizeof (v_state_), &v_state_first_)
      {
      }

      // tTrgOps_pskel
      //

      void tTrgOps_pskel::
      dchg_parser (::xml_schema::boolean_pskel& p)
      {
        this->dchg_parser_ = &p;
      }

      void tTrgOps_pskel::
      qchg_parser (::xml_schema::boolean_pskel& p)
      {
        this->qchg_parser_ = &p;
      }

      void tTrgOps_pskel::
      dupd_parser (::xml_schema::boolean_pskel& p)
      {
        this->dupd_parser_ = &p;
      }

      void tTrgOps_pskel::
      period_parser (::xml_schema::boolean_pskel& p)
      {
        this->period_parser_ = &p;
      }

      void tTrgOps_pskel::
      parsers (::xml_schema::boolean_pskel& dchg,
               ::xml_schema::boolean_pskel& qchg,
               ::xml_schema::boolean_pskel& dupd,
               ::xml_schema::boolean_pskel& period)
      {
        this->dchg_parser_ = &dchg;
        this->qchg_parser_ = &qchg;
        this->dupd_parser_ = &dupd;
        this->period_parser_ = &period;
      }

      tTrgOps_pskel::
      tTrgOps_pskel ()
      : dchg_parser_ (0),
        qchg_parser_ (0),
        dupd_parser_ (0),
        period_parser_ (0)
      {
      }

      // tReportControl_pskel
      //

      void tReportControl_pskel::
      OptFields_parser (::IEC61850::SCL::Validation::OptFields_pskel& p)
      {
        this->OptFields_parser_ = &p;
      }

      void tReportControl_pskel::
      RptEnabled_parser (::IEC61850::SCL::Validation::tRptEnabled_pskel& p)
      {
        this->RptEnabled_parser_ = &p;
      }

      void tReportControl_pskel::
      rptID_parser (::IEC61850::SCL::Validation::tName_pskel& p)
      {
        this->rptID_parser_ = &p;
      }

      void tReportControl_pskel::
      confRev_parser (::xml_schema::unsigned_int_pskel& p)
      {
        this->confRev_parser_ = &p;
      }

      void tReportControl_pskel::
      buffered_parser (::xml_schema::boolean_pskel& p)
      {
        this->buffered_parser_ = &p;
      }

      void tReportControl_pskel::
      bufTime_parser (::xml_schema::unsigned_int_pskel& p)
      {
        this->bufTime_parser_ = &p;
      }

      void tReportControl_pskel::
      parsers (::IEC61850::SCL::Validation::tText_pskel& Text,
               ::IEC61850::SCL::Validation::tPrivate_pskel& Private,
               ::IEC61850::SCL::Validation::tName_pskel& name,
               ::xml_schema::normalized_string_pskel& desc,
               ::IEC61850::SCL::Validation::tName_pskel& datSet,
               ::IEC61850::SCL::Validation::tTrgOps_pskel& TrgOps,
               ::xml_schema::unsigned_int_pskel& intgPd,
               ::IEC61850::SCL::Validation::OptFields_pskel& OptFields,
               ::IEC61850::SCL::Validation::tRptEnabled_pskel& RptEnabled,
               ::IEC61850::SCL::Validation::tName_pskel& rptID,
               ::xml_schema::unsigned_int_pskel& confRev,
               ::xml_schema::boolean_pskel& buffered,
               ::xml_schema::unsigned_int_pskel& bufTime)
      {
        this->Text_parser_ = &Text;
        this->Private_parser_ = &Private;
        this->name_parser_ = &name;
        this->desc_parser_ = &desc;
        this->datSet_parser_ = &datSet;
        this->TrgOps_parser_ = &TrgOps;
        this->intgPd_parser_ = &intgPd;
        this->OptFields_parser_ = &OptFields;
        this->RptEnabled_parser_ = &RptEnabled;
        this->rptID_parser_ = &rptID;
        this->confRev_parser_ = &confRev;
        this->buffered_parser_ = &buffered;
        this->bufTime_parser_ = &bufTime;
      }

      tReportControl_pskel::
      tReportControl_pskel ()
      : OptFields_parser_ (0),
        RptEnabled_parser_ (0),
        rptID_parser_ (0),
        confRev_parser_ (0),
        buffered_parser_ (0),
        bufTime_parser_ (0),
        v_state_stack_ (sizeof (v_state_), &v_state_first_),
        v_state_attr_stack_ (sizeof (v_state_attr_), &v_state_attr_first_)
      {
      }

      // tRptEnabled_pskel
      //

      void tRptEnabled_pskel::
      ClientLN_parser (::IEC61850::SCL::Validation::tClientLN_pskel& p)
      {
        this->ClientLN_parser_ = &p;
      }

      void tRptEnabled_pskel::
      max_parser (::xml_schema::unsigned_int_pskel& p)
      {
        this->max_parser_ = &p;
      }

      void tRptEnabled_pskel::
      parsers (::IEC61850::SCL::Validation::tText_pskel& Text,
               ::IEC61850::SCL::Validation::tPrivate_pskel& Private,
               ::xml_schema::normalized_string_pskel& desc,
               ::IEC61850::SCL::Validation::tClientLN_pskel& ClientLN,
               ::xml_schema::unsigned_int_pskel& max)
      {
        this->Text_parser_ = &Text;
        this->Private_parser_ = &Private;
        this->desc_parser_ = &desc;
        this->ClientLN_parser_ = &ClientLN;
        this->max_parser_ = &max;
      }

      tRptEnabled_pskel::
      tRptEnabled_pskel ()
      : ClientLN_parser_ (0),
        max_parser_ (0),
        v_state_stack_ (sizeof (v_state_), &v_state_first_)
      {
      }

      // tClientLN_pskel
      //

      void tClientLN_pskel::
      iedName_parser (::IEC61850::SCL::Validation::tName_pskel& p)
      {
        this->iedName_parser_ = &p;
      }

      void tClientLN_pskel::
      ldInst_parser (::IEC61850::SCL::Validation::tName_pskel& p)
      {
        this->ldInst_parser_ = &p;
      }

      void tClientLN_pskel::
      prefix_parser (::IEC61850::SCL::Validation::tAnyName_pskel& p)
      {
        this->prefix_parser_ = &p;
      }

      void tClientLN_pskel::
      lnClass_parser (::IEC61850::SCL::Validation::tLNClassEnum_pskel& p)
      {
        this->lnClass_parser_ = &p;
      }

      void tClientLN_pskel::
      lnInst_parser (::IEC61850::SCL::Validation::tAnyName_pskel& p)
      {
        this->lnInst_parser_ = &p;
      }

      void tClientLN_pskel::
      parsers (::IEC61850::SCL::Validation::tName_pskel& iedName,
               ::IEC61850::SCL::Validation::tName_pskel& ldInst,
               ::IEC61850::SCL::Validation::tAnyName_pskel& prefix,
               ::IEC61850::SCL::Validation::tLNClassEnum_pskel& lnClass,
               ::IEC61850::SCL::Validation::tAnyName_pskel& lnInst)
      {
        this->iedName_parser_ = &iedName;
        this->ldInst_parser_ = &ldInst;
        this->prefix_parser_ = &prefix;
        this->lnClass_parser_ = &lnClass;
        this->lnInst_parser_ = &lnInst;
      }

      tClientLN_pskel::
      tClientLN_pskel ()
      : iedName_parser_ (0),
        ldInst_parser_ (0),
        prefix_parser_ (0),
        lnClass_parser_ (0),
        lnInst_parser_ (0),
        v_state_attr_stack_ (sizeof (v_state_attr_), &v_state_attr_first_)
      {
      }

      // tLogControl_pskel
      //

      void tLogControl_pskel::
      logName_parser (::IEC61850::SCL::Validation::tName_pskel& p)
      {
        this->logName_parser_ = &p;
      }

      void tLogControl_pskel::
      logEna_parser (::xml_schema::boolean_pskel& p)
      {
        this->logEna_parser_ = &p;
      }

      void tLogControl_pskel::
      reasonCode_parser (::xml_schema::boolean_pskel& p)
      {
        this->reasonCode_parser_ = &p;
      }

      void tLogControl_pskel::
      parsers (::IEC61850::SCL::Validation::tText_pskel& Text,
               ::IEC61850::SCL::Validation::tPrivate_pskel& Private,
               ::IEC61850::SCL::Validation::tName_pskel& name,
               ::xml_schema::normalized_string_pskel& desc,
               ::IEC61850::SCL::Validation::tName_pskel& datSet,
               ::IEC61850::SCL::Validation::tTrgOps_pskel& TrgOps,
               ::xml_schema::unsigned_int_pskel& intgPd,
               ::IEC61850::SCL::Validation::tName_pskel& logName,
               ::xml_schema::boolean_pskel& logEna,
               ::xml_schema::boolean_pskel& reasonCode)
      {
        this->Text_parser_ = &Text;
        this->Private_parser_ = &Private;
        this->name_parser_ = &name;
        this->desc_parser_ = &desc;
        this->datSet_parser_ = &datSet;
        this->TrgOps_parser_ = &TrgOps;
        this->intgPd_parser_ = &intgPd;
        this->logName_parser_ = &logName;
        this->logEna_parser_ = &logEna;
        this->reasonCode_parser_ = &reasonCode;
      }

      tLogControl_pskel::
      tLogControl_pskel ()
      : logName_parser_ (0),
        logEna_parser_ (0),
        reasonCode_parser_ (0),
        v_state_attr_stack_ (sizeof (v_state_attr_), &v_state_attr_first_)
      {
      }

      // tInputs_pskel
      //

      void tInputs_pskel::
      ExtRef_parser (::IEC61850::SCL::Validation::tExtRef_pskel& p)
      {
        this->ExtRef_parser_ = &p;
      }

      void tInputs_pskel::
      parsers (::IEC61850::SCL::Validation::tText_pskel& Text,
               ::IEC61850::SCL::Validation::tPrivate_pskel& Private,
               ::xml_schema::normalized_string_pskel& desc,
               ::IEC61850::SCL::Validation::tExtRef_pskel& ExtRef)
      {
        this->Text_parser_ = &Text;
        this->Private_parser_ = &Private;
        this->desc_parser_ = &desc;
        this->ExtRef_parser_ = &ExtRef;
      }

      tInputs_pskel::
      tInputs_pskel ()
      : ExtRef_parser_ (0),
        v_state_stack_ (sizeof (v_state_), &v_state_first_)
      {
      }

      // tExtRef_pskel
      //

      void tExtRef_pskel::
      iedName_parser (::IEC61850::SCL::Validation::tName_pskel& p)
      {
        this->iedName_parser_ = &p;
      }

      void tExtRef_pskel::
      ldInst_parser (::IEC61850::SCL::Validation::tName_pskel& p)
      {
        this->ldInst_parser_ = &p;
      }

      void tExtRef_pskel::
      prefix_parser (::IEC61850::SCL::Validation::tAnyName_pskel& p)
      {
        this->prefix_parser_ = &p;
      }

      void tExtRef_pskel::
      lnClass_parser (::IEC61850::SCL::Validation::tLNClassEnum_pskel& p)
      {
        this->lnClass_parser_ = &p;
      }

      void tExtRef_pskel::
      lnInst_parser (::IEC61850::SCL::Validation::tAnyName_pskel& p)
      {
        this->lnInst_parser_ = &p;
      }

      void tExtRef_pskel::
      doName_parser (::IEC61850::SCL::Validation::tName_pskel& p)
      {
        this->doName_parser_ = &p;
      }

      void tExtRef_pskel::
      daName_parser (::IEC61850::SCL::Validation::tName_pskel& p)
      {
        this->daName_parser_ = &p;
      }

      void tExtRef_pskel::
      intAddr_parser (::xml_schema::normalized_string_pskel& p)
      {
        this->intAddr_parser_ = &p;
      }

      void tExtRef_pskel::
      parsers (::IEC61850::SCL::Validation::tName_pskel& iedName,
               ::IEC61850::SCL::Validation::tName_pskel& ldInst,
               ::IEC61850::SCL::Validation::tAnyName_pskel& prefix,
               ::IEC61850::SCL::Validation::tLNClassEnum_pskel& lnClass,
               ::IEC61850::SCL::Validation::tAnyName_pskel& lnInst,
               ::IEC61850::SCL::Validation::tName_pskel& doName,
               ::IEC61850::SCL::Validation::tName_pskel& daName,
               ::xml_schema::normalized_string_pskel& intAddr)
      {
        this->iedName_parser_ = &iedName;
        this->ldInst_parser_ = &ldInst;
        this->prefix_parser_ = &prefix;
        this->lnClass_parser_ = &lnClass;
        this->lnInst_parser_ = &lnInst;
        this->doName_parser_ = &doName;
        this->daName_parser_ = &daName;
        this->intAddr_parser_ = &intAddr;
      }

      tExtRef_pskel::
      tExtRef_pskel ()
      : iedName_parser_ (0),
        ldInst_parser_ (0),
        prefix_parser_ (0),
        lnClass_parser_ (0),
        lnInst_parser_ (0),
        doName_parser_ (0),
        daName_parser_ (0),
        intAddr_parser_ (0),
        v_state_attr_stack_ (sizeof (v_state_attr_), &v_state_attr_first_)
      {
      }

      // tControlWithIEDName_pskel
      //

      void tControlWithIEDName_pskel::
      IEDName_parser (::IEC61850::SCL::Validation::tName_pskel& p)
      {
        this->IEDName_parser_ = &p;
      }

      void tControlWithIEDName_pskel::
      confRev_parser (::xml_schema::unsigned_int_pskel& p)
      {
        this->confRev_parser_ = &p;
      }

      void tControlWithIEDName_pskel::
      parsers (::IEC61850::SCL::Validation::tText_pskel& Text,
               ::IEC61850::SCL::Validation::tPrivate_pskel& Private,
               ::IEC61850::SCL::Validation::tName_pskel& name,
               ::xml_schema::normalized_string_pskel& desc,
               ::IEC61850::SCL::Validation::tName_pskel& datSet,
               ::IEC61850::SCL::Validation::tName_pskel& IEDName,
               ::xml_schema::unsigned_int_pskel& confRev)
      {
        this->Text_parser_ = &Text;
        this->Private_parser_ = &Private;
        this->name_parser_ = &name;
        this->desc_parser_ = &desc;
        this->datSet_parser_ = &datSet;
        this->IEDName_parser_ = &IEDName;
        this->confRev_parser_ = &confRev;
      }

      tControlWithIEDName_pskel::
      tControlWithIEDName_pskel ()
      : IEDName_parser_ (0),
        confRev_parser_ (0),
        v_state_stack_ (sizeof (v_state_), &v_state_first_)
      {
      }

      // tGSEControl_pskel
      //

      void tGSEControl_pskel::
      type_parser (::IEC61850::SCL::Validation::tGSEControlTypeEnum_pskel& p)
      {
        this->type_parser_ = &p;
      }

      void tGSEControl_pskel::
      appID_parser (::xml_schema::normalized_string_pskel& p)
      {
        this->appID_parser_ = &p;
      }

      void tGSEControl_pskel::
      parsers (::IEC61850::SCL::Validation::tText_pskel& Text,
               ::IEC61850::SCL::Validation::tPrivate_pskel& Private,
               ::IEC61850::SCL::Validation::tName_pskel& name,
               ::xml_schema::normalized_string_pskel& desc,
               ::IEC61850::SCL::Validation::tName_pskel& datSet,
               ::IEC61850::SCL::Validation::tName_pskel& IEDName,
               ::xml_schema::unsigned_int_pskel& confRev,
               ::IEC61850::SCL::Validation::tGSEControlTypeEnum_pskel& type,
               ::xml_schema::normalized_string_pskel& appID)
      {
        this->Text_parser_ = &Text;
        this->Private_parser_ = &Private;
        this->name_parser_ = &name;
        this->desc_parser_ = &desc;
        this->datSet_parser_ = &datSet;
        this->IEDName_parser_ = &IEDName;
        this->confRev_parser_ = &confRev;
        this->type_parser_ = &type;
        this->appID_parser_ = &appID;
      }

      tGSEControl_pskel::
      tGSEControl_pskel ()
      : type_parser_ (0),
        appID_parser_ (0),
        v_state_attr_stack_ (sizeof (v_state_attr_), &v_state_attr_first_)
      {
      }

      // tSampledValueControl_pskel
      //

      void tSampledValueControl_pskel::
      SmvOpts_parser (::IEC61850::SCL::Validation::SmvOpts_pskel& p)
      {
        this->SmvOpts_parser_ = &p;
      }

      void tSampledValueControl_pskel::
      smvID_parser (::xml_schema::normalized_string_pskel& p)
      {
        this->smvID_parser_ = &p;
      }

      void tSampledValueControl_pskel::
      multicast_parser (::xml_schema::boolean_pskel& p)
      {
        this->multicast_parser_ = &p;
      }

      void tSampledValueControl_pskel::
      smpRate_parser (::xml_schema::unsigned_int_pskel& p)
      {
        this->smpRate_parser_ = &p;
      }

      void tSampledValueControl_pskel::
      nofASDU_parser (::xml_schema::unsigned_int_pskel& p)
      {
        this->nofASDU_parser_ = &p;
      }

      void tSampledValueControl_pskel::
      parsers (::IEC61850::SCL::Validation::tText_pskel& Text,
               ::IEC61850::SCL::Validation::tPrivate_pskel& Private,
               ::IEC61850::SCL::Validation::tName_pskel& name,
               ::xml_schema::normalized_string_pskel& desc,
               ::IEC61850::SCL::Validation::tName_pskel& datSet,
               ::IEC61850::SCL::Validation::tName_pskel& IEDName,
               ::xml_schema::unsigned_int_pskel& confRev,
               ::IEC61850::SCL::Validation::SmvOpts_pskel& SmvOpts,
               ::xml_schema::normalized_string_pskel& smvID,
               ::xml_schema::boolean_pskel& multicast,
               ::xml_schema::unsigned_int_pskel& smpRate,
               ::xml_schema::unsigned_int_pskel& nofASDU)
      {
        this->Text_parser_ = &Text;
        this->Private_parser_ = &Private;
        this->name_parser_ = &name;
        this->desc_parser_ = &desc;
        this->datSet_parser_ = &datSet;
        this->IEDName_parser_ = &IEDName;
        this->confRev_parser_ = &confRev;
        this->SmvOpts_parser_ = &SmvOpts;
        this->smvID_parser_ = &smvID;
        this->multicast_parser_ = &multicast;
        this->smpRate_parser_ = &smpRate;
        this->nofASDU_parser_ = &nofASDU;
      }

      tSampledValueControl_pskel::
      tSampledValueControl_pskel ()
      : SmvOpts_parser_ (0),
        smvID_parser_ (0),
        multicast_parser_ (0),
        smpRate_parser_ (0),
        nofASDU_parser_ (0),
        v_state_stack_ (sizeof (v_state_), &v_state_first_),
        v_state_attr_stack_ (sizeof (v_state_attr_), &v_state_attr_first_)
      {
      }

      // tSettingControl_pskel
      //

      void tSettingControl_pskel::
      numOfSGs_parser (::xml_schema::unsigned_int_pskel& p)
      {
        this->numOfSGs_parser_ = &p;
      }

      void tSettingControl_pskel::
      actSG_parser (::xml_schema::unsigned_int_pskel& p)
      {
        this->actSG_parser_ = &p;
      }

      void tSettingControl_pskel::
      parsers (::IEC61850::SCL::Validation::tText_pskel& Text,
               ::IEC61850::SCL::Validation::tPrivate_pskel& Private,
               ::xml_schema::normalized_string_pskel& desc,
               ::xml_schema::unsigned_int_pskel& numOfSGs,
               ::xml_schema::unsigned_int_pskel& actSG)
      {
        this->Text_parser_ = &Text;
        this->Private_parser_ = &Private;
        this->desc_parser_ = &desc;
        this->numOfSGs_parser_ = &numOfSGs;
        this->actSG_parser_ = &actSG;
      }

      tSettingControl_pskel::
      tSettingControl_pskel ()
      : numOfSGs_parser_ (0),
        actSG_parser_ (0),
        v_state_attr_stack_ (sizeof (v_state_attr_), &v_state_attr_first_)
      {
      }

      // tDOI_pskel
      //

      void tDOI_pskel::
      SDI_parser (::IEC61850::SCL::Validation::tSDI_pskel& p)
      {
        this->SDI_parser_ = &p;
      }

      void tDOI_pskel::
      DAI_parser (::IEC61850::SCL::Validation::tDAI_pskel& p)
      {
        this->DAI_parser_ = &p;
      }

      void tDOI_pskel::
      name_parser (::IEC61850::SCL::Validation::tRestrName1stU_pskel& p)
      {
        this->name_parser_ = &p;
      }

      void tDOI_pskel::
      ix_parser (::xml_schema::unsigned_int_pskel& p)
      {
        this->ix_parser_ = &p;
      }

      void tDOI_pskel::
      accessControl_parser (::xml_schema::normalized_string_pskel& p)
      {
        this->accessControl_parser_ = &p;
      }

      void tDOI_pskel::
      parsers (::IEC61850::SCL::Validation::tText_pskel& Text,
               ::IEC61850::SCL::Validation::tPrivate_pskel& Private,
               ::xml_schema::normalized_string_pskel& desc,
               ::IEC61850::SCL::Validation::tSDI_pskel& SDI,
               ::IEC61850::SCL::Validation::tDAI_pskel& DAI,
               ::IEC61850::SCL::Validation::tRestrName1stU_pskel& name,
               ::xml_schema::unsigned_int_pskel& ix,
               ::xml_schema::normalized_string_pskel& accessControl)
      {
        this->Text_parser_ = &Text;
        this->Private_parser_ = &Private;
        this->desc_parser_ = &desc;
        this->SDI_parser_ = &SDI;
        this->DAI_parser_ = &DAI;
        this->name_parser_ = &name;
        this->ix_parser_ = &ix;
        this->accessControl_parser_ = &accessControl;
      }

      tDOI_pskel::
      tDOI_pskel ()
      : SDI_parser_ (0),
        DAI_parser_ (0),
        name_parser_ (0),
        ix_parser_ (0),
        accessControl_parser_ (0),
        v_state_stack_ (sizeof (v_state_), &v_state_first_),
        v_state_attr_stack_ (sizeof (v_state_attr_), &v_state_attr_first_)
      {
      }

      // tSDI_pskel
      //

      void tSDI_pskel::
      SDI_parser (::IEC61850::SCL::Validation::tSDI_pskel& p)
      {
        this->SDI_parser_ = &p;
      }

      void tSDI_pskel::
      DAI_parser (::IEC61850::SCL::Validation::tDAI_pskel& p)
      {
        this->DAI_parser_ = &p;
      }

      void tSDI_pskel::
      name_parser (::IEC61850::SCL::Validation::tAttributeNameEnum_pskel& p)
      {
        this->name_parser_ = &p;
      }

      void tSDI_pskel::
      ix_parser (::xml_schema::unsigned_int_pskel& p)
      {
        this->ix_parser_ = &p;
      }

      void tSDI_pskel::
      parsers (::IEC61850::SCL::Validation::tText_pskel& Text,
               ::IEC61850::SCL::Validation::tPrivate_pskel& Private,
               ::xml_schema::normalized_string_pskel& desc,
               ::IEC61850::SCL::Validation::tSDI_pskel& SDI,
               ::IEC61850::SCL::Validation::tDAI_pskel& DAI,
               ::IEC61850::SCL::Validation::tAttributeNameEnum_pskel& name,
               ::xml_schema::unsigned_int_pskel& ix)
      {
        this->Text_parser_ = &Text;
        this->Private_parser_ = &Private;
        this->desc_parser_ = &desc;
        this->SDI_parser_ = &SDI;
        this->DAI_parser_ = &DAI;
        this->name_parser_ = &name;
        this->ix_parser_ = &ix;
      }

      tSDI_pskel::
      tSDI_pskel ()
      : SDI_parser_ (0),
        DAI_parser_ (0),
        name_parser_ (0),
        ix_parser_ (0),
        v_state_stack_ (sizeof (v_state_), &v_state_first_),
        v_state_attr_stack_ (sizeof (v_state_attr_), &v_state_attr_first_)
      {
      }

      // tDAI_pskel
      //

      void tDAI_pskel::
      Val_parser (::IEC61850::SCL::Validation::tVal_pskel& p)
      {
        this->Val_parser_ = &p;
      }

      void tDAI_pskel::
      name_parser (::IEC61850::SCL::Validation::tAttributeNameEnum_pskel& p)
      {
        this->name_parser_ = &p;
      }

      void tDAI_pskel::
      sAddr_parser (::xml_schema::normalized_string_pskel& p)
      {
        this->sAddr_parser_ = &p;
      }

      void tDAI_pskel::
      valKind_parser (::IEC61850::SCL::Validation::tValKindEnum_pskel& p)
      {
        this->valKind_parser_ = &p;
      }

      void tDAI_pskel::
      ix_parser (::xml_schema::unsigned_int_pskel& p)
      {
        this->ix_parser_ = &p;
      }

      void tDAI_pskel::
      parsers (::IEC61850::SCL::Validation::tText_pskel& Text,
               ::IEC61850::SCL::Validation::tPrivate_pskel& Private,
               ::xml_schema::normalized_string_pskel& desc,
               ::IEC61850::SCL::Validation::tVal_pskel& Val,
               ::IEC61850::SCL::Validation::tAttributeNameEnum_pskel& name,
               ::xml_schema::normalized_string_pskel& sAddr,
               ::IEC61850::SCL::Validation::tValKindEnum_pskel& valKind,
               ::xml_schema::unsigned_int_pskel& ix)
      {
        this->Text_parser_ = &Text;
        this->Private_parser_ = &Private;
        this->desc_parser_ = &desc;
        this->Val_parser_ = &Val;
        this->name_parser_ = &name;
        this->sAddr_parser_ = &sAddr;
        this->valKind_parser_ = &valKind;
        this->ix_parser_ = &ix;
      }

      tDAI_pskel::
      tDAI_pskel ()
      : Val_parser_ (0),
        name_parser_ (0),
        sAddr_parser_ (0),
        valKind_parser_ (0),
        ix_parser_ (0),
        v_state_stack_ (sizeof (v_state_), &v_state_first_),
        v_state_attr_stack_ (sizeof (v_state_attr_), &v_state_attr_first_)
      {
      }

      // tServiceWithMax_pskel
      //

      void tServiceWithMax_pskel::
      max_parser (::xml_schema::unsigned_int_pskel& p)
      {
        this->max_parser_ = &p;
      }

      void tServiceWithMax_pskel::
      parsers (::xml_schema::unsigned_int_pskel& max)
      {
        this->max_parser_ = &max;
      }

      tServiceWithMax_pskel::
      tServiceWithMax_pskel ()
      : max_parser_ (0),
        v_state_attr_stack_ (sizeof (v_state_attr_), &v_state_attr_first_)
      {
      }

      // tServiceWithMaxAndMaxAttributes_pskel
      //

      void tServiceWithMaxAndMaxAttributes_pskel::
      maxAttributes_parser (::xml_schema::unsigned_int_pskel& p)
      {
        this->maxAttributes_parser_ = &p;
      }

      void tServiceWithMaxAndMaxAttributes_pskel::
      parsers (::xml_schema::unsigned_int_pskel& max,
               ::xml_schema::unsigned_int_pskel& maxAttributes)
      {
        this->max_parser_ = &max;
        this->maxAttributes_parser_ = &maxAttributes;
      }

      tServiceWithMaxAndMaxAttributes_pskel::
      tServiceWithMaxAndMaxAttributes_pskel ()
      : maxAttributes_parser_ (0)
      {
      }

      // tServiceWithMaxAndModify_pskel
      //

      void tServiceWithMaxAndModify_pskel::
      modify_parser (::xml_schema::boolean_pskel& p)
      {
        this->modify_parser_ = &p;
      }

      void tServiceWithMaxAndModify_pskel::
      parsers (::xml_schema::unsigned_int_pskel& max,
               ::xml_schema::boolean_pskel& modify)
      {
        this->max_parser_ = &max;
        this->modify_parser_ = &modify;
      }

      tServiceWithMaxAndModify_pskel::
      tServiceWithMaxAndModify_pskel ()
      : modify_parser_ (0)
      {
      }

      // tServiceWithMaxAndMaxAttributesAndModify_pskel
      //

      void tServiceWithMaxAndMaxAttributesAndModify_pskel::
      modify_parser (::xml_schema::boolean_pskel& p)
      {
        this->modify_parser_ = &p;
      }

      void tServiceWithMaxAndMaxAttributesAndModify_pskel::
      parsers (::xml_schema::unsigned_int_pskel& max,
               ::xml_schema::unsigned_int_pskel& maxAttributes,
               ::xml_schema::boolean_pskel& modify)
      {
        this->max_parser_ = &max;
        this->maxAttributes_parser_ = &maxAttributes;
        this->modify_parser_ = &modify;
      }

      tServiceWithMaxAndMaxAttributesAndModify_pskel::
      tServiceWithMaxAndMaxAttributesAndModify_pskel ()
      : modify_parser_ (0)
      {
      }

      // tClientServices_pskel
      //

      void tClientServices_pskel::
      goose_parser (::xml_schema::boolean_pskel& p)
      {
        this->goose_parser_ = &p;
      }

      void tClientServices_pskel::
      gsse_parser (::xml_schema::boolean_pskel& p)
      {
        this->gsse_parser_ = &p;
      }

      void tClientServices_pskel::
      bufReport_parser (::xml_schema::boolean_pskel& p)
      {
        this->bufReport_parser_ = &p;
      }

      void tClientServices_pskel::
      unbufReport_parser (::xml_schema::boolean_pskel& p)
      {
        this->unbufReport_parser_ = &p;
      }

      void tClientServices_pskel::
      readLog_parser (::xml_schema::boolean_pskel& p)
      {
        this->readLog_parser_ = &p;
      }

      void tClientServices_pskel::
      parsers (::xml_schema::boolean_pskel& goose,
               ::xml_schema::boolean_pskel& gsse,
               ::xml_schema::boolean_pskel& bufReport,
               ::xml_schema::boolean_pskel& unbufReport,
               ::xml_schema::boolean_pskel& readLog)
      {
        this->goose_parser_ = &goose;
        this->gsse_parser_ = &gsse;
        this->bufReport_parser_ = &bufReport;
        this->unbufReport_parser_ = &unbufReport;
        this->readLog_parser_ = &readLog;
      }

      tClientServices_pskel::
      tClientServices_pskel ()
      : goose_parser_ (0),
        gsse_parser_ (0),
        bufReport_parser_ (0),
        unbufReport_parser_ (0),
        readLog_parser_ (0)
      {
      }

      // tServiceSettings_pskel
      //

      void tServiceSettings_pskel::
      cbName_parser (::IEC61850::SCL::Validation::tServiceSettingsEnum_pskel& p)
      {
        this->cbName_parser_ = &p;
      }

      void tServiceSettings_pskel::
      datSet_parser (::IEC61850::SCL::Validation::tServiceSettingsEnum_pskel& p)
      {
        this->datSet_parser_ = &p;
      }

      void tServiceSettings_pskel::
      parsers (::IEC61850::SCL::Validation::tServiceSettingsEnum_pskel& cbName,
               ::IEC61850::SCL::Validation::tServiceSettingsEnum_pskel& datSet)
      {
        this->cbName_parser_ = &cbName;
        this->datSet_parser_ = &datSet;
      }

      tServiceSettings_pskel::
      tServiceSettings_pskel ()
      : cbName_parser_ (0),
        datSet_parser_ (0)
      {
      }

      // tReportSettings_pskel
      //

      void tReportSettings_pskel::
      rptID_parser (::IEC61850::SCL::Validation::tServiceSettingsEnum_pskel& p)
      {
        this->rptID_parser_ = &p;
      }

      void tReportSettings_pskel::
      optFields_parser (::IEC61850::SCL::Validation::tServiceSettingsEnum_pskel& p)
      {
        this->optFields_parser_ = &p;
      }

      void tReportSettings_pskel::
      bufTime_parser (::IEC61850::SCL::Validation::tServiceSettingsEnum_pskel& p)
      {
        this->bufTime_parser_ = &p;
      }

      void tReportSettings_pskel::
      trgOps_parser (::IEC61850::SCL::Validation::tServiceSettingsEnum_pskel& p)
      {
        this->trgOps_parser_ = &p;
      }

      void tReportSettings_pskel::
      intgPd_parser (::IEC61850::SCL::Validation::tServiceSettingsEnum_pskel& p)
      {
        this->intgPd_parser_ = &p;
      }

      void tReportSettings_pskel::
      parsers (::IEC61850::SCL::Validation::tServiceSettingsEnum_pskel& cbName,
               ::IEC61850::SCL::Validation::tServiceSettingsEnum_pskel& datSet,
               ::IEC61850::SCL::Validation::tServiceSettingsEnum_pskel& rptID,
               ::IEC61850::SCL::Validation::tServiceSettingsEnum_pskel& optFields,
               ::IEC61850::SCL::Validation::tServiceSettingsEnum_pskel& bufTime,
               ::IEC61850::SCL::Validation::tServiceSettingsEnum_pskel& trgOps,
               ::IEC61850::SCL::Validation::tServiceSettingsEnum_pskel& intgPd)
      {
        this->cbName_parser_ = &cbName;
        this->datSet_parser_ = &datSet;
        this->rptID_parser_ = &rptID;
        this->optFields_parser_ = &optFields;
        this->bufTime_parser_ = &bufTime;
        this->trgOps_parser_ = &trgOps;
        this->intgPd_parser_ = &intgPd;
      }

      tReportSettings_pskel::
      tReportSettings_pskel ()
      : rptID_parser_ (0),
        optFields_parser_ (0),
        bufTime_parser_ (0),
        trgOps_parser_ (0),
        intgPd_parser_ (0)
      {
      }

      // tLogSettings_pskel
      //

      void tLogSettings_pskel::
      logEna_parser (::IEC61850::SCL::Validation::tServiceSettingsEnum_pskel& p)
      {
        this->logEna_parser_ = &p;
      }

      void tLogSettings_pskel::
      trgOps_parser (::IEC61850::SCL::Validation::tServiceSettingsEnum_pskel& p)
      {
        this->trgOps_parser_ = &p;
      }

      void tLogSettings_pskel::
      intgPd_parser (::IEC61850::SCL::Validation::tServiceSettingsEnum_pskel& p)
      {
        this->intgPd_parser_ = &p;
      }

      void tLogSettings_pskel::
      parsers (::IEC61850::SCL::Validation::tServiceSettingsEnum_pskel& cbName,
               ::IEC61850::SCL::Validation::tServiceSettingsEnum_pskel& datSet,
               ::IEC61850::SCL::Validation::tServiceSettingsEnum_pskel& logEna,
               ::IEC61850::SCL::Validation::tServiceSettingsEnum_pskel& trgOps,
               ::IEC61850::SCL::Validation::tServiceSettingsEnum_pskel& intgPd)
      {
        this->cbName_parser_ = &cbName;
        this->datSet_parser_ = &datSet;
        this->logEna_parser_ = &logEna;
        this->trgOps_parser_ = &trgOps;
        this->intgPd_parser_ = &intgPd;
      }

      tLogSettings_pskel::
      tLogSettings_pskel ()
      : logEna_parser_ (0),
        trgOps_parser_ (0),
        intgPd_parser_ (0)
      {
      }

      // tGSESettings_pskel
      //

      void tGSESettings_pskel::
      appID_parser (::IEC61850::SCL::Validation::tServiceSettingsEnum_pskel& p)
      {
        this->appID_parser_ = &p;
      }

      void tGSESettings_pskel::
      dataLabel_parser (::IEC61850::SCL::Validation::tServiceSettingsEnum_pskel& p)
      {
        this->dataLabel_parser_ = &p;
      }

      void tGSESettings_pskel::
      parsers (::IEC61850::SCL::Validation::tServiceSettingsEnum_pskel& cbName,
               ::IEC61850::SCL::Validation::tServiceSettingsEnum_pskel& datSet,
               ::IEC61850::SCL::Validation::tServiceSettingsEnum_pskel& appID,
               ::IEC61850::SCL::Validation::tServiceSettingsEnum_pskel& dataLabel)
      {
        this->cbName_parser_ = &cbName;
        this->datSet_parser_ = &datSet;
        this->appID_parser_ = &appID;
        this->dataLabel_parser_ = &dataLabel;
      }

      tGSESettings_pskel::
      tGSESettings_pskel ()
      : appID_parser_ (0),
        dataLabel_parser_ (0)
      {
      }

      // tSMVSettings_pskel
      //

      void tSMVSettings_pskel::
      SmpRate_parser (::IEC61850::SCL::Validation::SmpRate_pskel& p)
      {
        this->SmpRate_parser_ = &p;
      }

      void tSMVSettings_pskel::
      svID_parser (::IEC61850::SCL::Validation::tServiceSettingsEnum_pskel& p)
      {
        this->svID_parser_ = &p;
      }

      void tSMVSettings_pskel::
      optFields_parser (::IEC61850::SCL::Validation::tServiceSettingsEnum_pskel& p)
      {
        this->optFields_parser_ = &p;
      }

      void tSMVSettings_pskel::
      smpRate_parser (::IEC61850::SCL::Validation::tServiceSettingsEnum_pskel& p)
      {
        this->smpRate_parser_ = &p;
      }

      void tSMVSettings_pskel::
      parsers (::IEC61850::SCL::Validation::tServiceSettingsEnum_pskel& cbName,
               ::IEC61850::SCL::Validation::tServiceSettingsEnum_pskel& datSet,
               ::IEC61850::SCL::Validation::SmpRate_pskel& SmpRate,
               ::IEC61850::SCL::Validation::tServiceSettingsEnum_pskel& svID,
               ::IEC61850::SCL::Validation::tServiceSettingsEnum_pskel& optFields,
               ::IEC61850::SCL::Validation::tServiceSettingsEnum_pskel& smpRate)
      {
        this->cbName_parser_ = &cbName;
        this->datSet_parser_ = &datSet;
        this->SmpRate_parser_ = &SmpRate;
        this->svID_parser_ = &svID;
        this->optFields_parser_ = &optFields;
        this->smpRate_parser_ = &smpRate;
      }

      tSMVSettings_pskel::
      tSMVSettings_pskel ()
      : SmpRate_parser_ (0),
        svID_parser_ (0),
        optFields_parser_ (0),
        smpRate_parser_ (0),
        v_state_stack_ (sizeof (v_state_), &v_state_first_)
      {
      }

      // tConfLNs_pskel
      //

      void tConfLNs_pskel::
      fixPrefix_parser (::xml_schema::boolean_pskel& p)
      {
        this->fixPrefix_parser_ = &p;
      }

      void tConfLNs_pskel::
      fixLnInst_parser (::xml_schema::boolean_pskel& p)
      {
        this->fixLnInst_parser_ = &p;
      }

      void tConfLNs_pskel::
      parsers (::xml_schema::boolean_pskel& fixPrefix,
               ::xml_schema::boolean_pskel& fixLnInst)
      {
        this->fixPrefix_parser_ = &fixPrefix;
        this->fixLnInst_parser_ = &fixLnInst;
      }

      tConfLNs_pskel::
      tConfLNs_pskel ()
      : fixPrefix_parser_ (0),
        fixLnInst_parser_ (0)
      {
      }

      // SettingGroups_pskel
      //

      void SettingGroups_pskel::
      SGEdit_parser (::IEC61850::SCL::Validation::tServiceYesNo_pskel& p)
      {
        this->SGEdit_parser_ = &p;
      }

      void SettingGroups_pskel::
      ConfSG_parser (::IEC61850::SCL::Validation::tServiceYesNo_pskel& p)
      {
        this->ConfSG_parser_ = &p;
      }

      void SettingGroups_pskel::
      parsers (::IEC61850::SCL::Validation::tServiceYesNo_pskel& SGEdit,
               ::IEC61850::SCL::Validation::tServiceYesNo_pskel& ConfSG)
      {
        this->SGEdit_parser_ = &SGEdit;
        this->ConfSG_parser_ = &ConfSG;
      }

      SettingGroups_pskel::
      SettingGroups_pskel ()
      : SGEdit_parser_ (0),
        ConfSG_parser_ (0),
        v_state_stack_ (sizeof (v_state_), &v_state_first_),
        v_all_count_ (2UL, v_all_first_)
      {
      }

      // Authentication_pskel
      //

      void Authentication_pskel::
      none_parser (::xml_schema::boolean_pskel& p)
      {
        this->none_parser_ = &p;
      }

      void Authentication_pskel::
      password_parser (::xml_schema::boolean_pskel& p)
      {
        this->password_parser_ = &p;
      }

      void Authentication_pskel::
      weak_parser (::xml_schema::boolean_pskel& p)
      {
        this->weak_parser_ = &p;
      }

      void Authentication_pskel::
      strong_parser (::xml_schema::boolean_pskel& p)
      {
        this->strong_parser_ = &p;
      }

      void Authentication_pskel::
      certificate_parser (::xml_schema::boolean_pskel& p)
      {
        this->certificate_parser_ = &p;
      }

      void Authentication_pskel::
      parsers (::xml_schema::boolean_pskel& none,
               ::xml_schema::boolean_pskel& password,
               ::xml_schema::boolean_pskel& weak,
               ::xml_schema::boolean_pskel& strong,
               ::xml_schema::boolean_pskel& certificate)
      {
        this->none_parser_ = &none;
        this->password_parser_ = &password;
        this->weak_parser_ = &weak;
        this->strong_parser_ = &strong;
        this->certificate_parser_ = &certificate;
      }

      Authentication_pskel::
      Authentication_pskel ()
      : none_parser_ (0),
        password_parser_ (0),
        weak_parser_ (0),
        strong_parser_ (0),
        certificate_parser_ (0)
      {
      }

      // OptFields_pskel
      //

      void OptFields_pskel::
      seqNum_parser (::xml_schema::boolean_pskel& p)
      {
        this->seqNum_parser_ = &p;
      }

      void OptFields_pskel::
      timeStamp_parser (::xml_schema::boolean_pskel& p)
      {
        this->timeStamp_parser_ = &p;
      }

      void OptFields_pskel::
      dataSet_parser (::xml_schema::boolean_pskel& p)
      {
        this->dataSet_parser_ = &p;
      }

      void OptFields_pskel::
      reasonCode_parser (::xml_schema::boolean_pskel& p)
      {
        this->reasonCode_parser_ = &p;
      }

      void OptFields_pskel::
      dataRef_parser (::xml_schema::boolean_pskel& p)
      {
        this->dataRef_parser_ = &p;
      }

      void OptFields_pskel::
      entryID_parser (::xml_schema::boolean_pskel& p)
      {
        this->entryID_parser_ = &p;
      }

      void OptFields_pskel::
      configRef_parser (::xml_schema::boolean_pskel& p)
      {
        this->configRef_parser_ = &p;
      }

      void OptFields_pskel::
      parsers (::xml_schema::boolean_pskel& seqNum,
               ::xml_schema::boolean_pskel& timeStamp,
               ::xml_schema::boolean_pskel& dataSet,
               ::xml_schema::boolean_pskel& reasonCode,
               ::xml_schema::boolean_pskel& dataRef,
               ::xml_schema::boolean_pskel& entryID,
               ::xml_schema::boolean_pskel& configRef)
      {
        this->seqNum_parser_ = &seqNum;
        this->timeStamp_parser_ = &timeStamp;
        this->dataSet_parser_ = &dataSet;
        this->reasonCode_parser_ = &reasonCode;
        this->dataRef_parser_ = &dataRef;
        this->entryID_parser_ = &entryID;
        this->configRef_parser_ = &configRef;
      }

      OptFields_pskel::
      OptFields_pskel ()
      : seqNum_parser_ (0),
        timeStamp_parser_ (0),
        dataSet_parser_ (0),
        reasonCode_parser_ (0),
        dataRef_parser_ (0),
        entryID_parser_ (0),
        configRef_parser_ (0)
      {
      }

      // SmvOpts_pskel
      //

      void SmvOpts_pskel::
      refreshTime_parser (::xml_schema::boolean_pskel& p)
      {
        this->refreshTime_parser_ = &p;
      }

      void SmvOpts_pskel::
      sampleSynchronized_parser (::xml_schema::boolean_pskel& p)
      {
        this->sampleSynchronized_parser_ = &p;
      }

      void SmvOpts_pskel::
      sampleRate_parser (::xml_schema::boolean_pskel& p)
      {
        this->sampleRate_parser_ = &p;
      }

      void SmvOpts_pskel::
      dataSet_parser (::xml_schema::boolean_pskel& p)
      {
        this->dataSet_parser_ = &p;
      }

      void SmvOpts_pskel::
      security_parser (::xml_schema::boolean_pskel& p)
      {
        this->security_parser_ = &p;
      }

      void SmvOpts_pskel::
      parsers (::xml_schema::boolean_pskel& refreshTime,
               ::xml_schema::boolean_pskel& sampleSynchronized,
               ::xml_schema::boolean_pskel& sampleRate,
               ::xml_schema::boolean_pskel& dataSet,
               ::xml_schema::boolean_pskel& security)
      {
        this->refreshTime_parser_ = &refreshTime;
        this->sampleSynchronized_parser_ = &sampleSynchronized;
        this->sampleRate_parser_ = &sampleRate;
        this->dataSet_parser_ = &dataSet;
        this->security_parser_ = &security;
      }

      SmvOpts_pskel::
      SmvOpts_pskel ()
      : refreshTime_parser_ (0),
        sampleSynchronized_parser_ (0),
        sampleRate_parser_ (0),
        dataSet_parser_ (0),
        security_parser_ (0)
      {
      }
    }
  }
}

namespace IEC61850
{
  namespace SCL
  {
    namespace Validation
    {
      // tIED_pskel
      //

      void tIED_pskel::
      Services ()
      {
      }

      void tIED_pskel::
      AccessPoint ()
      {
      }

      void tIED_pskel::
      type (const ::std::string&)
      {
      }

      void tIED_pskel::
      manufacturer (const ::std::string&)
      {
      }

      void tIED_pskel::
      configVersion (const ::std::string&)
      {
      }

      void tIED_pskel::
      post_tIED ()
      {
        post_tNaming ();
      }

      // tServices_pskel
      //

      void tServices_pskel::
      DynAssociation ()
      {
      }

      void tServices_pskel::
      SettingGroups ()
      {
      }

      void tServices_pskel::
      GetDirectory ()
      {
      }

      void tServices_pskel::
      GetDataObjectDefinition ()
      {
      }

      void tServices_pskel::
      DataObjectDirectory ()
      {
      }

      void tServices_pskel::
      GetDataSetValue ()
      {
      }

      void tServices_pskel::
      SetDataSetValue ()
      {
      }

      void tServices_pskel::
      DataSetDirectory ()
      {
      }

      void tServices_pskel::
      ConfDataSet ()
      {
      }

      void tServices_pskel::
      DynDataSet ()
      {
      }

      void tServices_pskel::
      ReadWrite ()
      {
      }

      void tServices_pskel::
      TimerActivatedControl ()
      {
      }

      void tServices_pskel::
      ConfReportControl ()
      {
      }

      void tServices_pskel::
      GetCBValues ()
      {
      }

      void tServices_pskel::
      ConfLogControl ()
      {
      }

      void tServices_pskel::
      ReportSettings ()
      {
      }

      void tServices_pskel::
      LogSettings ()
      {
      }

      void tServices_pskel::
      GSESettings ()
      {
      }

      void tServices_pskel::
      SMVSettings ()
      {
      }

      void tServices_pskel::
      GSEDir ()
      {
      }

      void tServices_pskel::
      GOOSE ()
      {
      }

      void tServices_pskel::
      GSSE ()
      {
      }

      void tServices_pskel::
      FileHandling ()
      {
      }

      void tServices_pskel::
      ConfLNs ()
      {
      }

      void tServices_pskel::
      ClientServices ()
      {
      }

      void tServices_pskel::
      post_tServices ()
      {
      }

      // tAccessPoint_pskel
      //

      void tAccessPoint_pskel::
      Server ()
      {
      }

      void tAccessPoint_pskel::
      LN ()
      {
      }

      void tAccessPoint_pskel::
      router (bool)
      {
      }

      void tAccessPoint_pskel::
      clock (bool)
      {
      }

      void tAccessPoint_pskel::
      post_tAccessPoint ()
      {
        post_tNaming ();
      }

      // tServer_pskel
      //

      void tServer_pskel::
      Authentication ()
      {
      }

      void tServer_pskel::
      LDevice ()
      {
      }

      void tServer_pskel::
      Association ()
      {
      }

      void tServer_pskel::
      timeout (unsigned int)
      {
      }

      void tServer_pskel::
      post_tServer ()
      {
        post_tUnNaming ();
      }

      // tLDevice_pskel
      //

      void tLDevice_pskel::
      LN0 ()
      {
      }

      void tLDevice_pskel::
      LN ()
      {
      }

      void tLDevice_pskel::
      AccessControl ()
      {
      }

      void tLDevice_pskel::
      inst ()
      {
      }

      void tLDevice_pskel::
      ldName ()
      {
      }

      void tLDevice_pskel::
      post_tLDevice ()
      {
        post_tUnNaming ();
      }

      // tAccessControl_pskel
      //

      void tAccessControl_pskel::
      post_tAccessControl ()
      {
        post_tAnyContentFromOtherNamespace ();
      }

      // tAssociation_pskel
      //

      void tAssociation_pskel::
      kind ()
      {
      }

      void tAssociation_pskel::
      associationID ()
      {
      }

      void tAssociation_pskel::
      iedName ()
      {
      }

      void tAssociation_pskel::
      ldInst ()
      {
      }

      void tAssociation_pskel::
      prefix ()
      {
      }

      void tAssociation_pskel::
      lnClass ()
      {
      }

      void tAssociation_pskel::
      lnInst ()
      {
      }

      void tAssociation_pskel::
      post_tAssociation ()
      {
      }

      // tAnyLN_pskel
      //

      void tAnyLN_pskel::
      DataSet ()
      {
      }

      void tAnyLN_pskel::
      ReportControl ()
      {
      }

      void tAnyLN_pskel::
      LogControl ()
      {
      }

      void tAnyLN_pskel::
      DOI ()
      {
      }

      void tAnyLN_pskel::
      Inputs ()
      {
      }

      void tAnyLN_pskel::
      lnType ()
      {
      }

      void tAnyLN_pskel::
      post_tAnyLN ()
      {
        post_tUnNaming ();
      }

      // tLN_pskel
      //

      void tLN_pskel::
      lnClass ()
      {
      }

      void tLN_pskel::
      inst (unsigned int)
      {
      }

      void tLN_pskel::
      prefix ()
      {
      }

      void tLN_pskel::
      post_tLN ()
      {
        post_tAnyLN ();
      }

      // tLN0_pskel
      //

      void tLN0_pskel::
      GSEControl ()
      {
      }

      void tLN0_pskel::
      SampledValueControl ()
      {
      }

      void tLN0_pskel::
      SettingControl ()
      {
      }

      void tLN0_pskel::
      SCLControl ()
      {
      }

      void tLN0_pskel::
      Log ()
      {
      }

      void tLN0_pskel::
      lnClass ()
      {
      }

      void tLN0_pskel::
      inst (const ::std::string&)
      {
      }

      void tLN0_pskel::
      post_tLN0 ()
      {
        post_tAnyLN ();
      }

      // tDataSet_pskel
      //

      void tDataSet_pskel::
      FCDA ()
      {
      }

      void tDataSet_pskel::
      FCCB ()
      {
      }

      void tDataSet_pskel::
      post_tDataSet ()
      {
        post_tNaming ();
      }

      // tFCDA_pskel
      //

      void tFCDA_pskel::
      ldInst ()
      {
      }

      void tFCDA_pskel::
      prefix ()
      {
      }

      void tFCDA_pskel::
      lnClass ()
      {
      }

      void tFCDA_pskel::
      lnInst ()
      {
      }

      void tFCDA_pskel::
      doName ()
      {
      }

      void tFCDA_pskel::
      daName ()
      {
      }

      void tFCDA_pskel::
      fc ()
      {
      }

      void tFCDA_pskel::
      post_tFCDA ()
      {
      }

      // tFCCB_pskel
      //

      void tFCCB_pskel::
      ldInst ()
      {
      }

      void tFCCB_pskel::
      prefix ()
      {
      }

      void tFCCB_pskel::
      lnClass ()
      {
      }

      void tFCCB_pskel::
      lnInst ()
      {
      }

      void tFCCB_pskel::
      cbName ()
      {
      }

      void tFCCB_pskel::
      daName ()
      {
      }

      void tFCCB_pskel::
      fc ()
      {
      }

      void tFCCB_pskel::
      post_tFCCB ()
      {
      }

      // tControl_pskel
      //

      void tControl_pskel::
      datSet ()
      {
      }

      void tControl_pskel::
      post_tControl ()
      {
        post_tNaming ();
      }

      // tControlWithTriggerOpt_pskel
      //

      void tControlWithTriggerOpt_pskel::
      TrgOps ()
      {
      }

      void tControlWithTriggerOpt_pskel::
      intgPd (unsigned int)
      {
      }

      void tControlWithTriggerOpt_pskel::
      post_tControlWithTriggerOpt ()
      {
        post_tControl ();
      }

      // tTrgOps_pskel
      //

      void tTrgOps_pskel::
      dchg (bool)
      {
      }

      void tTrgOps_pskel::
      qchg (bool)
      {
      }

      void tTrgOps_pskel::
      dupd (bool)
      {
      }

      void tTrgOps_pskel::
      period (bool)
      {
      }

      void tTrgOps_pskel::
      post_tTrgOps ()
      {
      }

      // tReportControl_pskel
      //

      void tReportControl_pskel::
      OptFields ()
      {
      }

      void tReportControl_pskel::
      RptEnabled ()
      {
      }

      void tReportControl_pskel::
      rptID ()
      {
      }

      void tReportControl_pskel::
      confRev (unsigned int)
      {
      }

      void tReportControl_pskel::
      buffered (bool)
      {
      }

      void tReportControl_pskel::
      bufTime (unsigned int)
      {
      }

      void tReportControl_pskel::
      post_tReportControl ()
      {
        post_tControlWithTriggerOpt ();
      }

      // tRptEnabled_pskel
      //

      void tRptEnabled_pskel::
      ClientLN ()
      {
      }

      void tRptEnabled_pskel::
      max (unsigned int)
      {
      }

      void tRptEnabled_pskel::
      post_tRptEnabled ()
      {
        post_tUnNaming ();
      }

      // tClientLN_pskel
      //

      void tClientLN_pskel::
      iedName ()
      {
      }

      void tClientLN_pskel::
      ldInst ()
      {
      }

      void tClientLN_pskel::
      prefix ()
      {
      }

      void tClientLN_pskel::
      lnClass ()
      {
      }

      void tClientLN_pskel::
      lnInst ()
      {
      }

      void tClientLN_pskel::
      post_tClientLN ()
      {
      }

      // tLogControl_pskel
      //

      void tLogControl_pskel::
      logName ()
      {
      }

      void tLogControl_pskel::
      logEna (bool)
      {
      }

      void tLogControl_pskel::
      reasonCode (bool)
      {
      }

      void tLogControl_pskel::
      post_tLogControl ()
      {
        post_tControlWithTriggerOpt ();
      }

      // tInputs_pskel
      //

      void tInputs_pskel::
      ExtRef ()
      {
      }

      void tInputs_pskel::
      post_tInputs ()
      {
        post_tUnNaming ();
      }

      // tExtRef_pskel
      //

      void tExtRef_pskel::
      iedName ()
      {
      }

      void tExtRef_pskel::
      ldInst ()
      {
      }

      void tExtRef_pskel::
      prefix ()
      {
      }

      void tExtRef_pskel::
      lnClass ()
      {
      }

      void tExtRef_pskel::
      lnInst ()
      {
      }

      void tExtRef_pskel::
      doName ()
      {
      }

      void tExtRef_pskel::
      daName ()
      {
      }

      void tExtRef_pskel::
      intAddr (const ::std::string&)
      {
      }

      void tExtRef_pskel::
      post_tExtRef ()
      {
      }

      // tLog_pskel
      //

      void tLog_pskel::
      post_tLog ()
      {
        post_tAnyContentFromOtherNamespace ();
      }

      // tControlWithIEDName_pskel
      //

      void tControlWithIEDName_pskel::
      IEDName ()
      {
      }

      void tControlWithIEDName_pskel::
      confRev (unsigned int)
      {
      }

      void tControlWithIEDName_pskel::
      post_tControlWithIEDName ()
      {
        post_tControl ();
      }

      // tGSEControl_pskel
      //

      void tGSEControl_pskel::
      type ()
      {
      }

      void tGSEControl_pskel::
      appID (const ::std::string&)
      {
      }

      void tGSEControl_pskel::
      post_tGSEControl ()
      {
        post_tControlWithIEDName ();
      }

      // tSampledValueControl_pskel
      //

      void tSampledValueControl_pskel::
      SmvOpts ()
      {
      }

      void tSampledValueControl_pskel::
      smvID (const ::std::string&)
      {
      }

      void tSampledValueControl_pskel::
      multicast (bool)
      {
      }

      void tSampledValueControl_pskel::
      smpRate (unsigned int)
      {
      }

      void tSampledValueControl_pskel::
      nofASDU (unsigned int)
      {
      }

      void tSampledValueControl_pskel::
      post_tSampledValueControl ()
      {
        post_tControlWithIEDName ();
      }

      // tSettingControl_pskel
      //

      void tSettingControl_pskel::
      numOfSGs (unsigned int)
      {
      }

      void tSettingControl_pskel::
      actSG (unsigned int)
      {
      }

      void tSettingControl_pskel::
      post_tSettingControl ()
      {
        post_tUnNaming ();
      }

      // tSCLControl_pskel
      //

      void tSCLControl_pskel::
      post_tSCLControl ()
      {
        post_tUnNaming ();
      }

      // tDOI_pskel
      //

      void tDOI_pskel::
      SDI ()
      {
      }

      void tDOI_pskel::
      DAI ()
      {
      }

      void tDOI_pskel::
      name ()
      {
      }

      void tDOI_pskel::
      ix (unsigned int)
      {
      }

      void tDOI_pskel::
      accessControl (const ::std::string&)
      {
      }

      void tDOI_pskel::
      post_tDOI ()
      {
        post_tUnNaming ();
      }

      // tSDI_pskel
      //

      void tSDI_pskel::
      SDI ()
      {
      }

      void tSDI_pskel::
      DAI ()
      {
      }

      void tSDI_pskel::
      name ()
      {
      }

      void tSDI_pskel::
      ix (unsigned int)
      {
      }

      void tSDI_pskel::
      post_tSDI ()
      {
        post_tUnNaming ();
      }

      // tDAI_pskel
      //

      void tDAI_pskel::
      Val ()
      {
      }

      void tDAI_pskel::
      name ()
      {
      }

      void tDAI_pskel::
      sAddr (const ::std::string&)
      {
      }

      void tDAI_pskel::
      valKind ()
      {
      }

      void tDAI_pskel::
      ix (unsigned int)
      {
      }

      void tDAI_pskel::
      post_tDAI ()
      {
        post_tUnNaming ();
      }

      // tServiceYesNo_pskel
      //

      void tServiceYesNo_pskel::
      post_tServiceYesNo ()
      {
      }

      // tServiceWithMax_pskel
      //

      void tServiceWithMax_pskel::
      max (unsigned int)
      {
      }

      void tServiceWithMax_pskel::
      post_tServiceWithMax ()
      {
      }

      // tServiceWithMaxAndMaxAttributes_pskel
      //

      void tServiceWithMaxAndMaxAttributes_pskel::
      maxAttributes (unsigned int)
      {
      }

      void tServiceWithMaxAndMaxAttributes_pskel::
      post_tServiceWithMaxAndMaxAttributes ()
      {
        post_tServiceWithMax ();
      }

      // tServiceWithMaxAndModify_pskel
      //

      void tServiceWithMaxAndModify_pskel::
      modify (bool)
      {
      }

      void tServiceWithMaxAndModify_pskel::
      post_tServiceWithMaxAndModify ()
      {
        post_tServiceWithMax ();
      }

      // tServiceWithMaxAndMaxAttributesAndModify_pskel
      //

      void tServiceWithMaxAndMaxAttributesAndModify_pskel::
      modify (bool)
      {
      }

      void tServiceWithMaxAndMaxAttributesAndModify_pskel::
      post_tServiceWithMaxAndMaxAttributesAndModify ()
      {
        post_tServiceWithMaxAndMaxAttributes ();
      }

      // tClientServices_pskel
      //

      void tClientServices_pskel::
      goose (bool)
      {
      }

      void tClientServices_pskel::
      gsse (bool)
      {
      }

      void tClientServices_pskel::
      bufReport (bool)
      {
      }

      void tClientServices_pskel::
      unbufReport (bool)
      {
      }

      void tClientServices_pskel::
      readLog (bool)
      {
      }

      void tClientServices_pskel::
      post_tClientServices ()
      {
      }

      // tServiceSettings_pskel
      //

      void tServiceSettings_pskel::
      cbName ()
      {
      }

      void tServiceSettings_pskel::
      datSet ()
      {
      }

      void tServiceSettings_pskel::
      post_tServiceSettings ()
      {
      }

      // tReportSettings_pskel
      //

      void tReportSettings_pskel::
      rptID ()
      {
      }

      void tReportSettings_pskel::
      optFields ()
      {
      }

      void tReportSettings_pskel::
      bufTime ()
      {
      }

      void tReportSettings_pskel::
      trgOps ()
      {
      }

      void tReportSettings_pskel::
      intgPd ()
      {
      }

      void tReportSettings_pskel::
      post_tReportSettings ()
      {
        post_tServiceSettings ();
      }

      // tLogSettings_pskel
      //

      void tLogSettings_pskel::
      logEna ()
      {
      }

      void tLogSettings_pskel::
      trgOps ()
      {
      }

      void tLogSettings_pskel::
      intgPd ()
      {
      }

      void tLogSettings_pskel::
      post_tLogSettings ()
      {
        post_tServiceSettings ();
      }

      // tGSESettings_pskel
      //

      void tGSESettings_pskel::
      appID ()
      {
      }

      void tGSESettings_pskel::
      dataLabel ()
      {
      }

      void tGSESettings_pskel::
      post_tGSESettings ()
      {
        post_tServiceSettings ();
      }

      // tSMVSettings_pskel
      //

      void tSMVSettings_pskel::
      SmpRate ()
      {
      }

      void tSMVSettings_pskel::
      svID ()
      {
      }

      void tSMVSettings_pskel::
      optFields ()
      {
      }

      void tSMVSettings_pskel::
      smpRate ()
      {
      }

      void tSMVSettings_pskel::
      post_tSMVSettings ()
      {
        post_tServiceSettings ();
      }

      // tConfLNs_pskel
      //

      void tConfLNs_pskel::
      fixPrefix (bool)
      {
      }

      void tConfLNs_pskel::
      fixLnInst (bool)
      {
      }

      void tConfLNs_pskel::
      post_tConfLNs ()
      {
      }

      // SettingGroups_pskel
      //

      void SettingGroups_pskel::
      SGEdit ()
      {
      }

      void SettingGroups_pskel::
      ConfSG ()
      {
      }

      void SettingGroups_pskel::
      post_SettingGroups ()
      {
      }

      // Authentication_pskel
      //

      void Authentication_pskel::
      none (bool)
      {
      }

      void Authentication_pskel::
      password (bool)
      {
      }

      void Authentication_pskel::
      weak (bool)
      {
      }

      void Authentication_pskel::
      strong (bool)
      {
      }

      void Authentication_pskel::
      certificate (bool)
      {
      }

      void Authentication_pskel::
      post_Authentication ()
      {
      }

      // LN0_pskel
      //

      void LN0_pskel::
      post_LN0 ()
      {
        post_tLN0 ();
      }

      // OptFields_pskel
      //

      void OptFields_pskel::
      seqNum (bool)
      {
      }

      void OptFields_pskel::
      timeStamp (bool)
      {
      }

      void OptFields_pskel::
      dataSet (bool)
      {
      }

      void OptFields_pskel::
      reasonCode (bool)
      {
      }

      void OptFields_pskel::
      dataRef (bool)
      {
      }

      void OptFields_pskel::
      entryID (bool)
      {
      }

      void OptFields_pskel::
      configRef (bool)
      {
      }

      void OptFields_pskel::
      post_OptFields ()
      {
      }

      // SmvOpts_pskel
      //

      void SmvOpts_pskel::
      refreshTime (bool)
      {
      }

      void SmvOpts_pskel::
      sampleSynchronized (bool)
      {
      }

      void SmvOpts_pskel::
      sampleRate (bool)
      {
      }

      void SmvOpts_pskel::
      dataSet (bool)
      {
      }

      void SmvOpts_pskel::
      security (bool)
      {
      }

      void SmvOpts_pskel::
      post_SmvOpts ()
      {
      }

      // SmpRate_pskel
      //

      void SmpRate_pskel::
      post_SmpRate ()
      {
      }
    }
  }
}

#include <cassert>

namespace IEC61850
{
  namespace SCL
  {
    namespace Validation
    {
      // Element validation and dispatch functions for tIED_pskel.
      //
      bool tIED_pskel::
      _start_element_impl (const ::xml_schema::ro_string& ns,
                           const ::xml_schema::ro_string& n,
                           const ::xml_schema::ro_string* t)
      {
        XSD_UNUSED (t);

        v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
        v_state_descr_* vd = vs.data + (vs.size - 1);

        if (vd->func == 0 && vd->state == 0)
        {
          if (this->::IEC61850::SCL::Validation::tNaming_pskel::_start_element_impl (ns, n, t))
            return true;
          else
            vd->state = 1;
        }

        while (vd->func != 0)
        {
          (this->*vd->func) (vd->state, vd->count, ns, n, t, true);

          vd = vs.data + (vs.size - 1);

          if (vd->state == ~0UL)
            vd = vs.data + (--vs.size - 1);
          else
            break;
        }

        if (vd->func == 0)
        {
          if (vd->state != ~0UL)
          {
            unsigned long s = ~0UL;

            if (n == "Services" &&
                ns == "http://www.iec.ch/61850/2003/SCL")
              s = 0UL;
            else if (n == "AccessPoint" &&
                     ns == "http://www.iec.ch/61850/2003/SCL")
              s = 1UL;

            if (s != ~0UL)
            {
              vd->count++;
              vd->state = ~0UL;

              vd = vs.data + vs.size++;
              vd->func = &tIED_pskel::sequence_0;
              vd->state = s;
              vd->count = 0;

              this->sequence_0 (vd->state, vd->count, ns, n, t, true);
            }
            else
            {
              if (vd->count < 1UL)
                this->_expected_element (
                  "http://www.iec.ch/61850/2003/SCL", "Services",
                  ns, n);
              return false;
            }
          }
          else
            return false;
        }

        return true;
      }

      bool tIED_pskel::
      _end_element_impl (const ::xml_schema::ro_string& ns,
                         const ::xml_schema::ro_string& n)
      {
        v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
        v_state_descr_& vd = vs.data[vs.size - 1];

        if (vd.func == 0 && vd.state == 0)
        {
          if (!::IEC61850::SCL::Validation::tNaming_pskel::_end_element_impl (ns, n))
            assert (false);
          return true;
        }

        assert (vd.func != 0);
        (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

        if (vd.state == ~0UL)
          vs.size--;

        return true;
      }

      void tIED_pskel::
      _pre_e_validate ()
      {
        this->v_state_stack_.push ();
        static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

        v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
        v_state_descr_& vd = vs.data[vs.size++];

        vd.func = 0;
        vd.state = 0;
        vd.count = 0;

        ::IEC61850::SCL::Validation::tNaming_pskel::_pre_e_validate ();
      }

      void tIED_pskel::
      _post_e_validate ()
      {
        ::IEC61850::SCL::Validation::tNaming_pskel::_post_e_validate ();

        v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
        v_state_descr_* vd = vs.data + (vs.size - 1);

        ::xml_schema::ro_string empty;
        while (vd->func != 0)
        {
          (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
          assert (vd->state == ~0UL);
          vd = vs.data + (--vs.size - 1);
        }

        if (vd->count < 1UL)
          this->_expected_element (
            "http://www.iec.ch/61850/2003/SCL", "Services");

        this->v_state_stack_.pop ();
      }

      void tIED_pskel::
      sequence_0 (unsigned long& state,
                  unsigned long& count,
                  const ::xml_schema::ro_string& ns,
                  const ::xml_schema::ro_string& n,
                  const ::xml_schema::ro_string* t,
                  bool start)
      {
        XSD_UNUSED (t);

        switch (state)
        {
          case 0UL:
          {
            if (n == "Services" &&
                ns == "http://www.iec.ch/61850/2003/SCL")
            {
              if (start)
              {
                this->::xml_schema::complex_content::context_.top ().parser_ = this->Services_parser_;

                if (this->Services_parser_)
                  this->Services_parser_->pre ();
              }
              else
              {
                if (this->Services_parser_)
                {
                  this->Services_parser_->post_tServices ();
                  this->Services ();
                }

                count = 0;
                state = 1UL;
              }

              break;
            }
            else
            {
              assert (start);
              count = 0;
              state = 1UL;
              // Fall through.
            }
          }
          case 1UL:
          {
            if (n == "AccessPoint" &&
                ns == "http://www.iec.ch/61850/2003/SCL")
            {
              if (start)
              {
                this->::xml_schema::complex_content::context_.top ().parser_ = this->AccessPoint_parser_;

                if (this->AccessPoint_parser_)
                  this->AccessPoint_parser_->pre ();
              }
              else
              {
                if (this->AccessPoint_parser_)
                {
                  this->AccessPoint_parser_->post_tAccessPoint ();
                  this->AccessPoint ();
                }

                count++;
              }

              break;
            }
            else
            {
              assert (start);
              if (count < 1UL)
                this->_expected_element (
                  "http://www.iec.ch/61850/2003/SCL", "AccessPoint",
                  ns, n);
              count = 0;
              state = ~0UL;
              // Fall through.
            }
          }
          case ~0UL:
            break;
        }
      }

      // Element validation and dispatch functions for tServices_pskel.
      //
      bool tServices_pskel::
      _start_element_impl (const ::xml_schema::ro_string& ns,
                           const ::xml_schema::ro_string& n,
                           const ::xml_schema::ro_string* t)
      {
        XSD_UNUSED (t);

        v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
        v_state_descr_* vd = vs.data + (vs.size - 1);

        all_0 (vd->state, v_all_count_.top (), ns, n, t, true);

        if (vd->state != ~0UL)
          vd->count++;
        else
          return false;

        return true;
      }

      bool tServices_pskel::
      _end_element_impl (const ::xml_schema::ro_string& ns,
                         const ::xml_schema::ro_string& n)
      {
        v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
        v_state_descr_& vd = vs.data[vs.size - 1];

        all_0 (vd.state, v_all_count_.top (), ns, n, 0, false);

        return true;
      }

      void tServices_pskel::
      _pre_e_validate ()
      {
        this->v_state_stack_.push ();
        static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

        v_all_count_.push ();

        v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
        v_state_descr_& vd = vs.data[vs.size++];

        vd.func = 0;
        vd.state = 0;
        vd.count = 0;
      }

      void tServices_pskel::
      _post_e_validate ()
      {
        v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
        v_state_descr_& vd = vs.data[vs.size - 1];

        if (vd.count != 0)
        {
          ::xml_schema::ro_string empty;
          all_0 (vd.state, v_all_count_.top (), empty, empty, 0, true);
        }


        vs.size--;
        v_all_count_.pop ();

        this->v_state_stack_.pop ();
      }

      void tServices_pskel::
      all_0 (unsigned long& state,
             unsigned char* count,
             const ::xml_schema::ro_string& ns,
             const ::xml_schema::ro_string& n,
             const ::xml_schema::ro_string* t,
             bool start)
      {
        XSD_UNUSED (t);

        if (n == "DynAssociation" &&
            ns == "http://www.iec.ch/61850/2003/SCL")
        {
          if (count[0UL] == 0)
          {
            if (start)
            {
              this->::xml_schema::complex_content::context_.top ().parser_ = this->DynAssociation_parser_;

              if (this->DynAssociation_parser_)
                this->DynAssociation_parser_->pre ();
            }
            else
            {
              if (this->DynAssociation_parser_)
              {
                this->DynAssociation_parser_->post_tServiceYesNo ();
                this->DynAssociation ();
              }

              count[0UL] = 1;
            }
          }
          else
          {
            assert (start);
            state = ~0UL;
          }
        }
        else if (n == "SettingGroups" &&
                 ns == "http://www.iec.ch/61850/2003/SCL")
        {
          if (count[1UL] == 0)
          {
            if (start)
            {
              this->::xml_schema::complex_content::context_.top ().parser_ = this->SettingGroups_parser_;

              if (this->SettingGroups_parser_)
                this->SettingGroups_parser_->pre ();
            }
            else
            {
              if (this->SettingGroups_parser_)
              {
                this->SettingGroups_parser_->post_SettingGroups ();
                this->SettingGroups ();
              }

              count[1UL] = 1;
            }
          }
          else
          {
            assert (start);
            state = ~0UL;
          }
        }
        else if (n == "GetDirectory" &&
                 ns == "http://www.iec.ch/61850/2003/SCL")
        {
          if (count[2UL] == 0)
          {
            if (start)
            {
              this->::xml_schema::complex_content::context_.top ().parser_ = this->GetDirectory_parser_;

              if (this->GetDirectory_parser_)
                this->GetDirectory_parser_->pre ();
            }
            else
            {
              if (this->GetDirectory_parser_)
              {
                this->GetDirectory_parser_->post_tServiceYesNo ();
                this->GetDirectory ();
              }

              count[2UL] = 1;
            }
          }
          else
          {
            assert (start);
            state = ~0UL;
          }
        }
        else if (n == "GetDataObjectDefinition" &&
                 ns == "http://www.iec.ch/61850/2003/SCL")
        {
          if (count[3UL] == 0)
          {
            if (start)
            {
              this->::xml_schema::complex_content::context_.top ().parser_ = this->GetDataObjectDefinition_parser_;

              if (this->GetDataObjectDefinition_parser_)
                this->GetDataObjectDefinition_parser_->pre ();
            }
            else
            {
              if (this->GetDataObjectDefinition_parser_)
              {
                this->GetDataObjectDefinition_parser_->post_tServiceYesNo ();
                this->GetDataObjectDefinition ();
              }

              count[3UL] = 1;
            }
          }
          else
          {
            assert (start);
            state = ~0UL;
          }
        }
        else if (n == "DataObjectDirectory" &&
                 ns == "http://www.iec.ch/61850/2003/SCL")
        {
          if (count[4UL] == 0)
          {
            if (start)
            {
              this->::xml_schema::complex_content::context_.top ().parser_ = this->DataObjectDirectory_parser_;

              if (this->DataObjectDirectory_parser_)
                this->DataObjectDirectory_parser_->pre ();
            }
            else
            {
              if (this->DataObjectDirectory_parser_)
              {
                this->DataObjectDirectory_parser_->post_tServiceYesNo ();
                this->DataObjectDirectory ();
              }

              count[4UL] = 1;
            }
          }
          else
          {
            assert (start);
            state = ~0UL;
          }
        }
        else if (n == "GetDataSetValue" &&
                 ns == "http://www.iec.ch/61850/2003/SCL")
        {
          if (count[5UL] == 0)
          {
            if (start)
            {
              this->::xml_schema::complex_content::context_.top ().parser_ = this->GetDataSetValue_parser_;

              if (this->GetDataSetValue_parser_)
                this->GetDataSetValue_parser_->pre ();
            }
            else
            {
              if (this->GetDataSetValue_parser_)
              {
                this->GetDataSetValue_parser_->post_tServiceYesNo ();
                this->GetDataSetValue ();
              }

              count[5UL] = 1;
            }
          }
          else
          {
            assert (start);
            state = ~0UL;
          }
        }
        else if (n == "SetDataSetValue" &&
                 ns == "http://www.iec.ch/61850/2003/SCL")
        {
          if (count[6UL] == 0)
          {
            if (start)
            {
              this->::xml_schema::complex_content::context_.top ().parser_ = this->SetDataSetValue_parser_;

              if (this->SetDataSetValue_parser_)
                this->SetDataSetValue_parser_->pre ();
            }
            else
            {
              if (this->SetDataSetValue_parser_)
              {
                this->SetDataSetValue_parser_->post_tServiceYesNo ();
                this->SetDataSetValue ();
              }

              count[6UL] = 1;
            }
          }
          else
          {
            assert (start);
            state = ~0UL;
          }
        }
        else if (n == "DataSetDirectory" &&
                 ns == "http://www.iec.ch/61850/2003/SCL")
        {
          if (count[7UL] == 0)
          {
            if (start)
            {
              this->::xml_schema::complex_content::context_.top ().parser_ = this->DataSetDirectory_parser_;

              if (this->DataSetDirectory_parser_)
                this->DataSetDirectory_parser_->pre ();
            }
            else
            {
              if (this->DataSetDirectory_parser_)
              {
                this->DataSetDirectory_parser_->post_tServiceYesNo ();
                this->DataSetDirectory ();
              }

              count[7UL] = 1;
            }
          }
          else
          {
            assert (start);
            state = ~0UL;
          }
        }
        else if (n == "ConfDataSet" &&
                 ns == "http://www.iec.ch/61850/2003/SCL")
        {
          if (count[8UL] == 0)
          {
            if (start)
            {
              this->::xml_schema::complex_content::context_.top ().parser_ = this->ConfDataSet_parser_;

              if (this->ConfDataSet_parser_)
                this->ConfDataSet_parser_->pre ();
            }
            else
            {
              if (this->ConfDataSet_parser_)
              {
                this->ConfDataSet_parser_->post_tServiceWithMaxAndMaxAttributesAndModify ();
                this->ConfDataSet ();
              }

              count[8UL] = 1;
            }
          }
          else
          {
            assert (start);
            state = ~0UL;
          }
        }
        else if (n == "DynDataSet" &&
                 ns == "http://www.iec.ch/61850/2003/SCL")
        {
          if (count[9UL] == 0)
          {
            if (start)
            {
              this->::xml_schema::complex_content::context_.top ().parser_ = this->DynDataSet_parser_;

              if (this->DynDataSet_parser_)
                this->DynDataSet_parser_->pre ();
            }
            else
            {
              if (this->DynDataSet_parser_)
              {
                this->DynDataSet_parser_->post_tServiceWithMaxAndMaxAttributes ();
                this->DynDataSet ();
              }

              count[9UL] = 1;
            }
          }
          else
          {
            assert (start);
            state = ~0UL;
          }
        }
        else if (n == "ReadWrite" &&
                 ns == "http://www.iec.ch/61850/2003/SCL")
        {
          if (count[10UL] == 0)
          {
            if (start)
            {
              this->::xml_schema::complex_content::context_.top ().parser_ = this->ReadWrite_parser_;

              if (this->ReadWrite_parser_)
                this->ReadWrite_parser_->pre ();
            }
            else
            {
              if (this->ReadWrite_parser_)
              {
                this->ReadWrite_parser_->post_tServiceYesNo ();
                this->ReadWrite ();
              }

              count[10UL] = 1;
            }
          }
          else
          {
            assert (start);
            state = ~0UL;
          }
        }
        else if (n == "TimerActivatedControl" &&
                 ns == "http://www.iec.ch/61850/2003/SCL")
        {
          if (count[11UL] == 0)
          {
            if (start)
            {
              this->::xml_schema::complex_content::context_.top ().parser_ = this->TimerActivatedControl_parser_;

              if (this->TimerActivatedControl_parser_)
                this->TimerActivatedControl_parser_->pre ();
            }
            else
            {
              if (this->TimerActivatedControl_parser_)
              {
                this->TimerActivatedControl_parser_->post_tServiceYesNo ();
                this->TimerActivatedControl ();
              }

              count[11UL] = 1;
            }
          }
          else
          {
            assert (start);
            state = ~0UL;
          }
        }
        else if (n == "ConfReportControl" &&
                 ns == "http://www.iec.ch/61850/2003/SCL")
        {
          if (count[12UL] == 0)
          {
            if (start)
            {
              this->::xml_schema::complex_content::context_.top ().parser_ = this->ConfReportControl_parser_;

              if (this->ConfReportControl_parser_)
                this->ConfReportControl_parser_->pre ();
            }
            else
            {
              if (this->ConfReportControl_parser_)
              {
                this->ConfReportControl_parser_->post_tServiceWithMax ();
                this->ConfReportControl ();
              }

              count[12UL] = 1;
            }
          }
          else
          {
            assert (start);
            state = ~0UL;
          }
        }
        else if (n == "GetCBValues" &&
                 ns == "http://www.iec.ch/61850/2003/SCL")
        {
          if (count[13UL] == 0)
          {
            if (start)
            {
              this->::xml_schema::complex_content::context_.top ().parser_ = this->GetCBValues_parser_;

              if (this->GetCBValues_parser_)
                this->GetCBValues_parser_->pre ();
            }
            else
            {
              if (this->GetCBValues_parser_)
              {
                this->GetCBValues_parser_->post_tServiceYesNo ();
                this->GetCBValues ();
              }

              count[13UL] = 1;
            }
          }
          else
          {
            assert (start);
            state = ~0UL;
          }
        }
        else if (n == "ConfLogControl" &&
                 ns == "http://www.iec.ch/61850/2003/SCL")
        {
          if (count[14UL] == 0)
          {
            if (start)
            {
              this->::xml_schema::complex_content::context_.top ().parser_ = this->ConfLogControl_parser_;

              if (this->ConfLogControl_parser_)
                this->ConfLogControl_parser_->pre ();
            }
            else
            {
              if (this->ConfLogControl_parser_)
              {
                this->ConfLogControl_parser_->post_tServiceWithMax ();
                this->ConfLogControl ();
              }

              count[14UL] = 1;
            }
          }
          else
          {
            assert (start);
            state = ~0UL;
          }
        }
        else if (n == "ReportSettings" &&
                 ns == "http://www.iec.ch/61850/2003/SCL")
        {
          if (count[15UL] == 0)
          {
            if (start)
            {
              this->::xml_schema::complex_content::context_.top ().parser_ = this->ReportSettings_parser_;

              if (this->ReportSettings_parser_)
                this->ReportSettings_parser_->pre ();
            }
            else
            {
              if (this->ReportSettings_parser_)
              {
                this->ReportSettings_parser_->post_tReportSettings ();
                this->ReportSettings ();
              }

              count[15UL] = 1;
            }
          }
          else
          {
            assert (start);
            state = ~0UL;
          }
        }
        else if (n == "LogSettings" &&
                 ns == "http://www.iec.ch/61850/2003/SCL")
        {
          if (count[16UL] == 0)
          {
            if (start)
            {
              this->::xml_schema::complex_content::context_.top ().parser_ = this->LogSettings_parser_;

              if (this->LogSettings_parser_)
                this->LogSettings_parser_->pre ();
            }
            else
            {
              if (this->LogSettings_parser_)
              {
                this->LogSettings_parser_->post_tLogSettings ();
                this->LogSettings ();
              }

              count[16UL] = 1;
            }
          }
          else
          {
            assert (start);
            state = ~0UL;
          }
        }
        else if (n == "GSESettings" &&
                 ns == "http://www.iec.ch/61850/2003/SCL")
        {
          if (count[17UL] == 0)
          {
            if (start)
            {
              this->::xml_schema::complex_content::context_.top ().parser_ = this->GSESettings_parser_;

              if (this->GSESettings_parser_)
                this->GSESettings_parser_->pre ();
            }
            else
            {
              if (this->GSESettings_parser_)
              {
                this->GSESettings_parser_->post_tGSESettings ();
                this->GSESettings ();
              }

              count[17UL] = 1;
            }
          }
          else
          {
            assert (start);
            state = ~0UL;
          }
        }
        else if (n == "SMVSettings" &&
                 ns == "http://www.iec.ch/61850/2003/SCL")
        {
          if (count[18UL] == 0)
          {
            if (start)
            {
              this->::xml_schema::complex_content::context_.top ().parser_ = this->SMVSettings_parser_;

              if (this->SMVSettings_parser_)
                this->SMVSettings_parser_->pre ();
            }
            else
            {
              if (this->SMVSettings_parser_)
              {
                this->SMVSettings_parser_->post_tSMVSettings ();
                this->SMVSettings ();
              }

              count[18UL] = 1;
            }
          }
          else
          {
            assert (start);
            state = ~0UL;
          }
        }
        else if (n == "GSEDir" &&
                 ns == "http://www.iec.ch/61850/2003/SCL")
        {
          if (count[19UL] == 0)
          {
            if (start)
            {
              this->::xml_schema::complex_content::context_.top ().parser_ = this->GSEDir_parser_;

              if (this->GSEDir_parser_)
                this->GSEDir_parser_->pre ();
            }
            else
            {
              if (this->GSEDir_parser_)
              {
                this->GSEDir_parser_->post_tServiceYesNo ();
                this->GSEDir ();
              }

              count[19UL] = 1;
            }
          }
          else
          {
            assert (start);
            state = ~0UL;
          }
        }
        else if (n == "GOOSE" &&
                 ns == "http://www.iec.ch/61850/2003/SCL")
        {
          if (count[20UL] == 0)
          {
            if (start)
            {
              this->::xml_schema::complex_content::context_.top ().parser_ = this->GOOSE_parser_;

              if (this->GOOSE_parser_)
                this->GOOSE_parser_->pre ();
            }
            else
            {
              if (this->GOOSE_parser_)
              {
                this->GOOSE_parser_->post_tServiceWithMax ();
                this->GOOSE ();
              }

              count[20UL] = 1;
            }
          }
          else
          {
            assert (start);
            state = ~0UL;
          }
        }
        else if (n == "GSSE" &&
                 ns == "http://www.iec.ch/61850/2003/SCL")
        {
          if (count[21UL] == 0)
          {
            if (start)
            {
              this->::xml_schema::complex_content::context_.top ().parser_ = this->GSSE_parser_;

              if (this->GSSE_parser_)
                this->GSSE_parser_->pre ();
            }
            else
            {
              if (this->GSSE_parser_)
              {
                this->GSSE_parser_->post_tServiceWithMax ();
                this->GSSE ();
              }

              count[21UL] = 1;
            }
          }
          else
          {
            assert (start);
            state = ~0UL;
          }
        }
        else if (n == "FileHandling" &&
                 ns == "http://www.iec.ch/61850/2003/SCL")
        {
          if (count[22UL] == 0)
          {
            if (start)
            {
              this->::xml_schema::complex_content::context_.top ().parser_ = this->FileHandling_parser_;

              if (this->FileHandling_parser_)
                this->FileHandling_parser_->pre ();
            }
            else
            {
              if (this->FileHandling_parser_)
              {
                this->FileHandling_parser_->post_tServiceYesNo ();
                this->FileHandling ();
              }

              count[22UL] = 1;
            }
          }
          else
          {
            assert (start);
            state = ~0UL;
          }
        }
        else if (n == "ConfLNs" &&
                 ns == "http://www.iec.ch/61850/2003/SCL")
        {
          if (count[23UL] == 0)
          {
            if (start)
            {
              this->::xml_schema::complex_content::context_.top ().parser_ = this->ConfLNs_parser_;

              if (this->ConfLNs_parser_)
                this->ConfLNs_parser_->pre ();
            }
            else
            {
              if (this->ConfLNs_parser_)
              {
                this->ConfLNs_parser_->post_tConfLNs ();
                this->ConfLNs ();
              }

              count[23UL] = 1;
            }
          }
          else
          {
            assert (start);
            state = ~0UL;
          }
        }
        else if (n == "ClientServices" &&
                 ns == "http://www.iec.ch/61850/2003/SCL")
        {
          if (count[24UL] == 0)
          {
            if (start)
            {
              this->::xml_schema::complex_content::context_.top ().parser_ = this->ClientServices_parser_;

              if (this->ClientServices_parser_)
                this->ClientServices_parser_->pre ();
            }
            else
            {
              if (this->ClientServices_parser_)
              {
                this->ClientServices_parser_->post_tClientServices ();
                this->ClientServices ();
              }

              count[24UL] = 1;
            }
          }
          else
          {
            assert (start);
            state = ~0UL;
          }
        }
        else if (n.empty () && ns.empty ())
        {
          state = ~0UL;
        }
        else
          state = ~0UL;
      }

      // Element validation and dispatch functions for tAccessPoint_pskel.
      //
      bool tAccessPoint_pskel::
      _start_element_impl (const ::xml_schema::ro_string& ns,
                           const ::xml_schema::ro_string& n,
                           const ::xml_schema::ro_string* t)
      {
        XSD_UNUSED (t);

        v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
        v_state_descr_* vd = vs.data + (vs.size - 1);

        if (vd->func == 0 && vd->state == 0)
        {
          if (this->::IEC61850::SCL::Validation::tNaming_pskel::_start_element_impl (ns, n, t))
            return true;
          else
            vd->state = 1;
        }

        while (vd->func != 0)
        {
          (this->*vd->func) (vd->state, vd->count, ns, n, t, true);

          vd = vs.data + (vs.size - 1);

          if (vd->state == ~0UL)
            vd = vs.data + (--vs.size - 1);
          else
            break;
        }

        if (vd->func == 0)
        {
          if (vd->state != ~0UL)
          {
            unsigned long s = ~0UL;

            if (n == "Server" &&
                ns == "http://www.iec.ch/61850/2003/SCL")
              s = 0UL;
            else if (n == "LN" &&
                     ns == "http://www.iec.ch/61850/2003/SCL")
              s = 1UL;

            if (s != ~0UL)
            {
              vd->count++;
              vd->state = ~0UL;

              vd = vs.data + vs.size++;
              vd->func = &tAccessPoint_pskel::choice_0;
              vd->state = s;
              vd->count = 0;

              this->choice_0 (vd->state, vd->count, ns, n, t, true);
            }
            else
            {
              return false;
            }
          }
          else
            return false;
        }

        return true;
      }

      bool tAccessPoint_pskel::
      _end_element_impl (const ::xml_schema::ro_string& ns,
                         const ::xml_schema::ro_string& n)
      {
        v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
        v_state_descr_& vd = vs.data[vs.size - 1];

        if (vd.func == 0 && vd.state == 0)
        {
          if (!::IEC61850::SCL::Validation::tNaming_pskel::_end_element_impl (ns, n))
            assert (false);
          return true;
        }

        assert (vd.func != 0);
        (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

        if (vd.state == ~0UL)
          vs.size--;

        return true;
      }

      void tAccessPoint_pskel::
      _pre_e_validate ()
      {
        this->v_state_stack_.push ();
        static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

        v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
        v_state_descr_& vd = vs.data[vs.size++];

        vd.func = 0;
        vd.state = 0;
        vd.count = 0;

        ::IEC61850::SCL::Validation::tNaming_pskel::_pre_e_validate ();
      }

      void tAccessPoint_pskel::
      _post_e_validate ()
      {
        ::IEC61850::SCL::Validation::tNaming_pskel::_post_e_validate ();

        v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
        v_state_descr_* vd = vs.data + (vs.size - 1);

        ::xml_schema::ro_string empty;
        while (vd->func != 0)
        {
          (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
          assert (vd->state == ~0UL);
          vd = vs.data + (--vs.size - 1);
        }


        this->v_state_stack_.pop ();
      }

      void tAccessPoint_pskel::
      choice_0 (unsigned long& state,
                unsigned long& count,
                const ::xml_schema::ro_string& ns,
                const ::xml_schema::ro_string& n,
                const ::xml_schema::ro_string* t,
                bool start)
      {
        XSD_UNUSED (count);
        XSD_UNUSED (ns);
        XSD_UNUSED (n);
        XSD_UNUSED (t);

        switch (state)
        {
          case 0UL:
          {
            if (start)
            {
              this->::xml_schema::complex_content::context_.top ().parser_ = this->Server_parser_;

              if (this->Server_parser_)
                this->Server_parser_->pre ();
            }
            else
            {
              if (this->Server_parser_)
              {
                this->Server_parser_->post_tServer ();
                this->Server ();
              }

              state = ~0UL;
            }

            break;
          }
          case 1UL:
          {
            if (n == "LN" &&
                ns == "http://www.iec.ch/61850/2003/SCL")
            {
              if (start)
              {
                this->::xml_schema::complex_content::context_.top ().parser_ = this->LN_parser_;

                if (this->LN_parser_)
                  this->LN_parser_->pre ();
              }
              else
              {
                if (this->LN_parser_)
                {
                  this->LN_parser_->post_tLN ();
                  this->LN ();
                }

                count++;
              }
            }
            else
            {
              assert (start);
              state = ~0UL;
            }

            break;
          }
        }
      }

      // Element validation and dispatch functions for tServer_pskel.
      //
      bool tServer_pskel::
      _start_element_impl (const ::xml_schema::ro_string& ns,
                           const ::xml_schema::ro_string& n,
                           const ::xml_schema::ro_string* t)
      {
        XSD_UNUSED (t);

        v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
        v_state_descr_* vd = vs.data + (vs.size - 1);

        if (vd->func == 0 && vd->state == 0)
        {
          if (this->::IEC61850::SCL::Validation::tUnNaming_pskel::_start_element_impl (ns, n, t))
            return true;
          else
            vd->state = 1;
        }

        while (vd->func != 0)
        {
          (this->*vd->func) (vd->state, vd->count, ns, n, t, true);

          vd = vs.data + (vs.size - 1);

          if (vd->state == ~0UL)
            vd = vs.data + (--vs.size - 1);
          else
            break;
        }

        if (vd->func == 0)
        {
          if (vd->state != ~0UL)
          {
            unsigned long s = ~0UL;

            if (n == "Authentication" &&
                ns == "http://www.iec.ch/61850/2003/SCL")
              s = 0UL;

            if (s != ~0UL)
            {
              vd->count++;
              vd->state = ~0UL;

              vd = vs.data + vs.size++;
              vd->func = &tServer_pskel::sequence_0;
              vd->state = s;
              vd->count = 0;

              this->sequence_0 (vd->state, vd->count, ns, n, t, true);
            }
            else
            {
              if (vd->count < 1UL)
                this->_expected_element (
                  "http://www.iec.ch/61850/2003/SCL", "Authentication",
                  ns, n);
              return false;
            }
          }
          else
            return false;
        }

        return true;
      }

      bool tServer_pskel::
      _end_element_impl (const ::xml_schema::ro_string& ns,
                         const ::xml_schema::ro_string& n)
      {
        v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
        v_state_descr_& vd = vs.data[vs.size - 1];

        if (vd.func == 0 && vd.state == 0)
        {
          if (!::IEC61850::SCL::Validation::tUnNaming_pskel::_end_element_impl (ns, n))
            assert (false);
          return true;
        }

        assert (vd.func != 0);
        (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

        if (vd.state == ~0UL)
          vs.size--;

        return true;
      }

      void tServer_pskel::
      _pre_e_validate ()
      {
        this->v_state_stack_.push ();
        static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

        v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
        v_state_descr_& vd = vs.data[vs.size++];

        vd.func = 0;
        vd.state = 0;
        vd.count = 0;

        ::IEC61850::SCL::Validation::tUnNaming_pskel::_pre_e_validate ();
      }

      void tServer_pskel::
      _post_e_validate ()
      {
        ::IEC61850::SCL::Validation::tUnNaming_pskel::_post_e_validate ();

        v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
        v_state_descr_* vd = vs.data + (vs.size - 1);

        ::xml_schema::ro_string empty;
        while (vd->func != 0)
        {
          (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
          assert (vd->state == ~0UL);
          vd = vs.data + (--vs.size - 1);
        }

        if (vd->count < 1UL)
          this->_expected_element (
            "http://www.iec.ch/61850/2003/SCL", "Authentication");

        this->v_state_stack_.pop ();
      }

      void tServer_pskel::
      sequence_0 (unsigned long& state,
                  unsigned long& count,
                  const ::xml_schema::ro_string& ns,
                  const ::xml_schema::ro_string& n,
                  const ::xml_schema::ro_string* t,
                  bool start)
      {
        XSD_UNUSED (t);

        switch (state)
        {
          case 0UL:
          {
            if (n == "Authentication" &&
                ns == "http://www.iec.ch/61850/2003/SCL")
            {
              if (start)
              {
                this->::xml_schema::complex_content::context_.top ().parser_ = this->Authentication_parser_;

                if (this->Authentication_parser_)
                  this->Authentication_parser_->pre ();
              }
              else
              {
                if (this->Authentication_parser_)
                {
                  this->Authentication_parser_->post_Authentication ();
                  this->Authentication ();
                }

                count = 0;
                state = 1UL;
              }

              break;
            }
            else
            {
              assert (start);
              if (count < 1UL)
                this->_expected_element (
                  "http://www.iec.ch/61850/2003/SCL", "Authentication",
                  ns, n);
              count = 0;
              state = 1UL;
              // Fall through.
            }
          }
          case 1UL:
          {
            if (n == "LDevice" &&
                ns == "http://www.iec.ch/61850/2003/SCL")
            {
              if (start)
              {
                this->::xml_schema::complex_content::context_.top ().parser_ = this->LDevice_parser_;

                if (this->LDevice_parser_)
                  this->LDevice_parser_->pre ();
              }
              else
              {
                if (this->LDevice_parser_)
                {
                  this->LDevice_parser_->post_tLDevice ();
                  this->LDevice ();
                }

                count++;
              }

              break;
            }
            else
            {
              assert (start);
              if (count < 1UL)
                this->_expected_element (
                  "http://www.iec.ch/61850/2003/SCL", "LDevice",
                  ns, n);
              count = 0;
              state = 2UL;
              // Fall through.
            }
          }
          case 2UL:
          {
            if (n == "Association" &&
                ns == "http://www.iec.ch/61850/2003/SCL")
            {
              if (start)
              {
                this->::xml_schema::complex_content::context_.top ().parser_ = this->Association_parser_;

                if (this->Association_parser_)
                  this->Association_parser_->pre ();
              }
              else
              {
                if (this->Association_parser_)
                {
                  this->Association_parser_->post_tAssociation ();
                  this->Association ();
                }

                count++;
              }

              break;
            }
            else
            {
              assert (start);
              count = 0;
              state = ~0UL;
              // Fall through.
            }
          }
          case ~0UL:
            break;
        }
      }

      // Element validation and dispatch functions for tLDevice_pskel.
      //
      bool tLDevice_pskel::
      _start_element_impl (const ::xml_schema::ro_string& ns,
                           const ::xml_schema::ro_string& n,
                           const ::xml_schema::ro_string* t)
      {
        XSD_UNUSED (t);

        v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
        v_state_descr_* vd = vs.data + (vs.size - 1);

        if (vd->func == 0 && vd->state == 0)
        {
          if (this->::IEC61850::SCL::Validation::tUnNaming_pskel::_start_element_impl (ns, n, t))
            return true;
          else
            vd->state = 1;
        }

        while (vd->func != 0)
        {
          (this->*vd->func) (vd->state, vd->count, ns, n, t, true);

          vd = vs.data + (vs.size - 1);

          if (vd->state == ~0UL)
            vd = vs.data + (--vs.size - 1);
          else
            break;
        }

        if (vd->func == 0)
        {
          if (vd->state != ~0UL)
          {
            unsigned long s = ~0UL;

            if (n == "LN0" &&
                ns == "http://www.iec.ch/61850/2003/SCL")
              s = 0UL;

            if (s != ~0UL)
            {
              vd->count++;
              vd->state = ~0UL;

              vd = vs.data + vs.size++;
              vd->func = &tLDevice_pskel::sequence_0;
              vd->state = s;
              vd->count = 0;

              this->sequence_0 (vd->state, vd->count, ns, n, t, true);
            }
            else
            {
              if (vd->count < 1UL)
                this->_expected_element (
                  "http://www.iec.ch/61850/2003/SCL", "LN0",
                  ns, n);
              return false;
            }
          }
          else
            return false;
        }

        return true;
      }

      bool tLDevice_pskel::
      _end_element_impl (const ::xml_schema::ro_string& ns,
                         const ::xml_schema::ro_string& n)
      {
        v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
        v_state_descr_& vd = vs.data[vs.size - 1];

        if (vd.func == 0 && vd.state == 0)
        {
          if (!::IEC61850::SCL::Validation::tUnNaming_pskel::_end_element_impl (ns, n))
            assert (false);
          return true;
        }

        assert (vd.func != 0);
        (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

        if (vd.state == ~0UL)
          vs.size--;

        return true;
      }

      void tLDevice_pskel::
      _pre_e_validate ()
      {
        this->v_state_stack_.push ();
        static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

        v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
        v_state_descr_& vd = vs.data[vs.size++];

        vd.func = 0;
        vd.state = 0;
        vd.count = 0;

        ::IEC61850::SCL::Validation::tUnNaming_pskel::_pre_e_validate ();
      }

      void tLDevice_pskel::
      _post_e_validate ()
      {
        ::IEC61850::SCL::Validation::tUnNaming_pskel::_post_e_validate ();

        v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
        v_state_descr_* vd = vs.data + (vs.size - 1);

        ::xml_schema::ro_string empty;
        while (vd->func != 0)
        {
          (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
          assert (vd->state == ~0UL);
          vd = vs.data + (--vs.size - 1);
        }

        if (vd->count < 1UL)
          this->_expected_element (
            "http://www.iec.ch/61850/2003/SCL", "LN0");

        this->v_state_stack_.pop ();
      }

      void tLDevice_pskel::
      sequence_0 (unsigned long& state,
                  unsigned long& count,
                  const ::xml_schema::ro_string& ns,
                  const ::xml_schema::ro_string& n,
                  const ::xml_schema::ro_string* t,
                  bool start)
      {
        XSD_UNUSED (t);

        switch (state)
        {
          case 0UL:
          {
            if (n == "LN0" &&
                ns == "http://www.iec.ch/61850/2003/SCL")
            {
              if (start)
              {
                this->::xml_schema::complex_content::context_.top ().parser_ = this->LN0_parser_;

                if (this->LN0_parser_)
                  this->LN0_parser_->pre ();
              }
              else
              {
                if (this->LN0_parser_)
                {
                  this->LN0_parser_->post_LN0 ();
                  this->LN0 ();
                }

                count = 0;
                state = 1UL;
              }

              break;
            }
            else
            {
              assert (start);
              if (count < 1UL)
                this->_expected_element (
                  "http://www.iec.ch/61850/2003/SCL", "LN0",
                  ns, n);
              count = 0;
              state = 1UL;
              // Fall through.
            }
          }
          case 1UL:
          {
            if (n == "LN" &&
                ns == "http://www.iec.ch/61850/2003/SCL")
            {
              if (start)
              {
                this->::xml_schema::complex_content::context_.top ().parser_ = this->LN_parser_;

                if (this->LN_parser_)
                  this->LN_parser_->pre ();
              }
              else
              {
                if (this->LN_parser_)
                {
                  this->LN_parser_->post_tLN ();
                  this->LN ();
                }

                count++;
              }

              break;
            }
            else
            {
              assert (start);
              count = 0;
              state = 2UL;
              // Fall through.
            }
          }
          case 2UL:
          {
            if (n == "AccessControl" &&
                ns == "http://www.iec.ch/61850/2003/SCL")
            {
              if (start)
              {
                this->::xml_schema::complex_content::context_.top ().parser_ = this->AccessControl_parser_;

                if (this->AccessControl_parser_)
                  this->AccessControl_parser_->pre ();
              }
              else
              {
                if (this->AccessControl_parser_)
                {
                  this->AccessControl_parser_->post_tAccessControl ();
                  this->AccessControl ();
                }

                count = 0;
                state = ~0UL;
              }

              break;
            }
            else
            {
              assert (start);
              count = 0;
              state = ~0UL;
              // Fall through.
            }
          }
          case ~0UL:
            break;
        }
      }

      // Element validation and dispatch functions for tAnyLN_pskel.
      //
      bool tAnyLN_pskel::
      _start_element_impl (const ::xml_schema::ro_string& ns,
                           const ::xml_schema::ro_string& n,
                           const ::xml_schema::ro_string* t)
      {
        XSD_UNUSED (t);

        v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
        v_state_descr_* vd = vs.data + (vs.size - 1);

        if (vd->func == 0 && vd->state == 0)
        {
          if (this->::IEC61850::SCL::Validation::tUnNaming_pskel::_start_element_impl (ns, n, t))
            return true;
          else
            vd->state = 1;
        }

        while (vd->func != 0)
        {
          (this->*vd->func) (vd->state, vd->count, ns, n, t, true);

          vd = vs.data + (vs.size - 1);

          if (vd->state == ~0UL)
            vd = vs.data + (--vs.size - 1);
          else
            break;
        }

        if (vd->func == 0)
        {
          if (vd->state != ~0UL)
          {
            unsigned long s = ~0UL;

            if (n == "DataSet" &&
                ns == "http://www.iec.ch/61850/2003/SCL")
              s = 0UL;
            else if (n == "ReportControl" &&
                     ns == "http://www.iec.ch/61850/2003/SCL")
              s = 1UL;
            else if (n == "LogControl" &&
                     ns == "http://www.iec.ch/61850/2003/SCL")
              s = 2UL;
            else if (n == "DOI" &&
                     ns == "http://www.iec.ch/61850/2003/SCL")
              s = 3UL;
            else if (n == "Inputs" &&
                     ns == "http://www.iec.ch/61850/2003/SCL")
              s = 4UL;

            if (s != ~0UL)
            {
              vd->count++;
              vd->state = ~0UL;

              vd = vs.data + vs.size++;
              vd->func = &tAnyLN_pskel::sequence_0;
              vd->state = s;
              vd->count = 0;

              this->sequence_0 (vd->state, vd->count, ns, n, t, true);
            }
            else
            {
              return false;
            }
          }
          else
            return false;
        }

        return true;
      }

      bool tAnyLN_pskel::
      _end_element_impl (const ::xml_schema::ro_string& ns,
                         const ::xml_schema::ro_string& n)
      {
        v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
        v_state_descr_& vd = vs.data[vs.size - 1];

        if (vd.func == 0 && vd.state == 0)
        {
          if (!::IEC61850::SCL::Validation::tUnNaming_pskel::_end_element_impl (ns, n))
            assert (false);
          return true;
        }

        assert (vd.func != 0);
        (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

        if (vd.state == ~0UL)
          vs.size--;

        return true;
      }

      void tAnyLN_pskel::
      _pre_e_validate ()
      {
        this->v_state_stack_.push ();
        static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

        v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
        v_state_descr_& vd = vs.data[vs.size++];

        vd.func = 0;
        vd.state = 0;
        vd.count = 0;

        ::IEC61850::SCL::Validation::tUnNaming_pskel::_pre_e_validate ();
      }

      void tAnyLN_pskel::
      _post_e_validate ()
      {
        ::IEC61850::SCL::Validation::tUnNaming_pskel::_post_e_validate ();

        v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
        v_state_descr_* vd = vs.data + (vs.size - 1);

        ::xml_schema::ro_string empty;
        while (vd->func != 0)
        {
          (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
          assert (vd->state == ~0UL);
          vd = vs.data + (--vs.size - 1);
        }


        this->v_state_stack_.pop ();
      }

      void tAnyLN_pskel::
      sequence_0 (unsigned long& state,
                  unsigned long& count,
                  const ::xml_schema::ro_string& ns,
                  const ::xml_schema::ro_string& n,
                  const ::xml_schema::ro_string* t,
                  bool start)
      {
        XSD_UNUSED (t);

        switch (state)
        {
          case 0UL:
          {
            if (n == "DataSet" &&
                ns == "http://www.iec.ch/61850/2003/SCL")
            {
              if (start)
              {
                this->::xml_schema::complex_content::context_.top ().parser_ = this->DataSet_parser_;

                if (this->DataSet_parser_)
                  this->DataSet_parser_->pre ();
              }
              else
              {
                if (this->DataSet_parser_)
                {
                  this->DataSet_parser_->post_tDataSet ();
                  this->DataSet ();
                }

                count++;
              }

              break;
            }
            else
            {
              assert (start);
              count = 0;
              state = 1UL;
              // Fall through.
            }
          }
          case 1UL:
          {
            if (n == "ReportControl" &&
                ns == "http://www.iec.ch/61850/2003/SCL")
            {
              if (start)
              {
                this->::xml_schema::complex_content::context_.top ().parser_ = this->ReportControl_parser_;

                if (this->ReportControl_parser_)
                  this->ReportControl_parser_->pre ();
              }
              else
              {
                if (this->ReportControl_parser_)
                {
                  this->ReportControl_parser_->post_tReportControl ();
                  this->ReportControl ();
                }

                count++;
              }

              break;
            }
            else
            {
              assert (start);
              count = 0;
              state = 2UL;
              // Fall through.
            }
          }
          case 2UL:
          {
            if (n == "LogControl" &&
                ns == "http://www.iec.ch/61850/2003/SCL")
            {
              if (start)
              {
                this->::xml_schema::complex_content::context_.top ().parser_ = this->LogControl_parser_;

                if (this->LogControl_parser_)
                  this->LogControl_parser_->pre ();
              }
              else
              {
                if (this->LogControl_parser_)
                {
                  this->LogControl_parser_->post_tLogControl ();
                  this->LogControl ();
                }

                count++;
              }

              break;
            }
            else
            {
              assert (start);
              count = 0;
              state = 3UL;
              // Fall through.
            }
          }
          case 3UL:
          {
            if (n == "DOI" &&
                ns == "http://www.iec.ch/61850/2003/SCL")
            {
              if (start)
              {
                this->::xml_schema::complex_content::context_.top ().parser_ = this->DOI_parser_;

                if (this->DOI_parser_)
                  this->DOI_parser_->pre ();
              }
              else
              {
                if (this->DOI_parser_)
                {
                  this->DOI_parser_->post_tDOI ();
                  this->DOI ();
                }

                count++;
              }

              break;
            }
            else
            {
              assert (start);
              count = 0;
              state = 4UL;
              // Fall through.
            }
          }
          case 4UL:
          {
            if (n == "Inputs" &&
                ns == "http://www.iec.ch/61850/2003/SCL")
            {
              if (start)
              {
                this->::xml_schema::complex_content::context_.top ().parser_ = this->Inputs_parser_;

                if (this->Inputs_parser_)
                  this->Inputs_parser_->pre ();
              }
              else
              {
                if (this->Inputs_parser_)
                {
                  this->Inputs_parser_->post_tInputs ();
                  this->Inputs ();
                }

                count = 0;
                state = ~0UL;
              }

              break;
            }
            else
            {
              assert (start);
              count = 0;
              state = ~0UL;
              // Fall through.
            }
          }
          case ~0UL:
            break;
        }
      }

      // Element validation and dispatch functions for tLN0_pskel.
      //
      bool tLN0_pskel::
      _start_element_impl (const ::xml_schema::ro_string& ns,
                           const ::xml_schema::ro_string& n,
                           const ::xml_schema::ro_string* t)
      {
        XSD_UNUSED (t);

        v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
        v_state_descr_* vd = vs.data + (vs.size - 1);

        if (vd->func == 0 && vd->state == 0)
        {
          if (this->::IEC61850::SCL::Validation::tAnyLN_pskel::_start_element_impl (ns, n, t))
            return true;
          else
            vd->state = 1;
        }

        while (vd->func != 0)
        {
          (this->*vd->func) (vd->state, vd->count, ns, n, t, true);

          vd = vs.data + (vs.size - 1);

          if (vd->state == ~0UL)
            vd = vs.data + (--vs.size - 1);
          else
            break;
        }

        if (vd->func == 0)
        {
          if (vd->state != ~0UL)
          {
            unsigned long s = ~0UL;

            if (n == "GSEControl" &&
                ns == "http://www.iec.ch/61850/2003/SCL")
              s = 0UL;
            else if (n == "SampledValueControl" &&
                     ns == "http://www.iec.ch/61850/2003/SCL")
              s = 1UL;
            else if (n == "SettingControl" &&
                     ns == "http://www.iec.ch/61850/2003/SCL")
              s = 2UL;
            else if (n == "SCLControl" &&
                     ns == "http://www.iec.ch/61850/2003/SCL")
              s = 3UL;
            else if (n == "Log" &&
                     ns == "http://www.iec.ch/61850/2003/SCL")
              s = 4UL;

            if (s != ~0UL)
            {
              vd->count++;
              vd->state = ~0UL;

              vd = vs.data + vs.size++;
              vd->func = &tLN0_pskel::sequence_0;
              vd->state = s;
              vd->count = 0;

              this->sequence_0 (vd->state, vd->count, ns, n, t, true);
            }
            else
            {
              return false;
            }
          }
          else
            return false;
        }

        return true;
      }

      bool tLN0_pskel::
      _end_element_impl (const ::xml_schema::ro_string& ns,
                         const ::xml_schema::ro_string& n)
      {
        v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
        v_state_descr_& vd = vs.data[vs.size - 1];

        if (vd.func == 0 && vd.state == 0)
        {
          if (!::IEC61850::SCL::Validation::tAnyLN_pskel::_end_element_impl (ns, n))
            assert (false);
          return true;
        }

        assert (vd.func != 0);
        (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

        if (vd.state == ~0UL)
          vs.size--;

        return true;
      }

      void tLN0_pskel::
      _pre_e_validate ()
      {
        this->v_state_stack_.push ();
        static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

        v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
        v_state_descr_& vd = vs.data[vs.size++];

        vd.func = 0;
        vd.state = 0;
        vd.count = 0;

        ::IEC61850::SCL::Validation::tAnyLN_pskel::_pre_e_validate ();
      }

      void tLN0_pskel::
      _post_e_validate ()
      {
        ::IEC61850::SCL::Validation::tAnyLN_pskel::_post_e_validate ();

        v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
        v_state_descr_* vd = vs.data + (vs.size - 1);

        ::xml_schema::ro_string empty;
        while (vd->func != 0)
        {
          (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
          assert (vd->state == ~0UL);
          vd = vs.data + (--vs.size - 1);
        }


        this->v_state_stack_.pop ();
      }

      void tLN0_pskel::
      sequence_0 (unsigned long& state,
                  unsigned long& count,
                  const ::xml_schema::ro_string& ns,
                  const ::xml_schema::ro_string& n,
                  const ::xml_schema::ro_string* t,
                  bool start)
      {
        XSD_UNUSED (t);

        switch (state)
        {
          case 0UL:
          {
            if (n == "GSEControl" &&
                ns == "http://www.iec.ch/61850/2003/SCL")
            {
              if (start)
              {
                this->::xml_schema::complex_content::context_.top ().parser_ = this->GSEControl_parser_;

                if (this->GSEControl_parser_)
                  this->GSEControl_parser_->pre ();
              }
              else
              {
                if (this->GSEControl_parser_)
                {
                  this->GSEControl_parser_->post_tGSEControl ();
                  this->GSEControl ();
                }

                count++;
              }

              break;
            }
            else
            {
              assert (start);
              count = 0;
              state = 1UL;
              // Fall through.
            }
          }
          case 1UL:
          {
            if (n == "SampledValueControl" &&
                ns == "http://www.iec.ch/61850/2003/SCL")
            {
              if (start)
              {
                this->::xml_schema::complex_content::context_.top ().parser_ = this->SampledValueControl_parser_;

                if (this->SampledValueControl_parser_)
                  this->SampledValueControl_parser_->pre ();
              }
              else
              {
                if (this->SampledValueControl_parser_)
                {
                  this->SampledValueControl_parser_->post_tSampledValueControl ();
                  this->SampledValueControl ();
                }

                count++;
              }

              break;
            }
            else
            {
              assert (start);
              count = 0;
              state = 2UL;
              // Fall through.
            }
          }
          case 2UL:
          {
            if (n == "SettingControl" &&
                ns == "http://www.iec.ch/61850/2003/SCL")
            {
              if (start)
              {
                this->::xml_schema::complex_content::context_.top ().parser_ = this->SettingControl_parser_;

                if (this->SettingControl_parser_)
                  this->SettingControl_parser_->pre ();
              }
              else
              {
                if (this->SettingControl_parser_)
                {
                  this->SettingControl_parser_->post_tSettingControl ();
                  this->SettingControl ();
                }

                count = 0;
                state = 3UL;
              }

              break;
            }
            else
            {
              assert (start);
              count = 0;
              state = 3UL;
              // Fall through.
            }
          }
          case 3UL:
          {
            if (n == "SCLControl" &&
                ns == "http://www.iec.ch/61850/2003/SCL")
            {
              if (start)
              {
                this->::xml_schema::complex_content::context_.top ().parser_ = this->SCLControl_parser_;

                if (this->SCLControl_parser_)
                  this->SCLControl_parser_->pre ();
              }
              else
              {
                if (this->SCLControl_parser_)
                {
                  this->SCLControl_parser_->post_tSCLControl ();
                  this->SCLControl ();
                }

                count = 0;
                state = 4UL;
              }

              break;
            }
            else
            {
              assert (start);
              count = 0;
              state = 4UL;
              // Fall through.
            }
          }
          case 4UL:
          {
            if (n == "Log" &&
                ns == "http://www.iec.ch/61850/2003/SCL")
            {
              if (start)
              {
                this->::xml_schema::complex_content::context_.top ().parser_ = this->Log_parser_;

                if (this->Log_parser_)
                  this->Log_parser_->pre ();
              }
              else
              {
                if (this->Log_parser_)
                {
                  this->Log_parser_->post_tLog ();
                  this->Log ();
                }

                count = 0;
                state = ~0UL;
              }

              break;
            }
            else
            {
              assert (start);
              count = 0;
              state = ~0UL;
              // Fall through.
            }
          }
          case ~0UL:
            break;
        }
      }

      // Element validation and dispatch functions for tDataSet_pskel.
      //
      bool tDataSet_pskel::
      _start_element_impl (const ::xml_schema::ro_string& ns,
                           const ::xml_schema::ro_string& n,
                           const ::xml_schema::ro_string* t)
      {
        XSD_UNUSED (t);

        v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
        v_state_descr_* vd = vs.data + (vs.size - 1);

        if (vd->func == 0 && vd->state == 0)
        {
          if (this->::IEC61850::SCL::Validation::tNaming_pskel::_start_element_impl (ns, n, t))
            return true;
          else
            vd->state = 1;
        }

        while (vd->func != 0)
        {
          (this->*vd->func) (vd->state, vd->count, ns, n, t, true);

          vd = vs.data + (vs.size - 1);

          if (vd->state == ~0UL)
            vd = vs.data + (--vs.size - 1);
          else
            break;
        }

        if (vd->func == 0)
        {
          if (vd->state != ~0UL)
          {
            unsigned long s = ~0UL;

            if (n == "FCDA" &&
                ns == "http://www.iec.ch/61850/2003/SCL")
              s = 0UL;
            else if (n == "FCCB" &&
                     ns == "http://www.iec.ch/61850/2003/SCL")
              s = 1UL;

            if (s != ~0UL)
            {
              vd->count++;

              vd = vs.data + vs.size++;
              vd->func = &tDataSet_pskel::choice_0;
              vd->state = s;
              vd->count = 0;

              this->choice_0 (vd->state, vd->count, ns, n, t, true);
            }
            else
            {
              if (vd->count < 1UL)
                this->_expected_element (
                  "http://www.iec.ch/61850/2003/SCL", "FCDA",
                  ns, n);
              return false;
            }
          }
          else
            return false;
        }

        return true;
      }

      bool tDataSet_pskel::
      _end_element_impl (const ::xml_schema::ro_string& ns,
                         const ::xml_schema::ro_string& n)
      {
        v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
        v_state_descr_& vd = vs.data[vs.size - 1];

        if (vd.func == 0 && vd.state == 0)
        {
          if (!::IEC61850::SCL::Validation::tNaming_pskel::_end_element_impl (ns, n))
            assert (false);
          return true;
        }

        assert (vd.func != 0);
        (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

        if (vd.state == ~0UL)
          vs.size--;

        return true;
      }

      void tDataSet_pskel::
      _pre_e_validate ()
      {
        this->v_state_stack_.push ();
        static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

        v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
        v_state_descr_& vd = vs.data[vs.size++];

        vd.func = 0;
        vd.state = 0;
        vd.count = 0;

        ::IEC61850::SCL::Validation::tNaming_pskel::_pre_e_validate ();
      }

      void tDataSet_pskel::
      _post_e_validate ()
      {
        ::IEC61850::SCL::Validation::tNaming_pskel::_post_e_validate ();

        v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
        v_state_descr_* vd = vs.data + (vs.size - 1);

        ::xml_schema::ro_string empty;
        while (vd->func != 0)
        {
          (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
          assert (vd->state == ~0UL);
          vd = vs.data + (--vs.size - 1);
        }

        if (vd->count < 1UL)
          this->_expected_element (
            "http://www.iec.ch/61850/2003/SCL", "FCDA");

        this->v_state_stack_.pop ();
      }

      void tDataSet_pskel::
      choice_0 (unsigned long& state,
                unsigned long& count,
                const ::xml_schema::ro_string& ns,
                const ::xml_schema::ro_string& n,
                const ::xml_schema::ro_string* t,
                bool start)
      {
        XSD_UNUSED (count);
        XSD_UNUSED (ns);
        XSD_UNUSED (n);
        XSD_UNUSED (t);

        switch (state)
        {
          case 0UL:
          {
            if (start)
            {
              this->::xml_schema::complex_content::context_.top ().parser_ = this->FCDA_parser_;

              if (this->FCDA_parser_)
                this->FCDA_parser_->pre ();
            }
            else
            {
              if (this->FCDA_parser_)
              {
                this->FCDA_parser_->post_tFCDA ();
                this->FCDA ();
              }

              state = ~0UL;
            }

            break;
          }
          case 1UL:
          {
            if (start)
            {
              this->::xml_schema::complex_content::context_.top ().parser_ = this->FCCB_parser_;

              if (this->FCCB_parser_)
                this->FCCB_parser_->pre ();
            }
            else
            {
              if (this->FCCB_parser_)
              {
                this->FCCB_parser_->post_tFCCB ();
                this->FCCB ();
              }

              state = ~0UL;
            }

            break;
          }
        }
      }

      // Element validation and dispatch functions for tControlWithTriggerOpt_pskel.
      //
      bool tControlWithTriggerOpt_pskel::
      _start_element_impl (const ::xml_schema::ro_string& ns,
                           const ::xml_schema::ro_string& n,
                           const ::xml_schema::ro_string* t)
      {
        XSD_UNUSED (t);

        v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
        v_state_descr_* vd = vs.data + (vs.size - 1);

        if (vd->func == 0 && vd->state == 0)
        {
          if (this->::IEC61850::SCL::Validation::tControl_pskel::_start_element_impl (ns, n, t))
            return true;
          else
            vd->state = 1;
        }

        while (vd->func != 0)
        {
          (this->*vd->func) (vd->state, vd->count, ns, n, t, true);

          vd = vs.data + (vs.size - 1);

          if (vd->state == ~0UL)
            vd = vs.data + (--vs.size - 1);
          else
            break;
        }

        if (vd->func == 0)
        {
          if (vd->state != ~0UL)
          {
            unsigned long s = ~0UL;

            if (n == "TrgOps" &&
                ns == "http://www.iec.ch/61850/2003/SCL")
              s = 0UL;

            if (s != ~0UL)
            {
              vd->count++;
              vd->state = ~0UL;

              vd = vs.data + vs.size++;
              vd->func = &tControlWithTriggerOpt_pskel::sequence_0;
              vd->state = s;
              vd->count = 0;

              this->sequence_0 (vd->state, vd->count, ns, n, t, true);
            }
            else
            {
              return false;
            }
          }
          else
            return false;
        }

        return true;
      }

      bool tControlWithTriggerOpt_pskel::
      _end_element_impl (const ::xml_schema::ro_string& ns,
                         const ::xml_schema::ro_string& n)
      {
        v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
        v_state_descr_& vd = vs.data[vs.size - 1];

        if (vd.func == 0 && vd.state == 0)
        {
          if (!::IEC61850::SCL::Validation::tControl_pskel::_end_element_impl (ns, n))
            assert (false);
          return true;
        }

        assert (vd.func != 0);
        (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

        if (vd.state == ~0UL)
          vs.size--;

        return true;
      }

      void tControlWithTriggerOpt_pskel::
      _pre_e_validate ()
      {
        this->v_state_stack_.push ();
        static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

        v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
        v_state_descr_& vd = vs.data[vs.size++];

        vd.func = 0;
        vd.state = 0;
        vd.count = 0;

        ::IEC61850::SCL::Validation::tControl_pskel::_pre_e_validate ();
      }

      void tControlWithTriggerOpt_pskel::
      _post_e_validate ()
      {
        ::IEC61850::SCL::Validation::tControl_pskel::_post_e_validate ();

        v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
        v_state_descr_* vd = vs.data + (vs.size - 1);

        ::xml_schema::ro_string empty;
        while (vd->func != 0)
        {
          (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
          assert (vd->state == ~0UL);
          vd = vs.data + (--vs.size - 1);
        }


        this->v_state_stack_.pop ();
      }

      void tControlWithTriggerOpt_pskel::
      sequence_0 (unsigned long& state,
                  unsigned long& count,
                  const ::xml_schema::ro_string& ns,
                  const ::xml_schema::ro_string& n,
                  const ::xml_schema::ro_string* t,
                  bool start)
      {
        XSD_UNUSED (t);

        switch (state)
        {
          case 0UL:
          {
            if (n == "TrgOps" &&
                ns == "http://www.iec.ch/61850/2003/SCL")
            {
              if (start)
              {
                this->::xml_schema::complex_content::context_.top ().parser_ = this->TrgOps_parser_;

                if (this->TrgOps_parser_)
                  this->TrgOps_parser_->pre ();
              }
              else
              {
                if (this->TrgOps_parser_)
                {
                  this->TrgOps_parser_->post_tTrgOps ();
                  this->TrgOps ();
                }

                count = 0;
                state = ~0UL;
              }

              break;
            }
            else
            {
              assert (start);
              count = 0;
              state = ~0UL;
              // Fall through.
            }
          }
          case ~0UL:
            break;
        }
      }

      // Element validation and dispatch functions for tReportControl_pskel.
      //
      bool tReportControl_pskel::
      _start_element_impl (const ::xml_schema::ro_string& ns,
                           const ::xml_schema::ro_string& n,
                           const ::xml_schema::ro_string* t)
      {
        XSD_UNUSED (t);

        v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
        v_state_descr_* vd = vs.data + (vs.size - 1);

        if (vd->func == 0 && vd->state == 0)
        {
          if (this->::IEC61850::SCL::Validation::tControlWithTriggerOpt_pskel::_start_element_impl (ns, n, t))
            return true;
          else
            vd->state = 1;
        }

        while (vd->func != 0)
        {
          (this->*vd->func) (vd->state, vd->count, ns, n, t, true);

          vd = vs.data + (vs.size - 1);

          if (vd->state == ~0UL)
            vd = vs.data + (--vs.size - 1);
          else
            break;
        }

        if (vd->func == 0)
        {
          if (vd->state != ~0UL)
          {
            unsigned long s = ~0UL;

            if (n == "OptFields" &&
                ns == "http://www.iec.ch/61850/2003/SCL")
              s = 0UL;

            if (s != ~0UL)
            {
              vd->count++;
              vd->state = ~0UL;

              vd = vs.data + vs.size++;
              vd->func = &tReportControl_pskel::sequence_0;
              vd->state = s;
              vd->count = 0;

              this->sequence_0 (vd->state, vd->count, ns, n, t, true);
            }
            else
            {
              if (vd->count < 1UL)
                this->_expected_element (
                  "http://www.iec.ch/61850/2003/SCL", "OptFields",
                  ns, n);
              return false;
            }
          }
          else
            return false;
        }

        return true;
      }

      bool tReportControl_pskel::
      _end_element_impl (const ::xml_schema::ro_string& ns,
                         const ::xml_schema::ro_string& n)
      {
        v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
        v_state_descr_& vd = vs.data[vs.size - 1];

        if (vd.func == 0 && vd.state == 0)
        {
          if (!::IEC61850::SCL::Validation::tControlWithTriggerOpt_pskel::_end_element_impl (ns, n))
            assert (false);
          return true;
        }

        assert (vd.func != 0);
        (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

        if (vd.state == ~0UL)
          vs.size--;

        return true;
      }

      void tReportControl_pskel::
      _pre_e_validate ()
      {
        this->v_state_stack_.push ();
        static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

        v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
        v_state_descr_& vd = vs.data[vs.size++];

        vd.func = 0;
        vd.state = 0;
        vd.count = 0;

        ::IEC61850::SCL::Validation::tControlWithTriggerOpt_pskel::_pre_e_validate ();
      }

      void tReportControl_pskel::
      _post_e_validate ()
      {
        ::IEC61850::SCL::Validation::tControlWithTriggerOpt_pskel::_post_e_validate ();

        v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
        v_state_descr_* vd = vs.data + (vs.size - 1);

        ::xml_schema::ro_string empty;
        while (vd->func != 0)
        {
          (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
          assert (vd->state == ~0UL);
          vd = vs.data + (--vs.size - 1);
        }

        if (vd->count < 1UL)
          this->_expected_element (
            "http://www.iec.ch/61850/2003/SCL", "OptFields");

        this->v_state_stack_.pop ();
      }

      void tReportControl_pskel::
      sequence_0 (unsigned long& state,
                  unsigned long& count,
                  const ::xml_schema::ro_string& ns,
                  const ::xml_schema::ro_string& n,
                  const ::xml_schema::ro_string* t,
                  bool start)
      {
        XSD_UNUSED (t);

        switch (state)
        {
          case 0UL:
          {
            if (n == "OptFields" &&
                ns == "http://www.iec.ch/61850/2003/SCL")
            {
              if (start)
              {
                this->::xml_schema::complex_content::context_.top ().parser_ = this->OptFields_parser_;

                if (this->OptFields_parser_)
                  this->OptFields_parser_->pre ();
              }
              else
              {
                if (this->OptFields_parser_)
                {
                  this->OptFields_parser_->post_OptFields ();
                  this->OptFields ();
                }

                count = 0;
                state = 1UL;
              }

              break;
            }
            else
            {
              assert (start);
              if (count < 1UL)
                this->_expected_element (
                  "http://www.iec.ch/61850/2003/SCL", "OptFields",
                  ns, n);
              count = 0;
              state = 1UL;
              // Fall through.
            }
          }
          case 1UL:
          {
            if (n == "RptEnabled" &&
                ns == "http://www.iec.ch/61850/2003/SCL")
            {
              if (start)
              {
                this->::xml_schema::complex_content::context_.top ().parser_ = this->RptEnabled_parser_;

                if (this->RptEnabled_parser_)
                  this->RptEnabled_parser_->pre ();
              }
              else
              {
                if (this->RptEnabled_parser_)
                {
                  this->RptEnabled_parser_->post_tRptEnabled ();
                  this->RptEnabled ();
                }

                count = 0;
                state = ~0UL;
              }

              break;
            }
            else
            {
              assert (start);
              count = 0;
              state = ~0UL;
              // Fall through.
            }
          }
          case ~0UL:
            break;
        }
      }

      // Element validation and dispatch functions for tRptEnabled_pskel.
      //
      bool tRptEnabled_pskel::
      _start_element_impl (const ::xml_schema::ro_string& ns,
                           const ::xml_schema::ro_string& n,
                           const ::xml_schema::ro_string* t)
      {
        XSD_UNUSED (t);

        v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
        v_state_descr_* vd = vs.data + (vs.size - 1);

        if (vd->func == 0 && vd->state == 0)
        {
          if (this->::IEC61850::SCL::Validation::tUnNaming_pskel::_start_element_impl (ns, n, t))
            return true;
          else
            vd->state = 1;
        }

        while (vd->func != 0)
        {
          (this->*vd->func) (vd->state, vd->count, ns, n, t, true);

          vd = vs.data + (vs.size - 1);

          if (vd->state == ~0UL)
            vd = vs.data + (--vs.size - 1);
          else
            break;
        }

        if (vd->func == 0)
        {
          if (vd->state != ~0UL)
          {
            unsigned long s = ~0UL;

            if (n == "ClientLN" &&
                ns == "http://www.iec.ch/61850/2003/SCL")
              s = 0UL;

            if (s != ~0UL)
            {
              vd->count++;
              vd->state = ~0UL;

              vd = vs.data + vs.size++;
              vd->func = &tRptEnabled_pskel::sequence_0;
              vd->state = s;
              vd->count = 0;

              this->sequence_0 (vd->state, vd->count, ns, n, t, true);
            }
            else
            {
              return false;
            }
          }
          else
            return false;
        }

        return true;
      }

      bool tRptEnabled_pskel::
      _end_element_impl (const ::xml_schema::ro_string& ns,
                         const ::xml_schema::ro_string& n)
      {
        v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
        v_state_descr_& vd = vs.data[vs.size - 1];

        if (vd.func == 0 && vd.state == 0)
        {
          if (!::IEC61850::SCL::Validation::tUnNaming_pskel::_end_element_impl (ns, n))
            assert (false);
          return true;
        }

        assert (vd.func != 0);
        (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

        if (vd.state == ~0UL)
          vs.size--;

        return true;
      }

      void tRptEnabled_pskel::
      _pre_e_validate ()
      {
        this->v_state_stack_.push ();
        static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

        v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
        v_state_descr_& vd = vs.data[vs.size++];

        vd.func = 0;
        vd.state = 0;
        vd.count = 0;

        ::IEC61850::SCL::Validation::tUnNaming_pskel::_pre_e_validate ();
      }

      void tRptEnabled_pskel::
      _post_e_validate ()
      {
        ::IEC61850::SCL::Validation::tUnNaming_pskel::_post_e_validate ();

        v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
        v_state_descr_* vd = vs.data + (vs.size - 1);

        ::xml_schema::ro_string empty;
        while (vd->func != 0)
        {
          (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
          assert (vd->state == ~0UL);
          vd = vs.data + (--vs.size - 1);
        }


        this->v_state_stack_.pop ();
      }

      void tRptEnabled_pskel::
      sequence_0 (unsigned long& state,
                  unsigned long& count,
                  const ::xml_schema::ro_string& ns,
                  const ::xml_schema::ro_string& n,
                  const ::xml_schema::ro_string* t,
                  bool start)
      {
        XSD_UNUSED (t);

        switch (state)
        {
          case 0UL:
          {
            if (n == "ClientLN" &&
                ns == "http://www.iec.ch/61850/2003/SCL")
            {
              if (start)
              {
                this->::xml_schema::complex_content::context_.top ().parser_ = this->ClientLN_parser_;

                if (this->ClientLN_parser_)
                  this->ClientLN_parser_->pre ();
              }
              else
              {
                if (this->ClientLN_parser_)
                {
                  this->ClientLN_parser_->post_tClientLN ();
                  this->ClientLN ();
                }

                count++;
              }

              break;
            }
            else
            {
              assert (start);
              count = 0;
              state = ~0UL;
              // Fall through.
            }
          }
          case ~0UL:
            break;
        }
      }

      // Element validation and dispatch functions for tInputs_pskel.
      //
      bool tInputs_pskel::
      _start_element_impl (const ::xml_schema::ro_string& ns,
                           const ::xml_schema::ro_string& n,
                           const ::xml_schema::ro_string* t)
      {
        XSD_UNUSED (t);

        v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
        v_state_descr_* vd = vs.data + (vs.size - 1);

        if (vd->func == 0 && vd->state == 0)
        {
          if (this->::IEC61850::SCL::Validation::tUnNaming_pskel::_start_element_impl (ns, n, t))
            return true;
          else
            vd->state = 1;
        }

        while (vd->func != 0)
        {
          (this->*vd->func) (vd->state, vd->count, ns, n, t, true);

          vd = vs.data + (vs.size - 1);

          if (vd->state == ~0UL)
            vd = vs.data + (--vs.size - 1);
          else
            break;
        }

        if (vd->func == 0)
        {
          if (vd->state != ~0UL)
          {
            unsigned long s = ~0UL;

            if (n == "ExtRef" &&
                ns == "http://www.iec.ch/61850/2003/SCL")
              s = 0UL;

            if (s != ~0UL)
            {
              vd->count++;
              vd->state = ~0UL;

              vd = vs.data + vs.size++;
              vd->func = &tInputs_pskel::sequence_0;
              vd->state = s;
              vd->count = 0;

              this->sequence_0 (vd->state, vd->count, ns, n, t, true);
            }
            else
            {
              if (vd->count < 1UL)
                this->_expected_element (
                  "http://www.iec.ch/61850/2003/SCL", "ExtRef",
                  ns, n);
              return false;
            }
          }
          else
            return false;
        }

        return true;
      }

      bool tInputs_pskel::
      _end_element_impl (const ::xml_schema::ro_string& ns,
                         const ::xml_schema::ro_string& n)
      {
        v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
        v_state_descr_& vd = vs.data[vs.size - 1];

        if (vd.func == 0 && vd.state == 0)
        {
          if (!::IEC61850::SCL::Validation::tUnNaming_pskel::_end_element_impl (ns, n))
            assert (false);
          return true;
        }

        assert (vd.func != 0);
        (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

        if (vd.state == ~0UL)
          vs.size--;

        return true;
      }

      void tInputs_pskel::
      _pre_e_validate ()
      {
        this->v_state_stack_.push ();
        static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

        v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
        v_state_descr_& vd = vs.data[vs.size++];

        vd.func = 0;
        vd.state = 0;
        vd.count = 0;

        ::IEC61850::SCL::Validation::tUnNaming_pskel::_pre_e_validate ();
      }

      void tInputs_pskel::
      _post_e_validate ()
      {
        ::IEC61850::SCL::Validation::tUnNaming_pskel::_post_e_validate ();

        v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
        v_state_descr_* vd = vs.data + (vs.size - 1);

        ::xml_schema::ro_string empty;
        while (vd->func != 0)
        {
          (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
          assert (vd->state == ~0UL);
          vd = vs.data + (--vs.size - 1);
        }

        if (vd->count < 1UL)
          this->_expected_element (
            "http://www.iec.ch/61850/2003/SCL", "ExtRef");

        this->v_state_stack_.pop ();
      }

      void tInputs_pskel::
      sequence_0 (unsigned long& state,
                  unsigned long& count,
                  const ::xml_schema::ro_string& ns,
                  const ::xml_schema::ro_string& n,
                  const ::xml_schema::ro_string* t,
                  bool start)
      {
        XSD_UNUSED (t);

        switch (state)
        {
          case 0UL:
          {
            if (n == "ExtRef" &&
                ns == "http://www.iec.ch/61850/2003/SCL")
            {
              if (start)
              {
                this->::xml_schema::complex_content::context_.top ().parser_ = this->ExtRef_parser_;

                if (this->ExtRef_parser_)
                  this->ExtRef_parser_->pre ();
              }
              else
              {
                if (this->ExtRef_parser_)
                {
                  this->ExtRef_parser_->post_tExtRef ();
                  this->ExtRef ();
                }

                count++;
              }

              break;
            }
            else
            {
              assert (start);
              if (count < 1UL)
                this->_expected_element (
                  "http://www.iec.ch/61850/2003/SCL", "ExtRef",
                  ns, n);
              count = 0;
              state = ~0UL;
              // Fall through.
            }
          }
          case ~0UL:
            break;
        }
      }

      // Element validation and dispatch functions for tControlWithIEDName_pskel.
      //
      bool tControlWithIEDName_pskel::
      _start_element_impl (const ::xml_schema::ro_string& ns,
                           const ::xml_schema::ro_string& n,
                           const ::xml_schema::ro_string* t)
      {
        XSD_UNUSED (t);

        v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
        v_state_descr_* vd = vs.data + (vs.size - 1);

        if (vd->func == 0 && vd->state == 0)
        {
          if (this->::IEC61850::SCL::Validation::tControl_pskel::_start_element_impl (ns, n, t))
            return true;
          else
            vd->state = 1;
        }

        while (vd->func != 0)
        {
          (this->*vd->func) (vd->state, vd->count, ns, n, t, true);

          vd = vs.data + (vs.size - 1);

          if (vd->state == ~0UL)
            vd = vs.data + (--vs.size - 1);
          else
            break;
        }

        if (vd->func == 0)
        {
          if (vd->state != ~0UL)
          {
            unsigned long s = ~0UL;

            if (n == "IEDName" &&
                ns == "http://www.iec.ch/61850/2003/SCL")
              s = 0UL;

            if (s != ~0UL)
            {
              vd->count++;
              vd->state = ~0UL;

              vd = vs.data + vs.size++;
              vd->func = &tControlWithIEDName_pskel::sequence_0;
              vd->state = s;
              vd->count = 0;

              this->sequence_0 (vd->state, vd->count, ns, n, t, true);
            }
            else
            {
              return false;
            }
          }
          else
            return false;
        }

        return true;
      }

      bool tControlWithIEDName_pskel::
      _end_element_impl (const ::xml_schema::ro_string& ns,
                         const ::xml_schema::ro_string& n)
      {
        v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
        v_state_descr_& vd = vs.data[vs.size - 1];

        if (vd.func == 0 && vd.state == 0)
        {
          if (!::IEC61850::SCL::Validation::tControl_pskel::_end_element_impl (ns, n))
            assert (false);
          return true;
        }

        assert (vd.func != 0);
        (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

        if (vd.state == ~0UL)
          vs.size--;

        return true;
      }

      void tControlWithIEDName_pskel::
      _pre_e_validate ()
      {
        this->v_state_stack_.push ();
        static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

        v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
        v_state_descr_& vd = vs.data[vs.size++];

        vd.func = 0;
        vd.state = 0;
        vd.count = 0;

        ::IEC61850::SCL::Validation::tControl_pskel::_pre_e_validate ();
      }

      void tControlWithIEDName_pskel::
      _post_e_validate ()
      {
        ::IEC61850::SCL::Validation::tControl_pskel::_post_e_validate ();

        v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
        v_state_descr_* vd = vs.data + (vs.size - 1);

        ::xml_schema::ro_string empty;
        while (vd->func != 0)
        {
          (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
          assert (vd->state == ~0UL);
          vd = vs.data + (--vs.size - 1);
        }


        this->v_state_stack_.pop ();
      }

      void tControlWithIEDName_pskel::
      sequence_0 (unsigned long& state,
                  unsigned long& count,
                  const ::xml_schema::ro_string& ns,
                  const ::xml_schema::ro_string& n,
                  const ::xml_schema::ro_string* t,
                  bool start)
      {
        XSD_UNUSED (t);

        switch (state)
        {
          case 0UL:
          {
            if (n == "IEDName" &&
                ns == "http://www.iec.ch/61850/2003/SCL")
            {
              if (start)
              {
                this->::xml_schema::complex_content::context_.top ().parser_ = this->IEDName_parser_;

                if (this->IEDName_parser_)
                  this->IEDName_parser_->pre ();
              }
              else
              {
                if (this->IEDName_parser_)
                {
                  this->IEDName_parser_->post_tName ();
                  this->IEDName ();
                }

                count++;
              }

              break;
            }
            else
            {
              assert (start);
              count = 0;
              state = ~0UL;
              // Fall through.
            }
          }
          case ~0UL:
            break;
        }
      }

      // Element validation and dispatch functions for tSampledValueControl_pskel.
      //
      bool tSampledValueControl_pskel::
      _start_element_impl (const ::xml_schema::ro_string& ns,
                           const ::xml_schema::ro_string& n,
                           const ::xml_schema::ro_string* t)
      {
        XSD_UNUSED (t);

        v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
        v_state_descr_* vd = vs.data + (vs.size - 1);

        if (vd->func == 0 && vd->state == 0)
        {
          if (this->::IEC61850::SCL::Validation::tControlWithIEDName_pskel::_start_element_impl (ns, n, t))
            return true;
          else
            vd->state = 1;
        }

        while (vd->func != 0)
        {
          (this->*vd->func) (vd->state, vd->count, ns, n, t, true);

          vd = vs.data + (vs.size - 1);

          if (vd->state == ~0UL)
            vd = vs.data + (--vs.size - 1);
          else
            break;
        }

        if (vd->func == 0)
        {
          if (vd->state != ~0UL)
          {
            unsigned long s = ~0UL;

            if (n == "SmvOpts" &&
                ns == "http://www.iec.ch/61850/2003/SCL")
              s = 0UL;

            if (s != ~0UL)
            {
              vd->count++;
              vd->state = ~0UL;

              vd = vs.data + vs.size++;
              vd->func = &tSampledValueControl_pskel::sequence_0;
              vd->state = s;
              vd->count = 0;

              this->sequence_0 (vd->state, vd->count, ns, n, t, true);
            }
            else
            {
              if (vd->count < 1UL)
                this->_expected_element (
                  "http://www.iec.ch/61850/2003/SCL", "SmvOpts",
                  ns, n);
              return false;
            }
          }
          else
            return false;
        }

        return true;
      }

      bool tSampledValueControl_pskel::
      _end_element_impl (const ::xml_schema::ro_string& ns,
                         const ::xml_schema::ro_string& n)
      {
        v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
        v_state_descr_& vd = vs.data[vs.size - 1];

        if (vd.func == 0 && vd.state == 0)
        {
          if (!::IEC61850::SCL::Validation::tControlWithIEDName_pskel::_end_element_impl (ns, n))
            assert (false);
          return true;
        }

        assert (vd.func != 0);
        (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

        if (vd.state == ~0UL)
          vs.size--;

        return true;
      }

      void tSampledValueControl_pskel::
      _pre_e_validate ()
      {
        this->v_state_stack_.push ();
        static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

        v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
        v_state_descr_& vd = vs.data[vs.size++];

        vd.func = 0;
        vd.state = 0;
        vd.count = 0;

        ::IEC61850::SCL::Validation::tControlWithIEDName_pskel::_pre_e_validate ();
      }

      void tSampledValueControl_pskel::
      _post_e_validate ()
      {
        ::IEC61850::SCL::Validation::tControlWithIEDName_pskel::_post_e_validate ();

        v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
        v_state_descr_* vd = vs.data + (vs.size - 1);

        ::xml_schema::ro_string empty;
        while (vd->func != 0)
        {
          (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
          assert (vd->state == ~0UL);
          vd = vs.data + (--vs.size - 1);
        }

        if (vd->count < 1UL)
          this->_expected_element (
            "http://www.iec.ch/61850/2003/SCL", "SmvOpts");

        this->v_state_stack_.pop ();
      }

      void tSampledValueControl_pskel::
      sequence_0 (unsigned long& state,
                  unsigned long& count,
                  const ::xml_schema::ro_string& ns,
                  const ::xml_schema::ro_string& n,
                  const ::xml_schema::ro_string* t,
                  bool start)
      {
        XSD_UNUSED (t);

        switch (state)
        {
          case 0UL:
          {
            if (n == "SmvOpts" &&
                ns == "http://www.iec.ch/61850/2003/SCL")
            {
              if (start)
              {
                this->::xml_schema::complex_content::context_.top ().parser_ = this->SmvOpts_parser_;

                if (this->SmvOpts_parser_)
                  this->SmvOpts_parser_->pre ();
              }
              else
              {
                if (this->SmvOpts_parser_)
                {
                  this->SmvOpts_parser_->post_SmvOpts ();
                  this->SmvOpts ();
                }

                count = 0;
                state = ~0UL;
              }

              break;
            }
            else
            {
              assert (start);
              if (count < 1UL)
                this->_expected_element (
                  "http://www.iec.ch/61850/2003/SCL", "SmvOpts",
                  ns, n);
              count = 0;
              state = ~0UL;
              // Fall through.
            }
          }
          case ~0UL:
            break;
        }
      }

      // Element validation and dispatch functions for tDOI_pskel.
      //
      bool tDOI_pskel::
      _start_element_impl (const ::xml_schema::ro_string& ns,
                           const ::xml_schema::ro_string& n,
                           const ::xml_schema::ro_string* t)
      {
        XSD_UNUSED (t);

        v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
        v_state_descr_* vd = vs.data + (vs.size - 1);

        if (vd->func == 0 && vd->state == 0)
        {
          if (this->::IEC61850::SCL::Validation::tUnNaming_pskel::_start_element_impl (ns, n, t))
            return true;
          else
            vd->state = 1;
        }

        while (vd->func != 0)
        {
          (this->*vd->func) (vd->state, vd->count, ns, n, t, true);

          vd = vs.data + (vs.size - 1);

          if (vd->state == ~0UL)
            vd = vs.data + (--vs.size - 1);
          else
            break;
        }

        if (vd->func == 0)
        {
          if (vd->state != ~0UL)
          {
            unsigned long s = ~0UL;

            if (n == "SDI" &&
                ns == "http://www.iec.ch/61850/2003/SCL")
              s = 0UL;
            else if (n == "DAI" &&
                     ns == "http://www.iec.ch/61850/2003/SCL")
              s = 1UL;

            if (s != ~0UL)
            {
              vd->count++;

              vd = vs.data + vs.size++;
              vd->func = &tDOI_pskel::choice_0;
              vd->state = s;
              vd->count = 0;

              this->choice_0 (vd->state, vd->count, ns, n, t, true);
            }
            else
            {
              return false;
            }
          }
          else
            return false;
        }

        return true;
      }

      bool tDOI_pskel::
      _end_element_impl (const ::xml_schema::ro_string& ns,
                         const ::xml_schema::ro_string& n)
      {
        v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
        v_state_descr_& vd = vs.data[vs.size - 1];

        if (vd.func == 0 && vd.state == 0)
        {
          if (!::IEC61850::SCL::Validation::tUnNaming_pskel::_end_element_impl (ns, n))
            assert (false);
          return true;
        }

        assert (vd.func != 0);
        (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

        if (vd.state == ~0UL)
          vs.size--;

        return true;
      }

      void tDOI_pskel::
      _pre_e_validate ()
      {
        this->v_state_stack_.push ();
        static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

        v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
        v_state_descr_& vd = vs.data[vs.size++];

        vd.func = 0;
        vd.state = 0;
        vd.count = 0;

        ::IEC61850::SCL::Validation::tUnNaming_pskel::_pre_e_validate ();
      }

      void tDOI_pskel::
      _post_e_validate ()
      {
        ::IEC61850::SCL::Validation::tUnNaming_pskel::_post_e_validate ();

        v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
        v_state_descr_* vd = vs.data + (vs.size - 1);

        ::xml_schema::ro_string empty;
        while (vd->func != 0)
        {
          (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
          assert (vd->state == ~0UL);
          vd = vs.data + (--vs.size - 1);
        }


        this->v_state_stack_.pop ();
      }

      void tDOI_pskel::
      choice_0 (unsigned long& state,
                unsigned long& count,
                const ::xml_schema::ro_string& ns,
                const ::xml_schema::ro_string& n,
                const ::xml_schema::ro_string* t,
                bool start)
      {
        XSD_UNUSED (count);
        XSD_UNUSED (ns);
        XSD_UNUSED (n);
        XSD_UNUSED (t);

        switch (state)
        {
          case 0UL:
          {
            if (start)
            {
              this->::xml_schema::complex_content::context_.top ().parser_ = this->SDI_parser_;

              if (this->SDI_parser_)
                this->SDI_parser_->pre ();
            }
            else
            {
              if (this->SDI_parser_)
              {
                this->SDI_parser_->post_tSDI ();
                this->SDI ();
              }

              state = ~0UL;
            }

            break;
          }
          case 1UL:
          {
            if (start)
            {
              this->::xml_schema::complex_content::context_.top ().parser_ = this->DAI_parser_;

              if (this->DAI_parser_)
                this->DAI_parser_->pre ();
            }
            else
            {
              if (this->DAI_parser_)
              {
                this->DAI_parser_->post_tDAI ();
                this->DAI ();
              }

              state = ~0UL;
            }

            break;
          }
        }
      }

      // Element validation and dispatch functions for tSDI_pskel.
      //
      bool tSDI_pskel::
      _start_element_impl (const ::xml_schema::ro_string& ns,
                           const ::xml_schema::ro_string& n,
                           const ::xml_schema::ro_string* t)
      {
        XSD_UNUSED (t);

        v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
        v_state_descr_* vd = vs.data + (vs.size - 1);

        if (vd->func == 0 && vd->state == 0)
        {
          if (this->::IEC61850::SCL::Validation::tUnNaming_pskel::_start_element_impl (ns, n, t))
            return true;
          else
            vd->state = 1;
        }

        while (vd->func != 0)
        {
          (this->*vd->func) (vd->state, vd->count, ns, n, t, true);

          vd = vs.data + (vs.size - 1);

          if (vd->state == ~0UL)
            vd = vs.data + (--vs.size - 1);
          else
            break;
        }

        if (vd->func == 0)
        {
          if (vd->state != ~0UL)
          {
            unsigned long s = ~0UL;

            if (n == "SDI" &&
                ns == "http://www.iec.ch/61850/2003/SCL")
              s = 0UL;
            else if (n == "DAI" &&
                     ns == "http://www.iec.ch/61850/2003/SCL")
              s = 1UL;

            if (s != ~0UL)
            {
              vd->count++;

              vd = vs.data + vs.size++;
              vd->func = &tSDI_pskel::choice_0;
              vd->state = s;
              vd->count = 0;

              this->choice_0 (vd->state, vd->count, ns, n, t, true);
            }
            else
            {
              return false;
            }
          }
          else
            return false;
        }

        return true;
      }

      bool tSDI_pskel::
      _end_element_impl (const ::xml_schema::ro_string& ns,
                         const ::xml_schema::ro_string& n)
      {
        v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
        v_state_descr_& vd = vs.data[vs.size - 1];

        if (vd.func == 0 && vd.state == 0)
        {
          if (!::IEC61850::SCL::Validation::tUnNaming_pskel::_end_element_impl (ns, n))
            assert (false);
          return true;
        }

        assert (vd.func != 0);
        (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

        if (vd.state == ~0UL)
          vs.size--;

        return true;
      }

      void tSDI_pskel::
      _pre_e_validate ()
      {
        this->v_state_stack_.push ();
        static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

        v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
        v_state_descr_& vd = vs.data[vs.size++];

        vd.func = 0;
        vd.state = 0;
        vd.count = 0;

        ::IEC61850::SCL::Validation::tUnNaming_pskel::_pre_e_validate ();
      }

      void tSDI_pskel::
      _post_e_validate ()
      {
        ::IEC61850::SCL::Validation::tUnNaming_pskel::_post_e_validate ();

        v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
        v_state_descr_* vd = vs.data + (vs.size - 1);

        ::xml_schema::ro_string empty;
        while (vd->func != 0)
        {
          (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
          assert (vd->state == ~0UL);
          vd = vs.data + (--vs.size - 1);
        }


        this->v_state_stack_.pop ();
      }

      void tSDI_pskel::
      choice_0 (unsigned long& state,
                unsigned long& count,
                const ::xml_schema::ro_string& ns,
                const ::xml_schema::ro_string& n,
                const ::xml_schema::ro_string* t,
                bool start)
      {
        XSD_UNUSED (count);
        XSD_UNUSED (ns);
        XSD_UNUSED (n);
        XSD_UNUSED (t);

        switch (state)
        {
          case 0UL:
          {
            if (start)
            {
              this->::xml_schema::complex_content::context_.top ().parser_ = this->SDI_parser_;

              if (this->SDI_parser_)
                this->SDI_parser_->pre ();
            }
            else
            {
              if (this->SDI_parser_)
              {
                this->SDI_parser_->post_tSDI ();
                this->SDI ();
              }

              state = ~0UL;
            }

            break;
          }
          case 1UL:
          {
            if (start)
            {
              this->::xml_schema::complex_content::context_.top ().parser_ = this->DAI_parser_;

              if (this->DAI_parser_)
                this->DAI_parser_->pre ();
            }
            else
            {
              if (this->DAI_parser_)
              {
                this->DAI_parser_->post_tDAI ();
                this->DAI ();
              }

              state = ~0UL;
            }

            break;
          }
        }
      }

      // Element validation and dispatch functions for tDAI_pskel.
      //
      bool tDAI_pskel::
      _start_element_impl (const ::xml_schema::ro_string& ns,
                           const ::xml_schema::ro_string& n,
                           const ::xml_schema::ro_string* t)
      {
        XSD_UNUSED (t);

        v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
        v_state_descr_* vd = vs.data + (vs.size - 1);

        if (vd->func == 0 && vd->state == 0)
        {
          if (this->::IEC61850::SCL::Validation::tUnNaming_pskel::_start_element_impl (ns, n, t))
            return true;
          else
            vd->state = 1;
        }

        while (vd->func != 0)
        {
          (this->*vd->func) (vd->state, vd->count, ns, n, t, true);

          vd = vs.data + (vs.size - 1);

          if (vd->state == ~0UL)
            vd = vs.data + (--vs.size - 1);
          else
            break;
        }

        if (vd->func == 0)
        {
          if (vd->state != ~0UL)
          {
            unsigned long s = ~0UL;

            if (n == "Val" &&
                ns == "http://www.iec.ch/61850/2003/SCL")
              s = 0UL;

            if (s != ~0UL)
            {
              vd->count++;
              vd->state = ~0UL;

              vd = vs.data + vs.size++;
              vd->func = &tDAI_pskel::sequence_0;
              vd->state = s;
              vd->count = 0;

              this->sequence_0 (vd->state, vd->count, ns, n, t, true);
            }
            else
            {
              return false;
            }
          }
          else
            return false;
        }

        return true;
      }

      bool tDAI_pskel::
      _end_element_impl (const ::xml_schema::ro_string& ns,
                         const ::xml_schema::ro_string& n)
      {
        v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
        v_state_descr_& vd = vs.data[vs.size - 1];

        if (vd.func == 0 && vd.state == 0)
        {
          if (!::IEC61850::SCL::Validation::tUnNaming_pskel::_end_element_impl (ns, n))
            assert (false);
          return true;
        }

        assert (vd.func != 0);
        (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

        if (vd.state == ~0UL)
          vs.size--;

        return true;
      }

      void tDAI_pskel::
      _pre_e_validate ()
      {
        this->v_state_stack_.push ();
        static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

        v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
        v_state_descr_& vd = vs.data[vs.size++];

        vd.func = 0;
        vd.state = 0;
        vd.count = 0;

        ::IEC61850::SCL::Validation::tUnNaming_pskel::_pre_e_validate ();
      }

      void tDAI_pskel::
      _post_e_validate ()
      {
        ::IEC61850::SCL::Validation::tUnNaming_pskel::_post_e_validate ();

        v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
        v_state_descr_* vd = vs.data + (vs.size - 1);

        ::xml_schema::ro_string empty;
        while (vd->func != 0)
        {
          (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
          assert (vd->state == ~0UL);
          vd = vs.data + (--vs.size - 1);
        }


        this->v_state_stack_.pop ();
      }

      void tDAI_pskel::
      sequence_0 (unsigned long& state,
                  unsigned long& count,
                  const ::xml_schema::ro_string& ns,
                  const ::xml_schema::ro_string& n,
                  const ::xml_schema::ro_string* t,
                  bool start)
      {
        XSD_UNUSED (t);

        switch (state)
        {
          case 0UL:
          {
            if (n == "Val" &&
                ns == "http://www.iec.ch/61850/2003/SCL")
            {
              if (start)
              {
                this->::xml_schema::complex_content::context_.top ().parser_ = this->Val_parser_;

                if (this->Val_parser_)
                  this->Val_parser_->pre ();
              }
              else
              {
                if (this->Val_parser_)
                {
                  this->Val_parser_->post_tVal ();
                  this->Val ();
                }

                count++;
              }

              break;
            }
            else
            {
              assert (start);
              count = 0;
              state = ~0UL;
              // Fall through.
            }
          }
          case ~0UL:
            break;
        }
      }

      // Element validation and dispatch functions for tSMVSettings_pskel.
      //
      bool tSMVSettings_pskel::
      _start_element_impl (const ::xml_schema::ro_string& ns,
                           const ::xml_schema::ro_string& n,
                           const ::xml_schema::ro_string* t)
      {
        XSD_UNUSED (t);

        v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
        v_state_descr_* vd = vs.data + (vs.size - 1);

        if (vd->func == 0 && vd->state == 0)
        {
          if (this->::IEC61850::SCL::Validation::tServiceSettings_pskel::_start_element_impl (ns, n, t))
            return true;
          else
            vd->state = 1;
        }

        while (vd->func != 0)
        {
          (this->*vd->func) (vd->state, vd->count, ns, n, t, true);

          vd = vs.data + (vs.size - 1);

          if (vd->state == ~0UL)
            vd = vs.data + (--vs.size - 1);
          else
            break;
        }

        if (vd->func == 0)
        {
          if (vd->state != ~0UL)
          {
            unsigned long s = ~0UL;

            if (n == "SmpRate" &&
                ns == "http://www.iec.ch/61850/2003/SCL")
              s = 0UL;

            if (s != ~0UL)
            {
              vd->count++;
              vd->state = ~0UL;

              vd = vs.data + vs.size++;
              vd->func = &tSMVSettings_pskel::sequence_0;
              vd->state = s;
              vd->count = 0;

              this->sequence_0 (vd->state, vd->count, ns, n, t, true);
            }
            else
            {
              if (vd->count < 1UL)
                this->_expected_element (
                  "http://www.iec.ch/61850/2003/SCL", "SmpRate",
                  ns, n);
              return false;
            }
          }
          else
            return false;
        }

        return true;
      }

      bool tSMVSettings_pskel::
      _end_element_impl (const ::xml_schema::ro_string& ns,
                         const ::xml_schema::ro_string& n)
      {
        v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
        v_state_descr_& vd = vs.data[vs.size - 1];

        if (vd.func == 0 && vd.state == 0)
        {
          if (!::IEC61850::SCL::Validation::tServiceSettings_pskel::_end_element_impl (ns, n))
            assert (false);
          return true;
        }

        assert (vd.func != 0);
        (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

        if (vd.state == ~0UL)
          vs.size--;

        return true;
      }

      void tSMVSettings_pskel::
      _pre_e_validate ()
      {
        this->v_state_stack_.push ();
        static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

        v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
        v_state_descr_& vd = vs.data[vs.size++];

        vd.func = 0;
        vd.state = 0;
        vd.count = 0;

        ::IEC61850::SCL::Validation::tServiceSettings_pskel::_pre_e_validate ();
      }

      void tSMVSettings_pskel::
      _post_e_validate ()
      {
        ::IEC61850::SCL::Validation::tServiceSettings_pskel::_post_e_validate ();

        v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
        v_state_descr_* vd = vs.data + (vs.size - 1);

        ::xml_schema::ro_string empty;
        while (vd->func != 0)
        {
          (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
          assert (vd->state == ~0UL);
          vd = vs.data + (--vs.size - 1);
        }

        if (vd->count < 1UL)
          this->_expected_element (
            "http://www.iec.ch/61850/2003/SCL", "SmpRate");

        this->v_state_stack_.pop ();
      }

      void tSMVSettings_pskel::
      sequence_0 (unsigned long& state,
                  unsigned long& count,
                  const ::xml_schema::ro_string& ns,
                  const ::xml_schema::ro_string& n,
                  const ::xml_schema::ro_string* t,
                  bool start)
      {
        XSD_UNUSED (t);

        switch (state)
        {
          case 0UL:
          {
            if (n == "SmpRate" &&
                ns == "http://www.iec.ch/61850/2003/SCL")
            {
              if (start)
              {
                this->::xml_schema::complex_content::context_.top ().parser_ = this->SmpRate_parser_;

                if (this->SmpRate_parser_)
                  this->SmpRate_parser_->pre ();
              }
              else
              {
                if (this->SmpRate_parser_)
                {
                  this->SmpRate_parser_->post_SmpRate ();
                  this->SmpRate ();
                }

                count++;
              }

              break;
            }
            else
            {
              assert (start);
              if (count < 1UL)
                this->_expected_element (
                  "http://www.iec.ch/61850/2003/SCL", "SmpRate",
                  ns, n);
              count = 0;
              state = ~0UL;
              // Fall through.
            }
          }
          case ~0UL:
            break;
        }
      }

      // Element validation and dispatch functions for SettingGroups_pskel.
      //
      bool SettingGroups_pskel::
      _start_element_impl (const ::xml_schema::ro_string& ns,
                           const ::xml_schema::ro_string& n,
                           const ::xml_schema::ro_string* t)
      {
        XSD_UNUSED (t);

        v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
        v_state_descr_* vd = vs.data + (vs.size - 1);

        all_0 (vd->state, v_all_count_.top (), ns, n, t, true);

        if (vd->state != ~0UL)
          vd->count++;
        else
          return false;

        return true;
      }

      bool SettingGroups_pskel::
      _end_element_impl (const ::xml_schema::ro_string& ns,
                         const ::xml_schema::ro_string& n)
      {
        v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
        v_state_descr_& vd = vs.data[vs.size - 1];

        all_0 (vd.state, v_all_count_.top (), ns, n, 0, false);

        return true;
      }

      void SettingGroups_pskel::
      _pre_e_validate ()
      {
        this->v_state_stack_.push ();
        static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

        v_all_count_.push ();

        v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
        v_state_descr_& vd = vs.data[vs.size++];

        vd.func = 0;
        vd.state = 0;
        vd.count = 0;
      }

      void SettingGroups_pskel::
      _post_e_validate ()
      {
        v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
        v_state_descr_& vd = vs.data[vs.size - 1];

        if (vd.count != 0)
        {
          ::xml_schema::ro_string empty;
          all_0 (vd.state, v_all_count_.top (), empty, empty, 0, true);
        }


        vs.size--;
        v_all_count_.pop ();

        this->v_state_stack_.pop ();
      }

      void SettingGroups_pskel::
      all_0 (unsigned long& state,
             unsigned char* count,
             const ::xml_schema::ro_string& ns,
             const ::xml_schema::ro_string& n,
             const ::xml_schema::ro_string* t,
             bool start)
      {
        XSD_UNUSED (t);

        if (n == "SGEdit" &&
            ns == "http://www.iec.ch/61850/2003/SCL")
        {
          if (count[0UL] == 0)
          {
            if (start)
            {
              this->::xml_schema::complex_content::context_.top ().parser_ = this->SGEdit_parser_;

              if (this->SGEdit_parser_)
                this->SGEdit_parser_->pre ();
            }
            else
            {
              if (this->SGEdit_parser_)
              {
                this->SGEdit_parser_->post_tServiceYesNo ();
                this->SGEdit ();
              }

              count[0UL] = 1;
            }
          }
          else
          {
            assert (start);
            state = ~0UL;
          }
        }
        else if (n == "ConfSG" &&
                 ns == "http://www.iec.ch/61850/2003/SCL")
        {
          if (count[1UL] == 0)
          {
            if (start)
            {
              this->::xml_schema::complex_content::context_.top ().parser_ = this->ConfSG_parser_;

              if (this->ConfSG_parser_)
                this->ConfSG_parser_->pre ();
            }
            else
            {
              if (this->ConfSG_parser_)
              {
                this->ConfSG_parser_->post_tServiceYesNo ();
                this->ConfSG ();
              }

              count[1UL] = 1;
            }
          }
          else
          {
            assert (start);
            state = ~0UL;
          }
        }
        else if (n.empty () && ns.empty ())
        {
          state = ~0UL;
        }
        else
          state = ~0UL;
      }
    }
  }
}

namespace IEC61850
{
  namespace SCL
  {
    namespace Validation
    {
      // Attribute validation and dispatch functions for tIED_pskel.
      //
      bool tIED_pskel::
      _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
                                 const ::xml_schema::ro_string& n,
                                 const ::xml_schema::ro_string& s)
      {
        if (n == "type" && ns.empty ())
        {
          if (this->type_parser_)
          {
            this->type_parser_->pre ();
            this->type_parser_->_pre_impl ();
            this->type_parser_->_characters (s);
            this->type_parser_->_post_impl ();
            const ::std::string& tmp (this->type_parser_->post_normalized_string ());
            this->type (tmp);
          }

          return true;
        }

        if (n == "manufacturer" && ns.empty ())
        {
          if (this->manufacturer_parser_)
          {
            this->manufacturer_parser_->pre ();
            this->manufacturer_parser_->_pre_impl ();
            this->manufacturer_parser_->_characters (s);
            this->manufacturer_parser_->_post_impl ();
            const ::std::string& tmp (this->manufacturer_parser_->post_normalized_string ());
            this->manufacturer (tmp);
          }

          return true;
        }

        if (n == "configVersion" && ns.empty ())
        {
          if (this->configVersion_parser_)
          {
            this->configVersion_parser_->pre ();
            this->configVersion_parser_->_pre_impl ();
            this->configVersion_parser_->_characters (s);
            this->configVersion_parser_->_post_impl ();
            const ::std::string& tmp (this->configVersion_parser_->post_normalized_string ());
            this->configVersion (tmp);
          }

          return true;
        }

        return this->::IEC61850::SCL::Validation::tNaming_pskel::_attribute_impl_phase_one (ns, n, s);
      }

      // Attribute validation and dispatch functions for tAccessPoint_pskel.
      //
      bool tAccessPoint_pskel::
      _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
                                 const ::xml_schema::ro_string& n,
                                 const ::xml_schema::ro_string& s)
      {
        if (n == "router" && ns.empty ())
        {
          if (this->router_parser_)
          {
            this->router_parser_->pre ();
            this->router_parser_->_pre_impl ();
            this->router_parser_->_characters (s);
            this->router_parser_->_post_impl ();
            bool tmp (this->router_parser_->post_boolean ());
            this->router (tmp);
          }

          return true;
        }

        if (n == "clock" && ns.empty ())
        {
          if (this->clock_parser_)
          {
            this->clock_parser_->pre ();
            this->clock_parser_->_pre_impl ();
            this->clock_parser_->_characters (s);
            this->clock_parser_->_post_impl ();
            bool tmp (this->clock_parser_->post_boolean ());
            this->clock (tmp);
          }

          return true;
        }

        return this->::IEC61850::SCL::Validation::tNaming_pskel::_attribute_impl_phase_one (ns, n, s);
      }

      // Attribute validation and dispatch functions for tServer_pskel.
      //
      bool tServer_pskel::
      _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
                                 const ::xml_schema::ro_string& n,
                                 const ::xml_schema::ro_string& s)
      {
        if (n == "timeout" && ns.empty ())
        {
          if (this->timeout_parser_)
          {
            this->timeout_parser_->pre ();
            this->timeout_parser_->_pre_impl ();
            this->timeout_parser_->_characters (s);
            this->timeout_parser_->_post_impl ();
            unsigned int tmp (this->timeout_parser_->post_unsigned_int ());
            this->timeout (tmp);
          }

          return true;
        }

        return this->::IEC61850::SCL::Validation::tUnNaming_pskel::_attribute_impl_phase_one (ns, n, s);
      }

      // Attribute validation and dispatch functions for tLDevice_pskel.
      //
      bool tLDevice_pskel::
      _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
                                 const ::xml_schema::ro_string& n,
                                 const ::xml_schema::ro_string& s)
      {
        if (n == "inst" && ns.empty ())
        {
          if (this->inst_parser_)
          {
            this->inst_parser_->pre ();
            this->inst_parser_->_pre_impl ();
            this->inst_parser_->_characters (s);
            this->inst_parser_->_post_impl ();
            this->inst_parser_->post_tName ();
            this->inst ();
          }

          static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->inst = true;
          return true;
        }

        if (n == "ldName" && ns.empty ())
        {
          if (this->ldName_parser_)
          {
            this->ldName_parser_->pre ();
            this->ldName_parser_->_pre_impl ();
            this->ldName_parser_->_characters (s);
            this->ldName_parser_->_post_impl ();
            this->ldName_parser_->post_tRestrLdName ();
            this->ldName ();
          }

          return true;
        }

        return this->::IEC61850::SCL::Validation::tUnNaming_pskel::_attribute_impl_phase_one (ns, n, s);
      }

      void tLDevice_pskel::
      _pre_a_validate ()
      {
        this->v_state_attr_stack_.push ();
        v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());

        as.inst = false;
        this->::IEC61850::SCL::Validation::tUnNaming_pskel::_pre_a_validate ();
      }

      void tLDevice_pskel::
      _post_a_validate ()
      {
        this->::IEC61850::SCL::Validation::tUnNaming_pskel::_post_a_validate ();

        v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());

        if (!as.inst)
          this->_expected_attribute (
            "", "inst");

        this->v_state_attr_stack_.pop ();
      }

      // Attribute validation and dispatch functions for tAssociation_pskel.
      //
      bool tAssociation_pskel::
      _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
                                 const ::xml_schema::ro_string& n,
                                 const ::xml_schema::ro_string& s)
      {
        if (n == "kind" && ns.empty ())
        {
          if (this->kind_parser_)
          {
            this->kind_parser_->pre ();
            this->kind_parser_->_pre_impl ();
            this->kind_parser_->_characters (s);
            this->kind_parser_->_post_impl ();
            this->kind_parser_->post_tAssociationKindEnum ();
            this->kind ();
          }

          static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->kind = true;
          return true;
        }

        if (n == "associationID" && ns.empty ())
        {
          if (this->associationID_parser_)
          {
            this->associationID_parser_->pre ();
            this->associationID_parser_->_pre_impl ();
            this->associationID_parser_->_characters (s);
            this->associationID_parser_->_post_impl ();
            this->associationID_parser_->post_tName ();
            this->associationID ();
          }

          return true;
        }

        if (n == "iedName" && ns.empty ())
        {
          if (this->iedName_parser_)
          {
            this->iedName_parser_->pre ();
            this->iedName_parser_->_pre_impl ();
            this->iedName_parser_->_characters (s);
            this->iedName_parser_->_post_impl ();
            this->iedName_parser_->post_tName ();
            this->iedName ();
          }

          static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->iedName = true;
          return true;
        }

        if (n == "ldInst" && ns.empty ())
        {
          if (this->ldInst_parser_)
          {
            this->ldInst_parser_->pre ();
            this->ldInst_parser_->_pre_impl ();
            this->ldInst_parser_->_characters (s);
            this->ldInst_parser_->_post_impl ();
            this->ldInst_parser_->post_tName ();
            this->ldInst ();
          }

          static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->ldInst = true;
          return true;
        }

        if (n == "prefix" && ns.empty ())
        {
          if (this->prefix_parser_)
          {
            this->prefix_parser_->pre ();
            this->prefix_parser_->_pre_impl ();
            this->prefix_parser_->_characters (s);
            this->prefix_parser_->_post_impl ();
            this->prefix_parser_->post_tAnyName ();
            this->prefix ();
          }

          return true;
        }

        if (n == "lnClass" && ns.empty ())
        {
          if (this->lnClass_parser_)
          {
            this->lnClass_parser_->pre ();
            this->lnClass_parser_->_pre_impl ();
            this->lnClass_parser_->_characters (s);
            this->lnClass_parser_->_post_impl ();
            this->lnClass_parser_->post_tLNClassEnum ();
            this->lnClass ();
          }

          static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->lnClass = true;
          return true;
        }

        if (n == "lnInst" && ns.empty ())
        {
          if (this->lnInst_parser_)
          {
            this->lnInst_parser_->pre ();
            this->lnInst_parser_->_pre_impl ();
            this->lnInst_parser_->_characters (s);
            this->lnInst_parser_->_post_impl ();
            this->lnInst_parser_->post_tAnyName ();
            this->lnInst ();
          }

          static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->lnInst = true;
          return true;
        }

        return false;
      }

      void tAssociation_pskel::
      _pre_a_validate ()
      {
        this->v_state_attr_stack_.push ();
        v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());

        as.kind = false;
        as.iedName = false;
        as.ldInst = false;
        as.lnClass = false;
        as.lnInst = false;
      }

      void tAssociation_pskel::
      _post_a_validate ()
      {
        v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());

        if (!as.kind)
          this->_expected_attribute (
            "", "kind");
        if (!as.iedName)
          this->_expected_attribute (
            "", "iedName");
        if (!as.ldInst)
          this->_expected_attribute (
            "", "ldInst");
        if (!as.lnClass)
          this->_expected_attribute (
            "", "lnClass");
        if (!as.lnInst)
          this->_expected_attribute (
            "", "lnInst");

        this->v_state_attr_stack_.pop ();
      }

      // Attribute validation and dispatch functions for tAnyLN_pskel.
      //
      bool tAnyLN_pskel::
      _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
                                 const ::xml_schema::ro_string& n,
                                 const ::xml_schema::ro_string& s)
      {
        if (n == "lnType" && ns.empty ())
        {
          if (this->lnType_parser_)
          {
            this->lnType_parser_->pre ();
            this->lnType_parser_->_pre_impl ();
            this->lnType_parser_->_characters (s);
            this->lnType_parser_->_post_impl ();
            this->lnType_parser_->post_tName ();
            this->lnType ();
          }

          static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->lnType = true;
          return true;
        }

        return this->::IEC61850::SCL::Validation::tUnNaming_pskel::_attribute_impl_phase_one (ns, n, s);
      }

      void tAnyLN_pskel::
      _pre_a_validate ()
      {
        this->v_state_attr_stack_.push ();
        v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());

        as.lnType = false;
        this->::IEC61850::SCL::Validation::tUnNaming_pskel::_pre_a_validate ();
      }

      void tAnyLN_pskel::
      _post_a_validate ()
      {
        this->::IEC61850::SCL::Validation::tUnNaming_pskel::_post_a_validate ();

        v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());

        if (!as.lnType)
          this->_expected_attribute (
            "", "lnType");

        this->v_state_attr_stack_.pop ();
      }

      // Attribute validation and dispatch functions for tLN_pskel.
      //
      bool tLN_pskel::
      _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
                                 const ::xml_schema::ro_string& n,
                                 const ::xml_schema::ro_string& s)
      {
        if (n == "lnClass" && ns.empty ())
        {
          if (this->lnClass_parser_)
          {
            this->lnClass_parser_->pre ();
            this->lnClass_parser_->_pre_impl ();
            this->lnClass_parser_->_characters (s);
            this->lnClass_parser_->_post_impl ();
            this->lnClass_parser_->post_tLNClassEnum ();
            this->lnClass ();
          }

          static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->lnClass = true;
          return true;
        }

        if (n == "inst" && ns.empty ())
        {
          if (this->inst_parser_)
          {
            this->inst_parser_->pre ();
            this->inst_parser_->_pre_impl ();
            this->inst_parser_->_characters (s);
            this->inst_parser_->_post_impl ();
            unsigned int tmp (this->inst_parser_->post_unsigned_int ());
            this->inst (tmp);
          }

          static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->inst = true;
          return true;
        }

        if (n == "prefix" && ns.empty ())
        {
          if (this->prefix_parser_)
          {
            this->prefix_parser_->pre ();
            this->prefix_parser_->_pre_impl ();
            this->prefix_parser_->_characters (s);
            this->prefix_parser_->_post_impl ();
            this->prefix_parser_->post_tAnyName ();
            this->prefix ();
          }

          return true;
        }

        return this->::IEC61850::SCL::Validation::tAnyLN_pskel::_attribute_impl_phase_one (ns, n, s);
      }

      void tLN_pskel::
      _pre_a_validate ()
      {
        this->v_state_attr_stack_.push ();
        v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());

        as.lnClass = false;
        as.inst = false;
        this->::IEC61850::SCL::Validation::tAnyLN_pskel::_pre_a_validate ();
      }

      void tLN_pskel::
      _post_a_validate ()
      {
        this->::IEC61850::SCL::Validation::tAnyLN_pskel::_post_a_validate ();

        v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());

        if (!as.lnClass)
          this->_expected_attribute (
            "", "lnClass");
        if (!as.inst)
          this->_expected_attribute (
            "", "inst");

        this->v_state_attr_stack_.pop ();
      }

      // Attribute validation and dispatch functions for tLN0_pskel.
      //
      bool tLN0_pskel::
      _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
                                 const ::xml_schema::ro_string& n,
                                 const ::xml_schema::ro_string& s)
      {
        if (n == "lnClass" && ns.empty ())
        {
          if (this->lnClass_parser_)
          {
            this->lnClass_parser_->pre ();
            this->lnClass_parser_->_pre_impl ();
            this->lnClass_parser_->_characters (s);
            this->lnClass_parser_->_post_impl ();
            this->lnClass_parser_->post_tLNClassEnum ();
            this->lnClass ();
          }

          static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->lnClass = true;
          return true;
        }

        if (n == "inst" && ns.empty ())
        {
          if (this->inst_parser_)
          {
            this->inst_parser_->pre ();
            this->inst_parser_->_pre_impl ();
            this->inst_parser_->_characters (s);
            this->inst_parser_->_post_impl ();
            const ::std::string& tmp (this->inst_parser_->post_normalized_string ());
            this->inst (tmp);
          }

          static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->inst = true;
          return true;
        }

        return this->::IEC61850::SCL::Validation::tAnyLN_pskel::_attribute_impl_phase_one (ns, n, s);
      }

      void tLN0_pskel::
      _pre_a_validate ()
      {
        this->v_state_attr_stack_.push ();
        v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());

        as.lnClass = false;
        as.inst = false;
        this->::IEC61850::SCL::Validation::tAnyLN_pskel::_pre_a_validate ();
      }

      void tLN0_pskel::
      _post_a_validate ()
      {
        this->::IEC61850::SCL::Validation::tAnyLN_pskel::_post_a_validate ();

        v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());

        if (!as.lnClass)
          this->_expected_attribute (
            "", "lnClass");
        if (!as.inst)
          this->_expected_attribute (
            "", "inst");

        this->v_state_attr_stack_.pop ();
      }

      // Attribute validation and dispatch functions for tFCDA_pskel.
      //
      bool tFCDA_pskel::
      _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
                                 const ::xml_schema::ro_string& n,
                                 const ::xml_schema::ro_string& s)
      {
        if (n == "ldInst" && ns.empty ())
        {
          if (this->ldInst_parser_)
          {
            this->ldInst_parser_->pre ();
            this->ldInst_parser_->_pre_impl ();
            this->ldInst_parser_->_characters (s);
            this->ldInst_parser_->_post_impl ();
            this->ldInst_parser_->post_tName ();
            this->ldInst ();
          }

          return true;
        }

        if (n == "prefix" && ns.empty ())
        {
          if (this->prefix_parser_)
          {
            this->prefix_parser_->pre ();
            this->prefix_parser_->_pre_impl ();
            this->prefix_parser_->_characters (s);
            this->prefix_parser_->_post_impl ();
            this->prefix_parser_->post_tAnyName ();
            this->prefix ();
          }

          return true;
        }

        if (n == "lnClass" && ns.empty ())
        {
          if (this->lnClass_parser_)
          {
            this->lnClass_parser_->pre ();
            this->lnClass_parser_->_pre_impl ();
            this->lnClass_parser_->_characters (s);
            this->lnClass_parser_->_post_impl ();
            this->lnClass_parser_->post_tLNClassEnum ();
            this->lnClass ();
          }

          return true;
        }

        if (n == "lnInst" && ns.empty ())
        {
          if (this->lnInst_parser_)
          {
            this->lnInst_parser_->pre ();
            this->lnInst_parser_->_pre_impl ();
            this->lnInst_parser_->_characters (s);
            this->lnInst_parser_->_post_impl ();
            this->lnInst_parser_->post_tName ();
            this->lnInst ();
          }

          return true;
        }

        if (n == "doName" && ns.empty ())
        {
          if (this->doName_parser_)
          {
            this->doName_parser_->pre ();
            this->doName_parser_->_pre_impl ();
            this->doName_parser_->_characters (s);
            this->doName_parser_->_post_impl ();
            this->doName_parser_->post_tName ();
            this->doName ();
          }

          return true;
        }

        if (n == "daName" && ns.empty ())
        {
          if (this->daName_parser_)
          {
            this->daName_parser_->pre ();
            this->daName_parser_->_pre_impl ();
            this->daName_parser_->_characters (s);
            this->daName_parser_->_post_impl ();
            this->daName_parser_->post_tName ();
            this->daName ();
          }

          return true;
        }

        if (n == "fc" && ns.empty ())
        {
          if (this->fc_parser_)
          {
            this->fc_parser_->pre ();
            this->fc_parser_->_pre_impl ();
            this->fc_parser_->_characters (s);
            this->fc_parser_->_post_impl ();
            this->fc_parser_->post_tFCEnum ();
            this->fc ();
          }

          static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->fc = true;
          return true;
        }

        return false;
      }

      void tFCDA_pskel::
      _pre_a_validate ()
      {
        this->v_state_attr_stack_.push ();
        v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());

        as.fc = false;
      }

      void tFCDA_pskel::
      _post_a_validate ()
      {
        v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());

        if (!as.fc)
          this->_expected_attribute (
            "", "fc");

        this->v_state_attr_stack_.pop ();
      }

      // Attribute validation and dispatch functions for tFCCB_pskel.
      //
      bool tFCCB_pskel::
      _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
                                 const ::xml_schema::ro_string& n,
                                 const ::xml_schema::ro_string& s)
      {
        if (n == "ldInst" && ns.empty ())
        {
          if (this->ldInst_parser_)
          {
            this->ldInst_parser_->pre ();
            this->ldInst_parser_->_pre_impl ();
            this->ldInst_parser_->_characters (s);
            this->ldInst_parser_->_post_impl ();
            this->ldInst_parser_->post_tName ();
            this->ldInst ();
          }

          static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->ldInst = true;
          return true;
        }

        if (n == "prefix" && ns.empty ())
        {
          if (this->prefix_parser_)
          {
            this->prefix_parser_->pre ();
            this->prefix_parser_->_pre_impl ();
            this->prefix_parser_->_characters (s);
            this->prefix_parser_->_post_impl ();
            this->prefix_parser_->post_tAnyName ();
            this->prefix ();
          }

          return true;
        }

        if (n == "lnClass" && ns.empty ())
        {
          if (this->lnClass_parser_)
          {
            this->lnClass_parser_->pre ();
            this->lnClass_parser_->_pre_impl ();
            this->lnClass_parser_->_characters (s);
            this->lnClass_parser_->_post_impl ();
            this->lnClass_parser_->post_tLNClassEnum ();
            this->lnClass ();
          }

          static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->lnClass = true;
          return true;
        }

        if (n == "lnInst" && ns.empty ())
        {
          if (this->lnInst_parser_)
          {
            this->lnInst_parser_->pre ();
            this->lnInst_parser_->_pre_impl ();
            this->lnInst_parser_->_characters (s);
            this->lnInst_parser_->_post_impl ();
            this->lnInst_parser_->post_tName ();
            this->lnInst ();
          }

          return true;
        }

        if (n == "cbName" && ns.empty ())
        {
          if (this->cbName_parser_)
          {
            this->cbName_parser_->pre ();
            this->cbName_parser_->_pre_impl ();
            this->cbName_parser_->_characters (s);
            this->cbName_parser_->_post_impl ();
            this->cbName_parser_->post_tName ();
            this->cbName ();
          }

          static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->cbName = true;
          return true;
        }

        if (n == "daName" && ns.empty ())
        {
          if (this->daName_parser_)
          {
            this->daName_parser_->pre ();
            this->daName_parser_->_pre_impl ();
            this->daName_parser_->_characters (s);
            this->daName_parser_->_post_impl ();
            this->daName_parser_->post_tName ();
            this->daName ();
          }

          return true;
        }

        if (n == "fc" && ns.empty ())
        {
          if (this->fc_parser_)
          {
            this->fc_parser_->pre ();
            this->fc_parser_->_pre_impl ();
            this->fc_parser_->_characters (s);
            this->fc_parser_->_post_impl ();
            this->fc_parser_->post_tServiceFCEnum ();
            this->fc ();
          }

          static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->fc = true;
          return true;
        }

        return false;
      }

      void tFCCB_pskel::
      _pre_a_validate ()
      {
        this->v_state_attr_stack_.push ();
        v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());

        as.ldInst = false;
        as.lnClass = false;
        as.cbName = false;
        as.fc = false;
      }

      void tFCCB_pskel::
      _post_a_validate ()
      {
        v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());

        if (!as.ldInst)
          this->_expected_attribute (
            "", "ldInst");
        if (!as.lnClass)
          this->_expected_attribute (
            "", "lnClass");
        if (!as.cbName)
          this->_expected_attribute (
            "", "cbName");
        if (!as.fc)
          this->_expected_attribute (
            "", "fc");

        this->v_state_attr_stack_.pop ();
      }

      // Attribute validation and dispatch functions for tControl_pskel.
      //
      bool tControl_pskel::
      _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
                                 const ::xml_schema::ro_string& n,
                                 const ::xml_schema::ro_string& s)
      {
        if (n == "datSet" && ns.empty ())
        {
          if (this->datSet_parser_)
          {
            this->datSet_parser_->pre ();
            this->datSet_parser_->_pre_impl ();
            this->datSet_parser_->_characters (s);
            this->datSet_parser_->_post_impl ();
            this->datSet_parser_->post_tName ();
            this->datSet ();
          }

          return true;
        }

        return this->::IEC61850::SCL::Validation::tNaming_pskel::_attribute_impl_phase_one (ns, n, s);
      }

      // Attribute validation and dispatch functions for tControlWithTriggerOpt_pskel.
      //
      bool tControlWithTriggerOpt_pskel::
      _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
                                 const ::xml_schema::ro_string& n,
                                 const ::xml_schema::ro_string& s)
      {
        if (n == "intgPd" && ns.empty ())
        {
          if (this->intgPd_parser_)
          {
            this->intgPd_parser_->pre ();
            this->intgPd_parser_->_pre_impl ();
            this->intgPd_parser_->_characters (s);
            this->intgPd_parser_->_post_impl ();
            unsigned int tmp (this->intgPd_parser_->post_unsigned_int ());
            this->intgPd (tmp);
          }

          return true;
        }

        return this->::IEC61850::SCL::Validation::tControl_pskel::_attribute_impl_phase_one (ns, n, s);
      }

      // Attribute validation and dispatch functions for tTrgOps_pskel.
      //
      bool tTrgOps_pskel::
      _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
                                 const ::xml_schema::ro_string& n,
                                 const ::xml_schema::ro_string& s)
      {
        if (n == "dchg" && ns.empty ())
        {
          if (this->dchg_parser_)
          {
            this->dchg_parser_->pre ();
            this->dchg_parser_->_pre_impl ();
            this->dchg_parser_->_characters (s);
            this->dchg_parser_->_post_impl ();
            bool tmp (this->dchg_parser_->post_boolean ());
            this->dchg (tmp);
          }

          return true;
        }

        if (n == "qchg" && ns.empty ())
        {
          if (this->qchg_parser_)
          {
            this->qchg_parser_->pre ();
            this->qchg_parser_->_pre_impl ();
            this->qchg_parser_->_characters (s);
            this->qchg_parser_->_post_impl ();
            bool tmp (this->qchg_parser_->post_boolean ());
            this->qchg (tmp);
          }

          return true;
        }

        if (n == "dupd" && ns.empty ())
        {
          if (this->dupd_parser_)
          {
            this->dupd_parser_->pre ();
            this->dupd_parser_->_pre_impl ();
            this->dupd_parser_->_characters (s);
            this->dupd_parser_->_post_impl ();
            bool tmp (this->dupd_parser_->post_boolean ());
            this->dupd (tmp);
          }

          return true;
        }

        if (n == "period" && ns.empty ())
        {
          if (this->period_parser_)
          {
            this->period_parser_->pre ();
            this->period_parser_->_pre_impl ();
            this->period_parser_->_characters (s);
            this->period_parser_->_post_impl ();
            bool tmp (this->period_parser_->post_boolean ());
            this->period (tmp);
          }

          return true;
        }

        return false;
      }

      // Attribute validation and dispatch functions for tReportControl_pskel.
      //
      bool tReportControl_pskel::
      _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
                                 const ::xml_schema::ro_string& n,
                                 const ::xml_schema::ro_string& s)
      {
        if (n == "rptID" && ns.empty ())
        {
          if (this->rptID_parser_)
          {
            this->rptID_parser_->pre ();
            this->rptID_parser_->_pre_impl ();
            this->rptID_parser_->_characters (s);
            this->rptID_parser_->_post_impl ();
            this->rptID_parser_->post_tName ();
            this->rptID ();
          }

          return true;
        }

        if (n == "confRev" && ns.empty ())
        {
          if (this->confRev_parser_)
          {
            this->confRev_parser_->pre ();
            this->confRev_parser_->_pre_impl ();
            this->confRev_parser_->_characters (s);
            this->confRev_parser_->_post_impl ();
            unsigned int tmp (this->confRev_parser_->post_unsigned_int ());
            this->confRev (tmp);
          }

          static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->confRev = true;
          return true;
        }

        if (n == "buffered" && ns.empty ())
        {
          if (this->buffered_parser_)
          {
            this->buffered_parser_->pre ();
            this->buffered_parser_->_pre_impl ();
            this->buffered_parser_->_characters (s);
            this->buffered_parser_->_post_impl ();
            bool tmp (this->buffered_parser_->post_boolean ());
            this->buffered (tmp);
          }

          return true;
        }

        if (n == "bufTime" && ns.empty ())
        {
          if (this->bufTime_parser_)
          {
            this->bufTime_parser_->pre ();
            this->bufTime_parser_->_pre_impl ();
            this->bufTime_parser_->_characters (s);
            this->bufTime_parser_->_post_impl ();
            unsigned int tmp (this->bufTime_parser_->post_unsigned_int ());
            this->bufTime (tmp);
          }

          return true;
        }

        return this->::IEC61850::SCL::Validation::tControlWithTriggerOpt_pskel::_attribute_impl_phase_one (ns, n, s);
      }

      void tReportControl_pskel::
      _pre_a_validate ()
      {
        this->v_state_attr_stack_.push ();
        v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());

        as.confRev = false;
        this->::IEC61850::SCL::Validation::tControlWithTriggerOpt_pskel::_pre_a_validate ();
      }

      void tReportControl_pskel::
      _post_a_validate ()
      {
        this->::IEC61850::SCL::Validation::tControlWithTriggerOpt_pskel::_post_a_validate ();

        v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());

        if (!as.confRev)
          this->_expected_attribute (
            "", "confRev");

        this->v_state_attr_stack_.pop ();
      }

      // Attribute validation and dispatch functions for tRptEnabled_pskel.
      //
      bool tRptEnabled_pskel::
      _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
                                 const ::xml_schema::ro_string& n,
                                 const ::xml_schema::ro_string& s)
      {
        if (n == "max" && ns.empty ())
        {
          if (this->max_parser_)
          {
            this->max_parser_->pre ();
            this->max_parser_->_pre_impl ();
            this->max_parser_->_characters (s);
            this->max_parser_->_post_impl ();
            unsigned int tmp (this->max_parser_->post_unsigned_int ());
            this->max (tmp);
          }

          return true;
        }

        return this->::IEC61850::SCL::Validation::tUnNaming_pskel::_attribute_impl_phase_one (ns, n, s);
      }

      // Attribute validation and dispatch functions for tClientLN_pskel.
      //
      bool tClientLN_pskel::
      _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
                                 const ::xml_schema::ro_string& n,
                                 const ::xml_schema::ro_string& s)
      {
        if (n == "iedName" && ns.empty ())
        {
          if (this->iedName_parser_)
          {
            this->iedName_parser_->pre ();
            this->iedName_parser_->_pre_impl ();
            this->iedName_parser_->_characters (s);
            this->iedName_parser_->_post_impl ();
            this->iedName_parser_->post_tName ();
            this->iedName ();
          }

          static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->iedName = true;
          return true;
        }

        if (n == "ldInst" && ns.empty ())
        {
          if (this->ldInst_parser_)
          {
            this->ldInst_parser_->pre ();
            this->ldInst_parser_->_pre_impl ();
            this->ldInst_parser_->_characters (s);
            this->ldInst_parser_->_post_impl ();
            this->ldInst_parser_->post_tName ();
            this->ldInst ();
          }

          static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->ldInst = true;
          return true;
        }

        if (n == "prefix" && ns.empty ())
        {
          if (this->prefix_parser_)
          {
            this->prefix_parser_->pre ();
            this->prefix_parser_->_pre_impl ();
            this->prefix_parser_->_characters (s);
            this->prefix_parser_->_post_impl ();
            this->prefix_parser_->post_tAnyName ();
            this->prefix ();
          }

          return true;
        }

        if (n == "lnClass" && ns.empty ())
        {
          if (this->lnClass_parser_)
          {
            this->lnClass_parser_->pre ();
            this->lnClass_parser_->_pre_impl ();
            this->lnClass_parser_->_characters (s);
            this->lnClass_parser_->_post_impl ();
            this->lnClass_parser_->post_tLNClassEnum ();
            this->lnClass ();
          }

          static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->lnClass = true;
          return true;
        }

        if (n == "lnInst" && ns.empty ())
        {
          if (this->lnInst_parser_)
          {
            this->lnInst_parser_->pre ();
            this->lnInst_parser_->_pre_impl ();
            this->lnInst_parser_->_characters (s);
            this->lnInst_parser_->_post_impl ();
            this->lnInst_parser_->post_tAnyName ();
            this->lnInst ();
          }

          static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->lnInst = true;
          return true;
        }

        return false;
      }

      void tClientLN_pskel::
      _pre_a_validate ()
      {
        this->v_state_attr_stack_.push ();
        v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());

        as.iedName = false;
        as.ldInst = false;
        as.lnClass = false;
        as.lnInst = false;
      }

      void tClientLN_pskel::
      _post_a_validate ()
      {
        v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());

        if (!as.iedName)
          this->_expected_attribute (
            "", "iedName");
        if (!as.ldInst)
          this->_expected_attribute (
            "", "ldInst");
        if (!as.lnClass)
          this->_expected_attribute (
            "", "lnClass");
        if (!as.lnInst)
          this->_expected_attribute (
            "", "lnInst");

        this->v_state_attr_stack_.pop ();
      }

      // Attribute validation and dispatch functions for tLogControl_pskel.
      //
      bool tLogControl_pskel::
      _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
                                 const ::xml_schema::ro_string& n,
                                 const ::xml_schema::ro_string& s)
      {
        if (n == "logName" && ns.empty ())
        {
          if (this->logName_parser_)
          {
            this->logName_parser_->pre ();
            this->logName_parser_->_pre_impl ();
            this->logName_parser_->_characters (s);
            this->logName_parser_->_post_impl ();
            this->logName_parser_->post_tName ();
            this->logName ();
          }

          static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->logName = true;
          return true;
        }

        if (n == "logEna" && ns.empty ())
        {
          if (this->logEna_parser_)
          {
            this->logEna_parser_->pre ();
            this->logEna_parser_->_pre_impl ();
            this->logEna_parser_->_characters (s);
            this->logEna_parser_->_post_impl ();
            bool tmp (this->logEna_parser_->post_boolean ());
            this->logEna (tmp);
          }

          return true;
        }

        if (n == "reasonCode" && ns.empty ())
        {
          if (this->reasonCode_parser_)
          {
            this->reasonCode_parser_->pre ();
            this->reasonCode_parser_->_pre_impl ();
            this->reasonCode_parser_->_characters (s);
            this->reasonCode_parser_->_post_impl ();
            bool tmp (this->reasonCode_parser_->post_boolean ());
            this->reasonCode (tmp);
          }

          return true;
        }

        return this->::IEC61850::SCL::Validation::tControlWithTriggerOpt_pskel::_attribute_impl_phase_one (ns, n, s);
      }

      void tLogControl_pskel::
      _pre_a_validate ()
      {
        this->v_state_attr_stack_.push ();
        v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());

        as.logName = false;
        this->::IEC61850::SCL::Validation::tControlWithTriggerOpt_pskel::_pre_a_validate ();
      }

      void tLogControl_pskel::
      _post_a_validate ()
      {
        this->::IEC61850::SCL::Validation::tControlWithTriggerOpt_pskel::_post_a_validate ();

        v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());

        if (!as.logName)
          this->_expected_attribute (
            "", "logName");

        this->v_state_attr_stack_.pop ();
      }

      // Attribute validation and dispatch functions for tExtRef_pskel.
      //
      bool tExtRef_pskel::
      _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
                                 const ::xml_schema::ro_string& n,
                                 const ::xml_schema::ro_string& s)
      {
        if (n == "iedName" && ns.empty ())
        {
          if (this->iedName_parser_)
          {
            this->iedName_parser_->pre ();
            this->iedName_parser_->_pre_impl ();
            this->iedName_parser_->_characters (s);
            this->iedName_parser_->_post_impl ();
            this->iedName_parser_->post_tName ();
            this->iedName ();
          }

          static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->iedName = true;
          return true;
        }

        if (n == "ldInst" && ns.empty ())
        {
          if (this->ldInst_parser_)
          {
            this->ldInst_parser_->pre ();
            this->ldInst_parser_->_pre_impl ();
            this->ldInst_parser_->_characters (s);
            this->ldInst_parser_->_post_impl ();
            this->ldInst_parser_->post_tName ();
            this->ldInst ();
          }

          static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->ldInst = true;
          return true;
        }

        if (n == "prefix" && ns.empty ())
        {
          if (this->prefix_parser_)
          {
            this->prefix_parser_->pre ();
            this->prefix_parser_->_pre_impl ();
            this->prefix_parser_->_characters (s);
            this->prefix_parser_->_post_impl ();
            this->prefix_parser_->post_tAnyName ();
            this->prefix ();
          }

          return true;
        }

        if (n == "lnClass" && ns.empty ())
        {
          if (this->lnClass_parser_)
          {
            this->lnClass_parser_->pre ();
            this->lnClass_parser_->_pre_impl ();
            this->lnClass_parser_->_characters (s);
            this->lnClass_parser_->_post_impl ();
            this->lnClass_parser_->post_tLNClassEnum ();
            this->lnClass ();
          }

          static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->lnClass = true;
          return true;
        }

        if (n == "lnInst" && ns.empty ())
        {
          if (this->lnInst_parser_)
          {
            this->lnInst_parser_->pre ();
            this->lnInst_parser_->_pre_impl ();
            this->lnInst_parser_->_characters (s);
            this->lnInst_parser_->_post_impl ();
            this->lnInst_parser_->post_tAnyName ();
            this->lnInst ();
          }

          static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->lnInst = true;
          return true;
        }

        if (n == "doName" && ns.empty ())
        {
          if (this->doName_parser_)
          {
            this->doName_parser_->pre ();
            this->doName_parser_->_pre_impl ();
            this->doName_parser_->_characters (s);
            this->doName_parser_->_post_impl ();
            this->doName_parser_->post_tName ();
            this->doName ();
          }

          static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->doName = true;
          return true;
        }

        if (n == "daName" && ns.empty ())
        {
          if (this->daName_parser_)
          {
            this->daName_parser_->pre ();
            this->daName_parser_->_pre_impl ();
            this->daName_parser_->_characters (s);
            this->daName_parser_->_post_impl ();
            this->daName_parser_->post_tName ();
            this->daName ();
          }

          return true;
        }

        if (n == "intAddr" && ns.empty ())
        {
          if (this->intAddr_parser_)
          {
            this->intAddr_parser_->pre ();
            this->intAddr_parser_->_pre_impl ();
            this->intAddr_parser_->_characters (s);
            this->intAddr_parser_->_post_impl ();
            const ::std::string& tmp (this->intAddr_parser_->post_normalized_string ());
            this->intAddr (tmp);
          }

          return true;
        }

        return false;
      }

      void tExtRef_pskel::
      _pre_a_validate ()
      {
        this->v_state_attr_stack_.push ();
        v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());

        as.iedName = false;
        as.ldInst = false;
        as.lnClass = false;
        as.lnInst = false;
        as.doName = false;
      }

      void tExtRef_pskel::
      _post_a_validate ()
      {
        v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());

        if (!as.iedName)
          this->_expected_attribute (
            "", "iedName");
        if (!as.ldInst)
          this->_expected_attribute (
            "", "ldInst");
        if (!as.lnClass)
          this->_expected_attribute (
            "", "lnClass");
        if (!as.lnInst)
          this->_expected_attribute (
            "", "lnInst");
        if (!as.doName)
          this->_expected_attribute (
            "", "doName");

        this->v_state_attr_stack_.pop ();
      }

      // Attribute validation and dispatch functions for tControlWithIEDName_pskel.
      //
      bool tControlWithIEDName_pskel::
      _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
                                 const ::xml_schema::ro_string& n,
                                 const ::xml_schema::ro_string& s)
      {
        if (n == "confRev" && ns.empty ())
        {
          if (this->confRev_parser_)
          {
            this->confRev_parser_->pre ();
            this->confRev_parser_->_pre_impl ();
            this->confRev_parser_->_characters (s);
            this->confRev_parser_->_post_impl ();
            unsigned int tmp (this->confRev_parser_->post_unsigned_int ());
            this->confRev (tmp);
          }

          return true;
        }

        return this->::IEC61850::SCL::Validation::tControl_pskel::_attribute_impl_phase_one (ns, n, s);
      }

      // Attribute validation and dispatch functions for tGSEControl_pskel.
      //
      bool tGSEControl_pskel::
      _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
                                 const ::xml_schema::ro_string& n,
                                 const ::xml_schema::ro_string& s)
      {
        if (n == "type" && ns.empty ())
        {
          if (this->type_parser_)
          {
            this->type_parser_->pre ();
            this->type_parser_->_pre_impl ();
            this->type_parser_->_characters (s);
            this->type_parser_->_post_impl ();
            this->type_parser_->post_tGSEControlTypeEnum ();
            this->type ();
          }

          return true;
        }

        if (n == "appID" && ns.empty ())
        {
          if (this->appID_parser_)
          {
            this->appID_parser_->pre ();
            this->appID_parser_->_pre_impl ();
            this->appID_parser_->_characters (s);
            this->appID_parser_->_post_impl ();
            const ::std::string& tmp (this->appID_parser_->post_normalized_string ());
            this->appID (tmp);
          }

          static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->appID = true;
          return true;
        }

        return this->::IEC61850::SCL::Validation::tControlWithIEDName_pskel::_attribute_impl_phase_one (ns, n, s);
      }

      void tGSEControl_pskel::
      _pre_a_validate ()
      {
        this->v_state_attr_stack_.push ();
        v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());

        as.appID = false;
        this->::IEC61850::SCL::Validation::tControlWithIEDName_pskel::_pre_a_validate ();
      }

      void tGSEControl_pskel::
      _post_a_validate ()
      {
        this->::IEC61850::SCL::Validation::tControlWithIEDName_pskel::_post_a_validate ();

        v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());

        if (!as.appID)
          this->_expected_attribute (
            "", "appID");

        this->v_state_attr_stack_.pop ();
      }

      // Attribute validation and dispatch functions for tSampledValueControl_pskel.
      //
      bool tSampledValueControl_pskel::
      _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
                                 const ::xml_schema::ro_string& n,
                                 const ::xml_schema::ro_string& s)
      {
        if (n == "smvID" && ns.empty ())
        {
          if (this->smvID_parser_)
          {
            this->smvID_parser_->pre ();
            this->smvID_parser_->_pre_impl ();
            this->smvID_parser_->_characters (s);
            this->smvID_parser_->_post_impl ();
            const ::std::string& tmp (this->smvID_parser_->post_normalized_string ());
            this->smvID (tmp);
          }

          static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->smvID = true;
          return true;
        }

        if (n == "multicast" && ns.empty ())
        {
          if (this->multicast_parser_)
          {
            this->multicast_parser_->pre ();
            this->multicast_parser_->_pre_impl ();
            this->multicast_parser_->_characters (s);
            this->multicast_parser_->_post_impl ();
            bool tmp (this->multicast_parser_->post_boolean ());
            this->multicast (tmp);
          }

          return true;
        }

        if (n == "smpRate" && ns.empty ())
        {
          if (this->smpRate_parser_)
          {
            this->smpRate_parser_->pre ();
            this->smpRate_parser_->_pre_impl ();
            this->smpRate_parser_->_characters (s);
            this->smpRate_parser_->_post_impl ();
            unsigned int tmp (this->smpRate_parser_->post_unsigned_int ());
            this->smpRate (tmp);
          }

          static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->smpRate = true;
          return true;
        }

        if (n == "nofASDU" && ns.empty ())
        {
          if (this->nofASDU_parser_)
          {
            this->nofASDU_parser_->pre ();
            this->nofASDU_parser_->_pre_impl ();
            this->nofASDU_parser_->_characters (s);
            this->nofASDU_parser_->_post_impl ();
            unsigned int tmp (this->nofASDU_parser_->post_unsigned_int ());
            this->nofASDU (tmp);
          }

          static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->nofASDU = true;
          return true;
        }

        return this->::IEC61850::SCL::Validation::tControlWithIEDName_pskel::_attribute_impl_phase_one (ns, n, s);
      }

      void tSampledValueControl_pskel::
      _pre_a_validate ()
      {
        this->v_state_attr_stack_.push ();
        v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());

        as.smvID = false;
        as.smpRate = false;
        as.nofASDU = false;
        this->::IEC61850::SCL::Validation::tControlWithIEDName_pskel::_pre_a_validate ();
      }

      void tSampledValueControl_pskel::
      _post_a_validate ()
      {
        this->::IEC61850::SCL::Validation::tControlWithIEDName_pskel::_post_a_validate ();

        v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());

        if (!as.smvID)
          this->_expected_attribute (
            "", "smvID");
        if (!as.smpRate)
          this->_expected_attribute (
            "", "smpRate");
        if (!as.nofASDU)
          this->_expected_attribute (
            "", "nofASDU");

        this->v_state_attr_stack_.pop ();
      }

      // Attribute validation and dispatch functions for tSettingControl_pskel.
      //
      bool tSettingControl_pskel::
      _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
                                 const ::xml_schema::ro_string& n,
                                 const ::xml_schema::ro_string& s)
      {
        if (n == "numOfSGs" && ns.empty ())
        {
          if (this->numOfSGs_parser_)
          {
            this->numOfSGs_parser_->pre ();
            this->numOfSGs_parser_->_pre_impl ();
            this->numOfSGs_parser_->_characters (s);
            this->numOfSGs_parser_->_post_impl ();
            unsigned int tmp (this->numOfSGs_parser_->post_unsigned_int ());
            this->numOfSGs (tmp);
          }

          static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->numOfSGs = true;
          return true;
        }

        if (n == "actSG" && ns.empty ())
        {
          if (this->actSG_parser_)
          {
            this->actSG_parser_->pre ();
            this->actSG_parser_->_pre_impl ();
            this->actSG_parser_->_characters (s);
            this->actSG_parser_->_post_impl ();
            unsigned int tmp (this->actSG_parser_->post_unsigned_int ());
            this->actSG (tmp);
          }

          return true;
        }

        return this->::IEC61850::SCL::Validation::tUnNaming_pskel::_attribute_impl_phase_one (ns, n, s);
      }

      void tSettingControl_pskel::
      _pre_a_validate ()
      {
        this->v_state_attr_stack_.push ();
        v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());

        as.numOfSGs = false;
        this->::IEC61850::SCL::Validation::tUnNaming_pskel::_pre_a_validate ();
      }

      void tSettingControl_pskel::
      _post_a_validate ()
      {
        this->::IEC61850::SCL::Validation::tUnNaming_pskel::_post_a_validate ();

        v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());

        if (!as.numOfSGs)
          this->_expected_attribute (
            "", "numOfSGs");

        this->v_state_attr_stack_.pop ();
      }

      // Attribute validation and dispatch functions for tDOI_pskel.
      //
      bool tDOI_pskel::
      _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
                                 const ::xml_schema::ro_string& n,
                                 const ::xml_schema::ro_string& s)
      {
        if (n == "name" && ns.empty ())
        {
          if (this->name_parser_)
          {
            this->name_parser_->pre ();
            this->name_parser_->_pre_impl ();
            this->name_parser_->_characters (s);
            this->name_parser_->_post_impl ();
            this->name_parser_->post_tRestrName1stU ();
            this->name ();
          }

          static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->name = true;
          return true;
        }

        if (n == "ix" && ns.empty ())
        {
          if (this->ix_parser_)
          {
            this->ix_parser_->pre ();
            this->ix_parser_->_pre_impl ();
            this->ix_parser_->_characters (s);
            this->ix_parser_->_post_impl ();
            unsigned int tmp (this->ix_parser_->post_unsigned_int ());
            this->ix (tmp);
          }

          return true;
        }

        if (n == "accessControl" && ns.empty ())
        {
          if (this->accessControl_parser_)
          {
            this->accessControl_parser_->pre ();
            this->accessControl_parser_->_pre_impl ();
            this->accessControl_parser_->_characters (s);
            this->accessControl_parser_->_post_impl ();
            const ::std::string& tmp (this->accessControl_parser_->post_normalized_string ());
            this->accessControl (tmp);
          }

          return true;
        }

        return this->::IEC61850::SCL::Validation::tUnNaming_pskel::_attribute_impl_phase_one (ns, n, s);
      }

      void tDOI_pskel::
      _pre_a_validate ()
      {
        this->v_state_attr_stack_.push ();
        v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());

        as.name = false;
        this->::IEC61850::SCL::Validation::tUnNaming_pskel::_pre_a_validate ();
      }

      void tDOI_pskel::
      _post_a_validate ()
      {
        this->::IEC61850::SCL::Validation::tUnNaming_pskel::_post_a_validate ();

        v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());

        if (!as.name)
          this->_expected_attribute (
            "", "name");

        this->v_state_attr_stack_.pop ();
      }

      // Attribute validation and dispatch functions for tSDI_pskel.
      //
      bool tSDI_pskel::
      _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
                                 const ::xml_schema::ro_string& n,
                                 const ::xml_schema::ro_string& s)
      {
        if (n == "name" && ns.empty ())
        {
          if (this->name_parser_)
          {
            this->name_parser_->pre ();
            this->name_parser_->_pre_impl ();
            this->name_parser_->_characters (s);
            this->name_parser_->_post_impl ();
            this->name_parser_->post_tAttributeNameEnum ();
            this->name ();
          }

          static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->name = true;
          return true;
        }

        if (n == "ix" && ns.empty ())
        {
          if (this->ix_parser_)
          {
            this->ix_parser_->pre ();
            this->ix_parser_->_pre_impl ();
            this->ix_parser_->_characters (s);
            this->ix_parser_->_post_impl ();
            unsigned int tmp (this->ix_parser_->post_unsigned_int ());
            this->ix (tmp);
          }

          return true;
        }

        return this->::IEC61850::SCL::Validation::tUnNaming_pskel::_attribute_impl_phase_one (ns, n, s);
      }

      void tSDI_pskel::
      _pre_a_validate ()
      {
        this->v_state_attr_stack_.push ();
        v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());

        as.name = false;
        this->::IEC61850::SCL::Validation::tUnNaming_pskel::_pre_a_validate ();
      }

      void tSDI_pskel::
      _post_a_validate ()
      {
        this->::IEC61850::SCL::Validation::tUnNaming_pskel::_post_a_validate ();

        v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());

        if (!as.name)
          this->_expected_attribute (
            "", "name");

        this->v_state_attr_stack_.pop ();
      }

      // Attribute validation and dispatch functions for tDAI_pskel.
      //
      bool tDAI_pskel::
      _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
                                 const ::xml_schema::ro_string& n,
                                 const ::xml_schema::ro_string& s)
      {
        if (n == "name" && ns.empty ())
        {
          if (this->name_parser_)
          {
            this->name_parser_->pre ();
            this->name_parser_->_pre_impl ();
            this->name_parser_->_characters (s);
            this->name_parser_->_post_impl ();
            this->name_parser_->post_tAttributeNameEnum ();
            this->name ();
          }

          static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->name = true;
          return true;
        }

        if (n == "sAddr" && ns.empty ())
        {
          if (this->sAddr_parser_)
          {
            this->sAddr_parser_->pre ();
            this->sAddr_parser_->_pre_impl ();
            this->sAddr_parser_->_characters (s);
            this->sAddr_parser_->_post_impl ();
            const ::std::string& tmp (this->sAddr_parser_->post_normalized_string ());
            this->sAddr (tmp);
          }

          return true;
        }

        if (n == "valKind" && ns.empty ())
        {
          if (this->valKind_parser_)
          {
            this->valKind_parser_->pre ();
            this->valKind_parser_->_pre_impl ();
            this->valKind_parser_->_characters (s);
            this->valKind_parser_->_post_impl ();
            this->valKind_parser_->post_tValKindEnum ();
            this->valKind ();
          }

          return true;
        }

        if (n == "ix" && ns.empty ())
        {
          if (this->ix_parser_)
          {
            this->ix_parser_->pre ();
            this->ix_parser_->_pre_impl ();
            this->ix_parser_->_characters (s);
            this->ix_parser_->_post_impl ();
            unsigned int tmp (this->ix_parser_->post_unsigned_int ());
            this->ix (tmp);
          }

          return true;
        }

        return this->::IEC61850::SCL::Validation::tUnNaming_pskel::_attribute_impl_phase_one (ns, n, s);
      }

      void tDAI_pskel::
      _pre_a_validate ()
      {
        this->v_state_attr_stack_.push ();
        v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());

        as.name = false;
        this->::IEC61850::SCL::Validation::tUnNaming_pskel::_pre_a_validate ();
      }

      void tDAI_pskel::
      _post_a_validate ()
      {
        this->::IEC61850::SCL::Validation::tUnNaming_pskel::_post_a_validate ();

        v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());

        if (!as.name)
          this->_expected_attribute (
            "", "name");

        this->v_state_attr_stack_.pop ();
      }

      // Attribute validation and dispatch functions for tServiceWithMax_pskel.
      //
      bool tServiceWithMax_pskel::
      _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
                                 const ::xml_schema::ro_string& n,
                                 const ::xml_schema::ro_string& s)
      {
        if (n == "max" && ns.empty ())
        {
          if (this->max_parser_)
          {
            this->max_parser_->pre ();
            this->max_parser_->_pre_impl ();
            this->max_parser_->_characters (s);
            this->max_parser_->_post_impl ();
            unsigned int tmp (this->max_parser_->post_unsigned_int ());
            this->max (tmp);
          }

          static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->max = true;
          return true;
        }

        return false;
      }

      void tServiceWithMax_pskel::
      _pre_a_validate ()
      {
        this->v_state_attr_stack_.push ();
        v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());

        as.max = false;
      }

      void tServiceWithMax_pskel::
      _post_a_validate ()
      {
        v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());

        if (!as.max)
          this->_expected_attribute (
            "", "max");

        this->v_state_attr_stack_.pop ();
      }

      // Attribute validation and dispatch functions for tServiceWithMaxAndMaxAttributes_pskel.
      //
      bool tServiceWithMaxAndMaxAttributes_pskel::
      _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
                                 const ::xml_schema::ro_string& n,
                                 const ::xml_schema::ro_string& s)
      {
        if (n == "maxAttributes" && ns.empty ())
        {
          if (this->maxAttributes_parser_)
          {
            this->maxAttributes_parser_->pre ();
            this->maxAttributes_parser_->_pre_impl ();
            this->maxAttributes_parser_->_characters (s);
            this->maxAttributes_parser_->_post_impl ();
            unsigned int tmp (this->maxAttributes_parser_->post_unsigned_int ());
            this->maxAttributes (tmp);
          }

          return true;
        }

        return this->::IEC61850::SCL::Validation::tServiceWithMax_pskel::_attribute_impl_phase_one (ns, n, s);
      }

      // Attribute validation and dispatch functions for tServiceWithMaxAndModify_pskel.
      //
      bool tServiceWithMaxAndModify_pskel::
      _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
                                 const ::xml_schema::ro_string& n,
                                 const ::xml_schema::ro_string& s)
      {
        if (n == "modify" && ns.empty ())
        {
          if (this->modify_parser_)
          {
            this->modify_parser_->pre ();
            this->modify_parser_->_pre_impl ();
            this->modify_parser_->_characters (s);
            this->modify_parser_->_post_impl ();
            bool tmp (this->modify_parser_->post_boolean ());
            this->modify (tmp);
          }

          return true;
        }

        return this->::IEC61850::SCL::Validation::tServiceWithMax_pskel::_attribute_impl_phase_one (ns, n, s);
      }

      // Attribute validation and dispatch functions for tServiceWithMaxAndMaxAttributesAndModify_pskel.
      //
      bool tServiceWithMaxAndMaxAttributesAndModify_pskel::
      _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
                                 const ::xml_schema::ro_string& n,
                                 const ::xml_schema::ro_string& s)
      {
        if (n == "modify" && ns.empty ())
        {
          if (this->modify_parser_)
          {
            this->modify_parser_->pre ();
            this->modify_parser_->_pre_impl ();
            this->modify_parser_->_characters (s);
            this->modify_parser_->_post_impl ();
            bool tmp (this->modify_parser_->post_boolean ());
            this->modify (tmp);
          }

          return true;
        }

        return this->::IEC61850::SCL::Validation::tServiceWithMaxAndMaxAttributes_pskel::_attribute_impl_phase_one (ns, n, s);
      }

      // Attribute validation and dispatch functions for tClientServices_pskel.
      //
      bool tClientServices_pskel::
      _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
                                 const ::xml_schema::ro_string& n,
                                 const ::xml_schema::ro_string& s)
      {
        if (n == "goose" && ns.empty ())
        {
          if (this->goose_parser_)
          {
            this->goose_parser_->pre ();
            this->goose_parser_->_pre_impl ();
            this->goose_parser_->_characters (s);
            this->goose_parser_->_post_impl ();
            bool tmp (this->goose_parser_->post_boolean ());
            this->goose (tmp);
          }

          return true;
        }

        if (n == "gsse" && ns.empty ())
        {
          if (this->gsse_parser_)
          {
            this->gsse_parser_->pre ();
            this->gsse_parser_->_pre_impl ();
            this->gsse_parser_->_characters (s);
            this->gsse_parser_->_post_impl ();
            bool tmp (this->gsse_parser_->post_boolean ());
            this->gsse (tmp);
          }

          return true;
        }

        if (n == "bufReport" && ns.empty ())
        {
          if (this->bufReport_parser_)
          {
            this->bufReport_parser_->pre ();
            this->bufReport_parser_->_pre_impl ();
            this->bufReport_parser_->_characters (s);
            this->bufReport_parser_->_post_impl ();
            bool tmp (this->bufReport_parser_->post_boolean ());
            this->bufReport (tmp);
          }

          return true;
        }

        if (n == "unbufReport" && ns.empty ())
        {
          if (this->unbufReport_parser_)
          {
            this->unbufReport_parser_->pre ();
            this->unbufReport_parser_->_pre_impl ();
            this->unbufReport_parser_->_characters (s);
            this->unbufReport_parser_->_post_impl ();
            bool tmp (this->unbufReport_parser_->post_boolean ());
            this->unbufReport (tmp);
          }

          return true;
        }

        if (n == "readLog" && ns.empty ())
        {
          if (this->readLog_parser_)
          {
            this->readLog_parser_->pre ();
            this->readLog_parser_->_pre_impl ();
            this->readLog_parser_->_characters (s);
            this->readLog_parser_->_post_impl ();
            bool tmp (this->readLog_parser_->post_boolean ());
            this->readLog (tmp);
          }

          return true;
        }

        return false;
      }

      // Attribute validation and dispatch functions for tServiceSettings_pskel.
      //
      bool tServiceSettings_pskel::
      _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
                                 const ::xml_schema::ro_string& n,
                                 const ::xml_schema::ro_string& s)
      {
        if (n == "cbName" && ns.empty ())
        {
          if (this->cbName_parser_)
          {
            this->cbName_parser_->pre ();
            this->cbName_parser_->_pre_impl ();
            this->cbName_parser_->_characters (s);
            this->cbName_parser_->_post_impl ();
            this->cbName_parser_->post_tServiceSettingsEnum ();
            this->cbName ();
          }

          return true;
        }

        if (n == "datSet" && ns.empty ())
        {
          if (this->datSet_parser_)
          {
            this->datSet_parser_->pre ();
            this->datSet_parser_->_pre_impl ();
            this->datSet_parser_->_characters (s);
            this->datSet_parser_->_post_impl ();
            this->datSet_parser_->post_tServiceSettingsEnum ();
            this->datSet ();
          }

          return true;
        }

        return false;
      }

      // Attribute validation and dispatch functions for tReportSettings_pskel.
      //
      bool tReportSettings_pskel::
      _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
                                 const ::xml_schema::ro_string& n,
                                 const ::xml_schema::ro_string& s)
      {
        if (n == "rptID" && ns.empty ())
        {
          if (this->rptID_parser_)
          {
            this->rptID_parser_->pre ();
            this->rptID_parser_->_pre_impl ();
            this->rptID_parser_->_characters (s);
            this->rptID_parser_->_post_impl ();
            this->rptID_parser_->post_tServiceSettingsEnum ();
            this->rptID ();
          }

          return true;
        }

        if (n == "optFields" && ns.empty ())
        {
          if (this->optFields_parser_)
          {
            this->optFields_parser_->pre ();
            this->optFields_parser_->_pre_impl ();
            this->optFields_parser_->_characters (s);
            this->optFields_parser_->_post_impl ();
            this->optFields_parser_->post_tServiceSettingsEnum ();
            this->optFields ();
          }

          return true;
        }

        if (n == "bufTime" && ns.empty ())
        {
          if (this->bufTime_parser_)
          {
            this->bufTime_parser_->pre ();
            this->bufTime_parser_->_pre_impl ();
            this->bufTime_parser_->_characters (s);
            this->bufTime_parser_->_post_impl ();
            this->bufTime_parser_->post_tServiceSettingsEnum ();
            this->bufTime ();
          }

          return true;
        }

        if (n == "trgOps" && ns.empty ())
        {
          if (this->trgOps_parser_)
          {
            this->trgOps_parser_->pre ();
            this->trgOps_parser_->_pre_impl ();
            this->trgOps_parser_->_characters (s);
            this->trgOps_parser_->_post_impl ();
            this->trgOps_parser_->post_tServiceSettingsEnum ();
            this->trgOps ();
          }

          return true;
        }

        if (n == "intgPd" && ns.empty ())
        {
          if (this->intgPd_parser_)
          {
            this->intgPd_parser_->pre ();
            this->intgPd_parser_->_pre_impl ();
            this->intgPd_parser_->_characters (s);
            this->intgPd_parser_->_post_impl ();
            this->intgPd_parser_->post_tServiceSettingsEnum ();
            this->intgPd ();
          }

          return true;
        }

        return this->::IEC61850::SCL::Validation::tServiceSettings_pskel::_attribute_impl_phase_one (ns, n, s);
      }

      // Attribute validation and dispatch functions for tLogSettings_pskel.
      //
      bool tLogSettings_pskel::
      _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
                                 const ::xml_schema::ro_string& n,
                                 const ::xml_schema::ro_string& s)
      {
        if (n == "logEna" && ns.empty ())
        {
          if (this->logEna_parser_)
          {
            this->logEna_parser_->pre ();
            this->logEna_parser_->_pre_impl ();
            this->logEna_parser_->_characters (s);
            this->logEna_parser_->_post_impl ();
            this->logEna_parser_->post_tServiceSettingsEnum ();
            this->logEna ();
          }

          return true;
        }

        if (n == "trgOps" && ns.empty ())
        {
          if (this->trgOps_parser_)
          {
            this->trgOps_parser_->pre ();
            this->trgOps_parser_->_pre_impl ();
            this->trgOps_parser_->_characters (s);
            this->trgOps_parser_->_post_impl ();
            this->trgOps_parser_->post_tServiceSettingsEnum ();
            this->trgOps ();
          }

          return true;
        }

        if (n == "intgPd" && ns.empty ())
        {
          if (this->intgPd_parser_)
          {
            this->intgPd_parser_->pre ();
            this->intgPd_parser_->_pre_impl ();
            this->intgPd_parser_->_characters (s);
            this->intgPd_parser_->_post_impl ();
            this->intgPd_parser_->post_tServiceSettingsEnum ();
            this->intgPd ();
          }

          return true;
        }

        return this->::IEC61850::SCL::Validation::tServiceSettings_pskel::_attribute_impl_phase_one (ns, n, s);
      }

      // Attribute validation and dispatch functions for tGSESettings_pskel.
      //
      bool tGSESettings_pskel::
      _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
                                 const ::xml_schema::ro_string& n,
                                 const ::xml_schema::ro_string& s)
      {
        if (n == "appID" && ns.empty ())
        {
          if (this->appID_parser_)
          {
            this->appID_parser_->pre ();
            this->appID_parser_->_pre_impl ();
            this->appID_parser_->_characters (s);
            this->appID_parser_->_post_impl ();
            this->appID_parser_->post_tServiceSettingsEnum ();
            this->appID ();
          }

          return true;
        }

        if (n == "dataLabel" && ns.empty ())
        {
          if (this->dataLabel_parser_)
          {
            this->dataLabel_parser_->pre ();
            this->dataLabel_parser_->_pre_impl ();
            this->dataLabel_parser_->_characters (s);
            this->dataLabel_parser_->_post_impl ();
            this->dataLabel_parser_->post_tServiceSettingsEnum ();
            this->dataLabel ();
          }

          return true;
        }

        return this->::IEC61850::SCL::Validation::tServiceSettings_pskel::_attribute_impl_phase_one (ns, n, s);
      }

      // Attribute validation and dispatch functions for tSMVSettings_pskel.
      //
      bool tSMVSettings_pskel::
      _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
                                 const ::xml_schema::ro_string& n,
                                 const ::xml_schema::ro_string& s)
      {
        if (n == "svID" && ns.empty ())
        {
          if (this->svID_parser_)
          {
            this->svID_parser_->pre ();
            this->svID_parser_->_pre_impl ();
            this->svID_parser_->_characters (s);
            this->svID_parser_->_post_impl ();
            this->svID_parser_->post_tServiceSettingsEnum ();
            this->svID ();
          }

          return true;
        }

        if (n == "optFields" && ns.empty ())
        {
          if (this->optFields_parser_)
          {
            this->optFields_parser_->pre ();
            this->optFields_parser_->_pre_impl ();
            this->optFields_parser_->_characters (s);
            this->optFields_parser_->_post_impl ();
            this->optFields_parser_->post_tServiceSettingsEnum ();
            this->optFields ();
          }

          return true;
        }

        if (n == "smpRate" && ns.empty ())
        {
          if (this->smpRate_parser_)
          {
            this->smpRate_parser_->pre ();
            this->smpRate_parser_->_pre_impl ();
            this->smpRate_parser_->_characters (s);
            this->smpRate_parser_->_post_impl ();
            this->smpRate_parser_->post_tServiceSettingsEnum ();
            this->smpRate ();
          }

          return true;
        }

        return this->::IEC61850::SCL::Validation::tServiceSettings_pskel::_attribute_impl_phase_one (ns, n, s);
      }

      // Attribute validation and dispatch functions for tConfLNs_pskel.
      //
      bool tConfLNs_pskel::
      _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
                                 const ::xml_schema::ro_string& n,
                                 const ::xml_schema::ro_string& s)
      {
        if (n == "fixPrefix" && ns.empty ())
        {
          if (this->fixPrefix_parser_)
          {
            this->fixPrefix_parser_->pre ();
            this->fixPrefix_parser_->_pre_impl ();
            this->fixPrefix_parser_->_characters (s);
            this->fixPrefix_parser_->_post_impl ();
            bool tmp (this->fixPrefix_parser_->post_boolean ());
            this->fixPrefix (tmp);
          }

          return true;
        }

        if (n == "fixLnInst" && ns.empty ())
        {
          if (this->fixLnInst_parser_)
          {
            this->fixLnInst_parser_->pre ();
            this->fixLnInst_parser_->_pre_impl ();
            this->fixLnInst_parser_->_characters (s);
            this->fixLnInst_parser_->_post_impl ();
            bool tmp (this->fixLnInst_parser_->post_boolean ());
            this->fixLnInst (tmp);
          }

          return true;
        }

        return false;
      }

      // Attribute validation and dispatch functions for Authentication_pskel.
      //
      bool Authentication_pskel::
      _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
                                 const ::xml_schema::ro_string& n,
                                 const ::xml_schema::ro_string& s)
      {
        if (n == "none" && ns.empty ())
        {
          if (this->none_parser_)
          {
            this->none_parser_->pre ();
            this->none_parser_->_pre_impl ();
            this->none_parser_->_characters (s);
            this->none_parser_->_post_impl ();
            bool tmp (this->none_parser_->post_boolean ());
            this->none (tmp);
          }

          return true;
        }

        if (n == "password" && ns.empty ())
        {
          if (this->password_parser_)
          {
            this->password_parser_->pre ();
            this->password_parser_->_pre_impl ();
            this->password_parser_->_characters (s);
            this->password_parser_->_post_impl ();
            bool tmp (this->password_parser_->post_boolean ());
            this->password (tmp);
          }

          return true;
        }

        if (n == "weak" && ns.empty ())
        {
          if (this->weak_parser_)
          {
            this->weak_parser_->pre ();
            this->weak_parser_->_pre_impl ();
            this->weak_parser_->_characters (s);
            this->weak_parser_->_post_impl ();
            bool tmp (this->weak_parser_->post_boolean ());
            this->weak (tmp);
          }

          return true;
        }

        if (n == "strong" && ns.empty ())
        {
          if (this->strong_parser_)
          {
            this->strong_parser_->pre ();
            this->strong_parser_->_pre_impl ();
            this->strong_parser_->_characters (s);
            this->strong_parser_->_post_impl ();
            bool tmp (this->strong_parser_->post_boolean ());
            this->strong (tmp);
          }

          return true;
        }

        if (n == "certificate" && ns.empty ())
        {
          if (this->certificate_parser_)
          {
            this->certificate_parser_->pre ();
            this->certificate_parser_->_pre_impl ();
            this->certificate_parser_->_characters (s);
            this->certificate_parser_->_post_impl ();
            bool tmp (this->certificate_parser_->post_boolean ());
            this->certificate (tmp);
          }

          return true;
        }

        return false;
      }

      // Attribute validation and dispatch functions for OptFields_pskel.
      //
      bool OptFields_pskel::
      _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
                                 const ::xml_schema::ro_string& n,
                                 const ::xml_schema::ro_string& s)
      {
        if (n == "seqNum" && ns.empty ())
        {
          if (this->seqNum_parser_)
          {
            this->seqNum_parser_->pre ();
            this->seqNum_parser_->_pre_impl ();
            this->seqNum_parser_->_characters (s);
            this->seqNum_parser_->_post_impl ();
            bool tmp (this->seqNum_parser_->post_boolean ());
            this->seqNum (tmp);
          }

          return true;
        }

        if (n == "timeStamp" && ns.empty ())
        {
          if (this->timeStamp_parser_)
          {
            this->timeStamp_parser_->pre ();
            this->timeStamp_parser_->_pre_impl ();
            this->timeStamp_parser_->_characters (s);
            this->timeStamp_parser_->_post_impl ();
            bool tmp (this->timeStamp_parser_->post_boolean ());
            this->timeStamp (tmp);
          }

          return true;
        }

        if (n == "dataSet" && ns.empty ())
        {
          if (this->dataSet_parser_)
          {
            this->dataSet_parser_->pre ();
            this->dataSet_parser_->_pre_impl ();
            this->dataSet_parser_->_characters (s);
            this->dataSet_parser_->_post_impl ();
            bool tmp (this->dataSet_parser_->post_boolean ());
            this->dataSet (tmp);
          }

          return true;
        }

        if (n == "reasonCode" && ns.empty ())
        {
          if (this->reasonCode_parser_)
          {
            this->reasonCode_parser_->pre ();
            this->reasonCode_parser_->_pre_impl ();
            this->reasonCode_parser_->_characters (s);
            this->reasonCode_parser_->_post_impl ();
            bool tmp (this->reasonCode_parser_->post_boolean ());
            this->reasonCode (tmp);
          }

          return true;
        }

        if (n == "dataRef" && ns.empty ())
        {
          if (this->dataRef_parser_)
          {
            this->dataRef_parser_->pre ();
            this->dataRef_parser_->_pre_impl ();
            this->dataRef_parser_->_characters (s);
            this->dataRef_parser_->_post_impl ();
            bool tmp (this->dataRef_parser_->post_boolean ());
            this->dataRef (tmp);
          }

          return true;
        }

        if (n == "entryID" && ns.empty ())
        {
          if (this->entryID_parser_)
          {
            this->entryID_parser_->pre ();
            this->entryID_parser_->_pre_impl ();
            this->entryID_parser_->_characters (s);
            this->entryID_parser_->_post_impl ();
            bool tmp (this->entryID_parser_->post_boolean ());
            this->entryID (tmp);
          }

          return true;
        }

        if (n == "configRef" && ns.empty ())
        {
          if (this->configRef_parser_)
          {
            this->configRef_parser_->pre ();
            this->configRef_parser_->_pre_impl ();
            this->configRef_parser_->_characters (s);
            this->configRef_parser_->_post_impl ();
            bool tmp (this->configRef_parser_->post_boolean ());
            this->configRef (tmp);
          }

          return true;
        }

        return false;
      }

      // Attribute validation and dispatch functions for SmvOpts_pskel.
      //
      bool SmvOpts_pskel::
      _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
                                 const ::xml_schema::ro_string& n,
                                 const ::xml_schema::ro_string& s)
      {
        if (n == "refreshTime" && ns.empty ())
        {
          if (this->refreshTime_parser_)
          {
            this->refreshTime_parser_->pre ();
            this->refreshTime_parser_->_pre_impl ();
            this->refreshTime_parser_->_characters (s);
            this->refreshTime_parser_->_post_impl ();
            bool tmp (this->refreshTime_parser_->post_boolean ());
            this->refreshTime (tmp);
          }

          return true;
        }

        if (n == "sampleSynchronized" && ns.empty ())
        {
          if (this->sampleSynchronized_parser_)
          {
            this->sampleSynchronized_parser_->pre ();
            this->sampleSynchronized_parser_->_pre_impl ();
            this->sampleSynchronized_parser_->_characters (s);
            this->sampleSynchronized_parser_->_post_impl ();
            bool tmp (this->sampleSynchronized_parser_->post_boolean ());
            this->sampleSynchronized (tmp);
          }

          return true;
        }

        if (n == "sampleRate" && ns.empty ())
        {
          if (this->sampleRate_parser_)
          {
            this->sampleRate_parser_->pre ();
            this->sampleRate_parser_->_pre_impl ();
            this->sampleRate_parser_->_characters (s);
            this->sampleRate_parser_->_post_impl ();
            bool tmp (this->sampleRate_parser_->post_boolean ());
            this->sampleRate (tmp);
          }

          return true;
        }

        if (n == "dataSet" && ns.empty ())
        {
          if (this->dataSet_parser_)
          {
            this->dataSet_parser_->pre ();
            this->dataSet_parser_->_pre_impl ();
            this->dataSet_parser_->_characters (s);
            this->dataSet_parser_->_post_impl ();
            bool tmp (this->dataSet_parser_->post_boolean ());
            this->dataSet (tmp);
          }

          return true;
        }

        if (n == "security" && ns.empty ())
        {
          if (this->security_parser_)
          {
            this->security_parser_->pre ();
            this->security_parser_->_pre_impl ();
            this->security_parser_->_characters (s);
            this->security_parser_->_post_impl ();
            bool tmp (this->security_parser_->post_boolean ());
            this->security (tmp);
          }

          return true;
        }

        return false;
      }
    }
  }
}

namespace IEC61850
{
  namespace SCL
  {
    namespace Validation
    {
      // Character validation functions for tAccessControl_pskel.
      //
      bool tAccessControl_pskel::
      _characters_impl (const ::xml_schema::ro_string& s)
      {
        this->_any_characters (s);
        return true;
      }

      // Character validation functions for tLog_pskel.
      //
      bool tLog_pskel::
      _characters_impl (const ::xml_schema::ro_string& s)
      {
        this->_any_characters (s);
        return true;
      }
    }
  }
}

// Begin epilogue.
//
//
// End epilogue.

